!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==typeof c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], false, function($__System) {
var _dereq_ = this.require, exports = this.exports, module = this.module;
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
(function() {
var define = $__System.amdDefine;
define("2", ["exports", "3"], function(exports, _aureliaPal) {
  'use strict';
  Number.isNaN = Number.isNaN || function(value) {
    return value !== value;
  };
  Number.isFinite = Number.isFinite || function(value) {
    return typeof value === "number" && isFinite(value);
  };
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(searchString, position) {
      var subjectString = this.toString();
      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.substr(position, searchString.length) === searchString;
    };
  }
  if (!Array.from) {
    Array.from = (function() {
      var toStr = Object.prototype.toString;
      var isCallable = function isCallable(fn) {
        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
      };
      var toInteger = function toInteger(value) {
        var number = Number(value);
        if (isNaN(number)) {
          return 0;
        }
        if (number === 0 || !isFinite(number)) {
          return number;
        }
        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
      };
      var maxSafeInteger = Math.pow(2, 53) - 1;
      var toLength = function toLength(value) {
        var len = toInteger(value);
        return Math.min(Math.max(len, 0), maxSafeInteger);
      };
      return function from(arrayLike) {
        var C = this;
        var items = Object(arrayLike);
        if (arrayLike == null) {
          throw new TypeError("Array.from requires an array-like object - not null or undefined");
        }
        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
        var T;
        if (typeof mapFn !== 'undefined') {
          if (!isCallable(mapFn)) {
            throw new TypeError('Array.from: when provided, the second argument must be a function');
          }
          if (arguments.length > 2) {
            T = arguments[2];
          }
        }
        var len = toLength(items.length);
        var A = isCallable(C) ? Object(new C(len)) : new Array(len);
        var k = 0;
        var kValue;
        while (k < len) {
          kValue = items[k];
          if (mapFn) {
            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
          } else {
            A[k] = kValue;
          }
          k += 1;
        }
        A.length = len;
        return A;
      };
    })();
  }
  if (!Array.prototype.find) {
    Array.prototype.find = function(predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;
      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return value;
        }
      }
      return undefined;
    };
  }
  if (!Array.prototype.findIndex) {
    Array.prototype.findIndex = function(predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;
      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Array.prototype.includes) {
    Array.prototype.includes = function(searchElement) {
      var O = Object(this);
      var len = parseInt(O.length) || 0;
      if (len === 0) {
        return false;
      }
      var n = parseInt(arguments[1]) || 0;
      var k;
      if (n >= 0) {
        k = n;
      } else {
        k = len + n;
        if (k < 0) {
          k = 0;
        }
      }
      var currentElement;
      while (k < len) {
        currentElement = O[k];
        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
          return true;
        }
        k++;
      }
      return false;
    };
  }
  if (typeof Object.assign !== 'function') {
    Object.assign = function(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  }
  (function(global) {
    var i = undefined;
    var defineProperty = Object.defineProperty;
    var is = function is(a, b) {
      return a === b || a !== a && b !== b;
    };
    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
      global.Map = createCollection({
        'delete': sharedDelete,
        has: mapHas,
        get: sharedGet,
        set: sharedSet,
        keys: sharedKeys,
        values: sharedValues,
        entries: mapEntries,
        forEach: sharedForEach,
        clear: sharedClear
      });
    }
    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
      global.Set = createCollection({
        has: setHas,
        add: sharedAdd,
        'delete': sharedDelete,
        clear: sharedClear,
        keys: sharedValues,
        values: sharedValues,
        entries: setEntries,
        forEach: sharedForEach
      });
    }
    function createCollection(proto, objectOnly) {
      function Collection(a) {
        if (!this || this.constructor !== Collection)
          return new Collection(a);
        this._keys = [];
        this._values = [];
        this._itp = [];
        this.objectOnly = objectOnly;
        if (a)
          init.call(this, a);
      }
      if (!objectOnly) {
        defineProperty(proto, 'size', {get: sharedSize});
      }
      proto.constructor = Collection;
      Collection.prototype = proto;
      return Collection;
    }
    function init(a) {
      var i;
      if (this.add)
        a.forEach(this.add, this);
      else
        a.forEach(function(a) {
          this.set(a[0], a[1]);
        }, this);
    }
    function sharedDelete(key) {
      if (this.has(key)) {
        this._keys.splice(i, 1);
        this._values.splice(i, 1);
        this._itp.forEach(function(p) {
          if (i < p[0])
            p[0]--;
        });
      }
      return -1 < i;
    }
    ;
    function sharedGet(key) {
      return this.has(key) ? this._values[i] : undefined;
    }
    function has(list, key) {
      if (this.objectOnly && key !== Object(key))
        throw new TypeError("Invalid value used as weak collection key");
      if (key != key || key === 0)
        for (i = list.length; i-- && !is(list[i], key); ) {}
      else
        i = list.indexOf(key);
      return -1 < i;
    }
    function setHas(value) {
      return has.call(this, this._values, value);
    }
    function mapHas(value) {
      return has.call(this, this._keys, value);
    }
    function sharedSet(key, value) {
      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
      return this;
    }
    function sharedAdd(value) {
      if (!this.has(value))
        this._values.push(value);
      return this;
    }
    function sharedClear() {
      (this._keys || 0).length = this._values.length = 0;
    }
    function sharedKeys() {
      return sharedIterator(this._itp, this._keys);
    }
    function sharedValues() {
      return sharedIterator(this._itp, this._values);
    }
    function mapEntries() {
      return sharedIterator(this._itp, this._keys, this._values);
    }
    function setEntries() {
      return sharedIterator(this._itp, this._values, this._values);
    }
    function sharedIterator(itp, array, array2) {
      var p = [0],
          done = false;
      itp.push(p);
      return {next: function next() {
          var v,
              k = p[0];
          if (!done && k < array.length) {
            v = array2 ? [array[k], array2[k]] : array[k];
            p[0]++;
          } else {
            done = true;
            itp.splice(itp.indexOf(p), 1);
          }
          return {
            done: done,
            value: v
          };
        }};
    }
    function sharedSize() {
      return this._values.length;
    }
    function sharedForEach(callback, context) {
      var it = this.entries();
      for (; ; ) {
        var r = it.next();
        if (r.done)
          break;
        callback.call(context, r.value[1], r.value[0], this);
      }
    }
  })(_aureliaPal.PLATFORM.global);
  var emptyMetadata = Object.freeze({});
  var metadataContainerKey = '__metadata__';
  var bind = Function.prototype.bind;
  if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
    _aureliaPal.PLATFORM.global.Reflect = {};
  }
  if (typeof Reflect.getOwnMetadata !== 'function') {
    Reflect.getOwnMetadata = function(metadataKey, target, targetKey) {
      return ((target[metadataContainerKey] || emptyMetadata)[targetKey] || emptyMetadata)[metadataKey];
    };
  }
  if (typeof Reflect.defineMetadata !== 'function') {
    Reflect.defineMetadata = function(metadataKey, metadataValue, target, targetKey) {
      var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
      var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
      targetContainer[metadataKey] = metadataValue;
    };
  }
  if (typeof Reflect.metadata !== 'function') {
    Reflect.metadata = function(metadataKey, metadataValue) {
      return function(target, targetKey) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
      };
    };
  }
  if (typeof Reflect.construct !== 'function') {
    Reflect.construct = function(Target, args) {
      if (args) {
        switch (args.length) {
          case 0:
            return new Target();
          case 1:
            return new Target(args[0]);
          case 2:
            return new Target(args[0], args[1]);
          case 3:
            return new Target(args[0], args[1], args[2]);
          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        }
      }
      var a = [null];
      a.push.apply(a, args);
      return new (bind.apply(Target, a))();
    };
  }
});

})();
$__System.register('3', [], function (_export, _context) {
    "use strict";

    var FEATURE, PLATFORM, DOM;
    function AggregateError(message, innerError, skipIfAlreadyAggregate) {
        if (innerError) {
            if (innerError.innerError && skipIfAlreadyAggregate) {
                return innerError;
            }
            var separator = '\n------------------------------------------------\n';
            message += separator + 'Inner Error:\n';
            if (typeof innerError === 'string') {
                message += 'Message: ' + innerError;
            } else {
                if (innerError.message) {
                    message += 'Message: ' + innerError.message;
                } else {
                    message += 'Unknown Inner Error Type. Displaying Inner Error as JSON:\n ' + JSON.stringify(innerError, null, '  ');
                }
                if (innerError.stack) {
                    message += '\nInner Error Stack:\n' + innerError.stack;
                    message += '\nEnd Inner Error Stack';
                }
            }
            message += separator;
        }
        var e = new Error(message);
        if (innerError) {
            e.innerError = innerError;
        }
        return e;
    }

    function initializePAL(callback) {
        if (typeof Object.getPropertyDescriptor !== 'function') {
            Object.getPropertyDescriptor = function (subject, name) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = Object.getPrototypeOf(subject);
                while (typeof pd === 'undefined' && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = Object.getPrototypeOf(proto);
                }
                return pd;
            };
        }
        callback(PLATFORM, FEATURE, DOM);
    }

    return {
        setters: [],
        execute: function () {
            _export('FEATURE', FEATURE = {});

            _export('PLATFORM', PLATFORM = {
                noop: function noop() {},
                eachModule: function eachModule() {}
            });

            PLATFORM.global = function () {
                if (typeof self !== 'undefined') {
                    return self;
                }
                if (typeof global !== 'undefined') {
                    return global;
                }
                return new Function('return this')();
            }();

            _export('DOM', DOM = {});

            _export('AggregateError', AggregateError);

            _export('FEATURE', FEATURE);

            _export('PLATFORM', PLATFORM);

            _export('DOM', DOM);

            _export('initializePAL', initializePAL);
        }
    };
});
(function() {
var define = $__System.amdDefine;
define("4", ["5", "6", "7", "8"], function(defined, defineProperties, DeveloperError, Event) {
  'use strict';
  function CallbackProperty(callback, isConstant) {
    this._callback = undefined;
    this._isConstant = undefined;
    this._definitionChanged = new Event();
    this.setCallback(callback, isConstant);
  }
  defineProperties(CallbackProperty.prototype, {
    isConstant: {get: function() {
        return this._isConstant;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }}
  });
  CallbackProperty.prototype.getValue = function(time, result) {
    return this._callback(time, result);
  };
  CallbackProperty.prototype.setCallback = function(callback, isConstant) {
    if (!defined(callback)) {
      throw new DeveloperError('callback is required.');
    }
    if (!defined(isConstant)) {
      throw new DeveloperError('isConstant is required.');
    }
    var changed = this._callback !== callback || this._isConstant !== isConstant;
    this._callback = callback;
    this._isConstant = isConstant;
    if (changed) {
      this._definitionChanged.raiseEvent(this);
    }
  };
  CallbackProperty.prototype.equals = function(other) {
    return this === other || (other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant);
  };
  return CallbackProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("9", ["a", "5", "6", "b", "7", "c", "d", "e", "f", "10"], function(Cartesian2, defined, defineProperties, destroyObject, DeveloperError, KeyboardEventModifier, CesiumMath, ScreenSpaceEventHandler, ScreenSpaceEventType, CameraEventType) {
  'use strict';
  function getKey(type, modifier) {
    var key = type;
    if (defined(modifier)) {
      key += '+' + modifier;
    }
    return key;
  }
  function clonePinchMovement(pinchMovement, result) {
    Cartesian2.clone(pinchMovement.distance.startPosition, result.distance.startPosition);
    Cartesian2.clone(pinchMovement.distance.endPosition, result.distance.endPosition);
    Cartesian2.clone(pinchMovement.angleAndHeight.startPosition, result.angleAndHeight.startPosition);
    Cartesian2.clone(pinchMovement.angleAndHeight.endPosition, result.angleAndHeight.endPosition);
  }
  function listenToPinch(aggregator, modifier, canvas) {
    var key = getKey(CameraEventType.PINCH, modifier);
    var update = aggregator._update;
    var isDown = aggregator._isDown;
    var eventStartPosition = aggregator._eventStartPosition;
    var pressTime = aggregator._pressTime;
    var releaseTime = aggregator._releaseTime;
    update[key] = true;
    isDown[key] = false;
    eventStartPosition[key] = new Cartesian2();
    var movement = aggregator._movement[key];
    if (!defined(movement)) {
      movement = aggregator._movement[key] = {};
    }
    movement.distance = {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    };
    movement.angleAndHeight = {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    };
    movement.prevAngle = 0.0;
    aggregator._eventHandler.setInputAction(function(event) {
      aggregator._buttonsDown++;
      isDown[key] = true;
      pressTime[key] = new Date();
      Cartesian2.lerp(event.position1, event.position2, 0.5, eventStartPosition[key]);
    }, ScreenSpaceEventType.PINCH_START, modifier);
    aggregator._eventHandler.setInputAction(function() {
      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);
      isDown[key] = false;
      releaseTime[key] = new Date();
    }, ScreenSpaceEventType.PINCH_END, modifier);
    aggregator._eventHandler.setInputAction(function(mouseMovement) {
      if (isDown[key]) {
        if (!update[key]) {
          Cartesian2.clone(mouseMovement.distance.endPosition, movement.distance.endPosition);
          Cartesian2.clone(mouseMovement.angleAndHeight.endPosition, movement.angleAndHeight.endPosition);
        } else {
          clonePinchMovement(mouseMovement, movement);
          update[key] = false;
          movement.prevAngle = movement.angleAndHeight.startPosition.x;
        }
        var angle = movement.angleAndHeight.endPosition.x;
        var prevAngle = movement.prevAngle;
        var TwoPI = Math.PI * 2;
        while (angle >= (prevAngle + Math.PI)) {
          angle -= TwoPI;
        }
        while (angle < (prevAngle - Math.PI)) {
          angle += TwoPI;
        }
        movement.angleAndHeight.endPosition.x = -angle * canvas.clientWidth / 12;
        movement.angleAndHeight.startPosition.x = -prevAngle * canvas.clientWidth / 12;
      }
    }, ScreenSpaceEventType.PINCH_MOVE, modifier);
  }
  function listenToWheel(aggregator, modifier) {
    var key = getKey(CameraEventType.WHEEL, modifier);
    var update = aggregator._update;
    update[key] = true;
    var movement = aggregator._movement[key];
    if (!defined(movement)) {
      movement = aggregator._movement[key] = {};
    }
    movement.startPosition = new Cartesian2();
    movement.endPosition = new Cartesian2();
    aggregator._eventHandler.setInputAction(function(delta) {
      var arcLength = 15.0 * CesiumMath.toRadians(delta);
      if (!update[key]) {
        movement.endPosition.y = movement.endPosition.y + arcLength;
      } else {
        Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);
        movement.endPosition.x = 0.0;
        movement.endPosition.y = arcLength;
        update[key] = false;
      }
    }, ScreenSpaceEventType.WHEEL, modifier);
  }
  function listenMouseButtonDownUp(aggregator, modifier, type) {
    var key = getKey(type, modifier);
    var isDown = aggregator._isDown;
    var eventStartPosition = aggregator._eventStartPosition;
    var pressTime = aggregator._pressTime;
    var releaseTime = aggregator._releaseTime;
    isDown[key] = false;
    eventStartPosition[key] = new Cartesian2();
    var lastMovement = aggregator._lastMovement[key];
    if (!defined(lastMovement)) {
      lastMovement = aggregator._lastMovement[key] = {
        startPosition: new Cartesian2(),
        endPosition: new Cartesian2(),
        valid: false
      };
    }
    var down;
    var up;
    if (type === CameraEventType.LEFT_DRAG) {
      down = ScreenSpaceEventType.LEFT_DOWN;
      up = ScreenSpaceEventType.LEFT_UP;
    } else if (type === CameraEventType.RIGHT_DRAG) {
      down = ScreenSpaceEventType.RIGHT_DOWN;
      up = ScreenSpaceEventType.RIGHT_UP;
    } else if (type === CameraEventType.MIDDLE_DRAG) {
      down = ScreenSpaceEventType.MIDDLE_DOWN;
      up = ScreenSpaceEventType.MIDDLE_UP;
    }
    aggregator._eventHandler.setInputAction(function(event) {
      aggregator._buttonsDown++;
      lastMovement.valid = false;
      isDown[key] = true;
      pressTime[key] = new Date();
      Cartesian2.clone(event.position, eventStartPosition[key]);
    }, down, modifier);
    aggregator._eventHandler.setInputAction(function() {
      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);
      isDown[key] = false;
      releaseTime[key] = new Date();
    }, up, modifier);
  }
  function cloneMouseMovement(mouseMovement, result) {
    Cartesian2.clone(mouseMovement.startPosition, result.startPosition);
    Cartesian2.clone(mouseMovement.endPosition, result.endPosition);
  }
  function listenMouseMove(aggregator, modifier) {
    var update = aggregator._update;
    var movement = aggregator._movement;
    var lastMovement = aggregator._lastMovement;
    var isDown = aggregator._isDown;
    for (var typeName in CameraEventType) {
      if (CameraEventType.hasOwnProperty(typeName)) {
        var type = CameraEventType[typeName];
        if (defined(type)) {
          var key = getKey(type, modifier);
          update[key] = true;
          if (!defined(aggregator._lastMovement[key])) {
            aggregator._lastMovement[key] = {
              startPosition: new Cartesian2(),
              endPosition: new Cartesian2(),
              valid: false
            };
          }
          if (!defined(aggregator._movement[key])) {
            aggregator._movement[key] = {
              startPosition: new Cartesian2(),
              endPosition: new Cartesian2()
            };
          }
        }
      }
    }
    aggregator._eventHandler.setInputAction(function(mouseMovement) {
      for (var typeName in CameraEventType) {
        if (CameraEventType.hasOwnProperty(typeName)) {
          var type = CameraEventType[typeName];
          if (defined(type)) {
            var key = getKey(type, modifier);
            if (isDown[key]) {
              if (!update[key]) {
                Cartesian2.clone(mouseMovement.endPosition, movement[key].endPosition);
              } else {
                cloneMouseMovement(movement[key], lastMovement[key]);
                lastMovement[key].valid = true;
                cloneMouseMovement(mouseMovement, movement[key]);
                update[key] = false;
              }
            }
          }
        }
      }
      Cartesian2.clone(mouseMovement.endPosition, aggregator._currentMousePosition);
    }, ScreenSpaceEventType.MOUSE_MOVE, modifier);
  }
  function CameraEventAggregator(canvas) {
    if (!defined(canvas)) {
      throw new DeveloperError('canvas is required.');
    }
    this._eventHandler = new ScreenSpaceEventHandler(canvas, true);
    this._update = {};
    this._movement = {};
    this._lastMovement = {};
    this._isDown = {};
    this._eventStartPosition = {};
    this._pressTime = {};
    this._releaseTime = {};
    this._buttonsDown = 0;
    this._currentMousePosition = new Cartesian2();
    listenToWheel(this, undefined);
    listenToPinch(this, undefined, canvas);
    listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);
    listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);
    listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);
    listenMouseMove(this, undefined);
    for (var modifierName in KeyboardEventModifier) {
      if (KeyboardEventModifier.hasOwnProperty(modifierName)) {
        var modifier = KeyboardEventModifier[modifierName];
        if (defined(modifier)) {
          listenToWheel(this, modifier);
          listenToPinch(this, modifier, canvas);
          listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);
          listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);
          listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);
          listenMouseMove(this, modifier);
        }
      }
    }
  }
  defineProperties(CameraEventAggregator.prototype, {
    currentMousePosition: {get: function() {
        return this._currentMousePosition;
      }},
    anyButtonDown: {get: function() {
        var wheelMoved = !this._update[getKey(CameraEventType.WHEEL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];
        return this._buttonsDown > 0 || wheelMoved;
      }}
  });
  CameraEventAggregator.prototype.isMoving = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return !this._update[key];
  };
  CameraEventAggregator.prototype.getMovement = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    var movement = this._movement[key];
    return movement;
  };
  CameraEventAggregator.prototype.getLastMovement = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    var lastMovement = this._lastMovement[key];
    if (lastMovement.valid) {
      return lastMovement;
    }
    return undefined;
  };
  CameraEventAggregator.prototype.isButtonDown = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._isDown[key];
  };
  CameraEventAggregator.prototype.getStartMousePosition = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    if (type === CameraEventType.WHEEL) {
      return this._currentMousePosition;
    }
    var key = getKey(type, modifier);
    return this._eventStartPosition[key];
  };
  CameraEventAggregator.prototype.getButtonPressTime = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._pressTime[key];
  };
  CameraEventAggregator.prototype.getButtonReleaseTime = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._releaseTime[key];
  };
  CameraEventAggregator.prototype.reset = function() {
    for (var name in this._update) {
      if (this._update.hasOwnProperty(name)) {
        this._update[name] = true;
      }
    }
  };
  CameraEventAggregator.prototype.isDestroyed = function() {
    return false;
  };
  CameraEventAggregator.prototype.destroy = function() {
    this._eventHandler = this._eventHandler && this._eventHandler.destroy();
    return destroyObject(this);
  };
  return CameraEventAggregator;
});

})();
(function() {
var define = $__System.amdDefine;
define("10", ["11"], function(freezeObject) {
  'use strict';
  var CameraEventType = {
    LEFT_DRAG: 0,
    RIGHT_DRAG: 1,
    MIDDLE_DRAG: 2,
    WHEEL: 3,
    PINCH: 4
  };
  return freezeObject(CameraEventType);
});

})();
(function() {
var define = $__System.amdDefine;
define("12", ["11"], function(freezeObject) {
  'use strict';
  var ClockRange = {
    UNBOUNDED: 0,
    CLAMPED: 1,
    LOOP_STOP: 2
  };
  return freezeObject(ClockRange);
});

})();
(function() {
var define = $__System.amdDefine;
define("13", ["12", "14", "15", "5", "6", "7", "8", "16", "17"], function(ClockRange, ClockStep, defaultValue, defined, defineProperties, DeveloperError, Event, getTimestamp, JulianDate) {
  'use strict';
  function Clock(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var currentTime = options.currentTime;
    var startTime = options.startTime;
    var stopTime = options.stopTime;
    if (!defined(currentTime)) {
      if (defined(startTime)) {
        currentTime = JulianDate.clone(startTime);
      } else if (defined(stopTime)) {
        currentTime = JulianDate.addDays(stopTime, -1.0, new JulianDate());
      } else {
        currentTime = JulianDate.now();
      }
    } else {
      currentTime = JulianDate.clone(currentTime);
    }
    if (!defined(startTime)) {
      startTime = JulianDate.clone(currentTime);
    } else {
      startTime = JulianDate.clone(startTime);
    }
    if (!defined(stopTime)) {
      stopTime = JulianDate.addDays(startTime, 1.0, new JulianDate());
    } else {
      stopTime = JulianDate.clone(stopTime);
    }
    if (JulianDate.greaterThan(startTime, stopTime)) {
      throw new DeveloperError('startTime must come before stopTime.');
    }
    this.startTime = startTime;
    this.stopTime = stopTime;
    this.clockRange = defaultValue(options.clockRange, ClockRange.UNBOUNDED);
    this.canAnimate = defaultValue(options.canAnimate, true);
    this.onTick = new Event();
    this._currentTime = undefined;
    this._multiplier = undefined;
    this._clockStep = undefined;
    this._shouldAnimate = undefined;
    this._lastSystemTime = getTimestamp();
    this.currentTime = currentTime;
    this.multiplier = defaultValue(options.multiplier, 1.0);
    this.clockStep = defaultValue(options.clockStep, ClockStep.SYSTEM_CLOCK_MULTIPLIER);
    this.shouldAnimate = defaultValue(options.shouldAnimate, true);
  }
  defineProperties(Clock.prototype, {
    currentTime: {
      get: function() {
        return this._currentTime;
      },
      set: function(value) {
        if (JulianDate.equals(this._currentTime, value)) {
          return;
        }
        if (this._clockStep === ClockStep.SYSTEM_CLOCK) {
          this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        }
        this._currentTime = value;
      }
    },
    multiplier: {
      get: function() {
        return this._multiplier;
      },
      set: function(value) {
        if (this._multiplier === value) {
          return;
        }
        if (this._clockStep === ClockStep.SYSTEM_CLOCK) {
          this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        }
        this._multiplier = value;
      }
    },
    clockStep: {
      get: function() {
        return this._clockStep;
      },
      set: function(value) {
        if (value === ClockStep.SYSTEM_CLOCK) {
          this._multiplier = 1.0;
          this._shouldAnimate = true;
          this._currentTime = JulianDate.now();
        }
        this._clockStep = value;
      }
    },
    shouldAnimate: {
      get: function() {
        return this._shouldAnimate;
      },
      set: function(value) {
        if (this._shouldAnimate === value) {
          return;
        }
        if (this._clockStep === ClockStep.SYSTEM_CLOCK) {
          this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        }
        this._shouldAnimate = value;
      }
    }
  });
  Clock.prototype.tick = function() {
    var currentSystemTime = getTimestamp();
    var currentTime = JulianDate.clone(this._currentTime);
    if (this.canAnimate && this._shouldAnimate) {
      var clockStep = this._clockStep;
      if (clockStep === ClockStep.SYSTEM_CLOCK) {
        currentTime = JulianDate.now(currentTime);
      } else {
        var multiplier = this._multiplier;
        if (clockStep === ClockStep.TICK_DEPENDENT) {
          currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);
        } else {
          var milliseconds = currentSystemTime - this._lastSystemTime;
          currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / 1000.0), currentTime);
        }
        var clockRange = this.clockRange;
        var startTime = this.startTime;
        var stopTime = this.stopTime;
        if (clockRange === ClockRange.CLAMPED) {
          if (JulianDate.lessThan(currentTime, startTime)) {
            currentTime = JulianDate.clone(startTime, currentTime);
          } else if (JulianDate.greaterThan(currentTime, stopTime)) {
            currentTime = JulianDate.clone(stopTime, currentTime);
          }
        } else if (clockRange === ClockRange.LOOP_STOP) {
          if (JulianDate.lessThan(currentTime, startTime)) {
            currentTime = JulianDate.clone(startTime, currentTime);
          }
          while (JulianDate.greaterThan(currentTime, stopTime)) {
            currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);
          }
        }
      }
    }
    this._currentTime = currentTime;
    this._lastSystemTime = currentSystemTime;
    this.onTick.raiseEvent(this);
    return currentTime;
  };
  return Clock;
});

})();
(function() {
var define = $__System.amdDefine;
define("14", ["11"], function(freezeObject) {
  'use strict';
  var ClockStep = {
    TICK_DEPENDENT: 0,
    SYSTEM_CLOCK_MULTIPLIER: 1,
    SYSTEM_CLOCK: 2
  };
  return freezeObject(ClockStep);
});

})();
(function() {
var define = $__System.amdDefine;
define("18", ["19", "5", "6", "7", "d", "1a", "1b"], function(createGuid, defined, defineProperties, DeveloperError, CesiumMath, Entity, EntityCollection) {
  'use strict';
  var entityOptionsScratch = {id: undefined};
  var entityIdScratch = new Array(2);
  function clean(entity) {
    var propertyNames = entity.propertyNames;
    var propertyNamesLength = propertyNames.length;
    for (var i = 0; i < propertyNamesLength; i++) {
      entity[propertyNames[i]] = undefined;
    }
  }
  function subscribeToEntity(that, eventHash, collectionId, entity) {
    entityIdScratch[0] = collectionId;
    entityIdScratch[1] = entity.id;
    eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);
  }
  function unsubscribeFromEntity(that, eventHash, collectionId, entity) {
    entityIdScratch[0] = collectionId;
    entityIdScratch[1] = entity.id;
    var id = JSON.stringify(entityIdScratch);
    eventHash[id]();
    eventHash[id] = undefined;
  }
  function recomposite(that) {
    that._shouldRecomposite = true;
    if (that._suspendCount !== 0) {
      return;
    }
    var collections = that._collections;
    var collectionsLength = collections.length;
    var collectionsCopy = that._collectionsCopy;
    var collectionsCopyLength = collectionsCopy.length;
    var i;
    var entity;
    var entities;
    var iEntities;
    var collection;
    var composite = that._composite;
    var newEntities = new EntityCollection(that);
    var eventHash = that._eventHash;
    var collectionId;
    for (i = 0; i < collectionsCopyLength; i++) {
      collection = collectionsCopy[i];
      collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
      entities = collection.values;
      collectionId = collection.id;
      for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
        entity = entities[iEntities];
        unsubscribeFromEntity(that, eventHash, collectionId, entity);
      }
    }
    for (i = collectionsLength - 1; i >= 0; i--) {
      collection = collections[i];
      collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
      entities = collection.values;
      collectionId = collection.id;
      for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
        entity = entities[iEntities];
        subscribeToEntity(that, eventHash, collectionId, entity);
        var compositeEntity = newEntities.getById(entity.id);
        if (!defined(compositeEntity)) {
          compositeEntity = composite.getById(entity.id);
          if (!defined(compositeEntity)) {
            entityOptionsScratch.id = entity.id;
            compositeEntity = new Entity(entityOptionsScratch);
          } else {
            clean(compositeEntity);
          }
          newEntities.add(compositeEntity);
        }
        compositeEntity.merge(entity);
      }
    }
    that._collectionsCopy = collections.slice(0);
    composite.suspendEvents();
    composite.removeAll();
    var newEntitiesArray = newEntities.values;
    for (i = 0; i < newEntitiesArray.length; i++) {
      composite.add(newEntitiesArray[i]);
    }
    composite.resumeEvents();
  }
  function CompositeEntityCollection(collections, owner) {
    this._owner = owner;
    this._composite = new EntityCollection(this);
    this._suspendCount = 0;
    this._collections = defined(collections) ? collections.slice() : [];
    this._collectionsCopy = [];
    this._id = createGuid();
    this._eventHash = {};
    recomposite(this);
    this._shouldRecomposite = false;
  }
  defineProperties(CompositeEntityCollection.prototype, {
    collectionChanged: {get: function() {
        return this._composite._collectionChanged;
      }},
    id: {get: function() {
        return this._id;
      }},
    values: {get: function() {
        return this._composite.values;
      }},
    owner: {get: function() {
        return this._owner;
      }}
  });
  CompositeEntityCollection.prototype.addCollection = function(collection, index) {
    var hasIndex = defined(index);
    if (!defined(collection)) {
      throw new DeveloperError('collection is required.');
    }
    if (hasIndex) {
      if (index < 0) {
        throw new DeveloperError('index must be greater than or equal to zero.');
      } else if (index > this._collections.length) {
        throw new DeveloperError('index must be less than or equal to the number of collections.');
      }
    }
    if (!hasIndex) {
      index = this._collections.length;
      this._collections.push(collection);
    } else {
      this._collections.splice(index, 0, collection);
    }
    recomposite(this);
  };
  CompositeEntityCollection.prototype.removeCollection = function(collection) {
    var index = this._collections.indexOf(collection);
    if (index !== -1) {
      this._collections.splice(index, 1);
      recomposite(this);
      return true;
    }
    return false;
  };
  CompositeEntityCollection.prototype.removeAllCollections = function() {
    this._collections.length = 0;
    recomposite(this);
  };
  CompositeEntityCollection.prototype.containsCollection = function(collection) {
    return this._collections.indexOf(collection) !== -1;
  };
  CompositeEntityCollection.prototype.contains = function(entity) {
    return this._composite.contains(entity);
  };
  CompositeEntityCollection.prototype.indexOfCollection = function(collection) {
    return this._collections.indexOf(collection);
  };
  CompositeEntityCollection.prototype.getCollection = function(index) {
    if (!defined(index)) {
      throw new DeveloperError('index is required.', 'index');
    }
    return this._collections[index];
  };
  CompositeEntityCollection.prototype.getCollectionsLength = function() {
    return this._collections.length;
  };
  function getCollectionIndex(collections, collection) {
    if (!defined(collection)) {
      throw new DeveloperError('collection is required.');
    }
    var index = collections.indexOf(collection);
    if (index === -1) {
      throw new DeveloperError('collection is not in this composite.');
    }
    return index;
  }
  function swapCollections(composite, i, j) {
    var arr = composite._collections;
    i = CesiumMath.clamp(i, 0, arr.length - 1);
    j = CesiumMath.clamp(j, 0, arr.length - 1);
    if (i === j) {
      return;
    }
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    recomposite(composite);
  }
  CompositeEntityCollection.prototype.raiseCollection = function(collection) {
    var index = getCollectionIndex(this._collections, collection);
    swapCollections(this, index, index + 1);
  };
  CompositeEntityCollection.prototype.lowerCollection = function(collection) {
    var index = getCollectionIndex(this._collections, collection);
    swapCollections(this, index, index - 1);
  };
  CompositeEntityCollection.prototype.raiseCollectionToTop = function(collection) {
    var index = getCollectionIndex(this._collections, collection);
    if (index === this._collections.length - 1) {
      return;
    }
    this._collections.splice(index, 1);
    this._collections.push(collection);
    recomposite(this);
  };
  CompositeEntityCollection.prototype.lowerCollectionToBottom = function(collection) {
    var index = getCollectionIndex(this._collections, collection);
    if (index === 0) {
      return;
    }
    this._collections.splice(index, 1);
    this._collections.splice(0, 0, collection);
    recomposite(this);
  };
  CompositeEntityCollection.prototype.suspendEvents = function() {
    this._suspendCount++;
    this._composite.suspendEvents();
  };
  CompositeEntityCollection.prototype.resumeEvents = function() {
    if (this._suspendCount === 0) {
      throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
    }
    this._suspendCount--;
    if (this._shouldRecomposite && this._suspendCount === 0) {
      recomposite(this);
      this._shouldRecomposite = false;
    }
    this._composite.resumeEvents();
  };
  CompositeEntityCollection.prototype.computeAvailability = function() {
    return this._composite.computeAvailability();
  };
  CompositeEntityCollection.prototype.getById = function(id) {
    return this._composite.getById(id);
  };
  CompositeEntityCollection.prototype._onCollectionChanged = function(collection, added, removed) {
    var collections = this._collectionsCopy;
    var collectionsLength = collections.length;
    var composite = this._composite;
    composite.suspendEvents();
    var i;
    var q;
    var entity;
    var compositeEntity;
    var removedLength = removed.length;
    var eventHash = this._eventHash;
    var collectionId = collection.id;
    for (i = 0; i < removedLength; i++) {
      var removedEntity = removed[i];
      unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);
      var removedId = removedEntity.id;
      for (q = collectionsLength - 1; q >= 0; q--) {
        entity = collections[q].getById(removedId);
        if (defined(entity)) {
          if (!defined(compositeEntity)) {
            compositeEntity = composite.getById(removedId);
            clean(compositeEntity);
          }
          compositeEntity.merge(entity);
        }
      }
      if (!defined(compositeEntity)) {
        composite.removeById(removedId);
      }
      compositeEntity = undefined;
    }
    var addedLength = added.length;
    for (i = 0; i < addedLength; i++) {
      var addedEntity = added[i];
      subscribeToEntity(this, eventHash, collectionId, addedEntity);
      var addedId = addedEntity.id;
      for (q = collectionsLength - 1; q >= 0; q--) {
        entity = collections[q].getById(addedId);
        if (defined(entity)) {
          if (!defined(compositeEntity)) {
            compositeEntity = composite.getById(addedId);
            if (!defined(compositeEntity)) {
              entityOptionsScratch.id = addedId;
              compositeEntity = new Entity(entityOptionsScratch);
              composite.add(compositeEntity);
            } else {
              clean(compositeEntity);
            }
          }
          compositeEntity.merge(entity);
        }
      }
      compositeEntity = undefined;
    }
    composite.resumeEvents();
  };
  CompositeEntityCollection.prototype._onDefinitionChanged = function(entity, propertyName, newValue, oldValue) {
    var collections = this._collections;
    var composite = this._composite;
    var collectionsLength = collections.length;
    var id = entity.id;
    var compositeEntity = composite.getById(id);
    var compositeProperty = compositeEntity[propertyName];
    var newProperty = !defined(compositeProperty);
    var firstTime = true;
    for (var q = collectionsLength - 1; q >= 0; q--) {
      var innerEntity = collections[q].getById(entity.id);
      if (defined(innerEntity)) {
        var property = innerEntity[propertyName];
        if (defined(property)) {
          if (firstTime) {
            firstTime = false;
            if (defined(property.merge) && defined(property.clone)) {
              compositeProperty = property.clone(compositeProperty);
            } else {
              compositeProperty = property;
              break;
            }
          }
          compositeProperty.merge(property);
        }
      }
    }
    if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {
      compositeEntity.addProperty(propertyName);
    }
    compositeEntity[propertyName] = compositeProperty;
  };
  return CompositeEntityCollection;
});

})();
(function() {
var define = $__System.amdDefine;
define("1c", ["11", "17", "1d"], function(freezeObject, JulianDate, TimeInterval) {
  'use strict';
  var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
  var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
  var MAXIMUM_INTERVAL = freezeObject(new TimeInterval({
    start: MINIMUM_VALUE,
    stop: MAXIMUM_VALUE
  }));
  var Iso8601 = {
    MINIMUM_VALUE: MINIMUM_VALUE,
    MAXIMUM_VALUE: MAXIMUM_VALUE,
    MAXIMUM_INTERVAL: MAXIMUM_INTERVAL
  };
  return Iso8601;
});

})();
(function() {
var define = $__System.amdDefine;
define("1d", ["15", "5", "6", "7", "11", "17"], function(defaultValue, defined, defineProperties, DeveloperError, freezeObject, JulianDate) {
  'use strict';
  function TimeInterval(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();
    this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();
    this.data = options.data;
    this.isStartIncluded = defaultValue(options.isStartIncluded, true);
    this.isStopIncluded = defaultValue(options.isStopIncluded, true);
  }
  defineProperties(TimeInterval.prototype, {isEmpty: {get: function() {
        var stopComparedToStart = JulianDate.compare(this.stop, this.start);
        return stopComparedToStart < 0 || (stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded));
      }}});
  var scratchInterval = {
    start: undefined,
    stop: undefined,
    isStartIncluded: undefined,
    isStopIncluded: undefined,
    data: undefined
  };
  TimeInterval.fromIso8601 = function(options, result) {
    if (!defined(options)) {
      throw new DeveloperError('options is required.');
    }
    if (!defined(options.iso8601)) {
      throw new DeveloperError('options.iso8601 is required.');
    }
    var dates = options.iso8601.split('/');
    var start = JulianDate.fromIso8601(dates[0]);
    var stop = JulianDate.fromIso8601(dates[1]);
    var isStartIncluded = defaultValue(options.isStartIncluded, true);
    var isStopIncluded = defaultValue(options.isStopIncluded, true);
    var data = options.data;
    if (!defined(result)) {
      scratchInterval.start = start;
      scratchInterval.stop = stop;
      scratchInterval.isStartIncluded = isStartIncluded;
      scratchInterval.isStopIncluded = isStopIncluded;
      scratchInterval.data = data;
      return new TimeInterval(scratchInterval);
    }
    result.start = start;
    result.stop = stop;
    result.isStartIncluded = isStartIncluded;
    result.isStopIncluded = isStopIncluded;
    result.data = data;
    return result;
  };
  TimeInterval.toIso8601 = function(timeInterval, precision) {
    if (!defined(timeInterval)) {
      throw new DeveloperError('timeInterval is required.');
    }
    return JulianDate.toIso8601(timeInterval.start, precision) + '/' + JulianDate.toIso8601(timeInterval.stop, precision);
  };
  TimeInterval.clone = function(timeInterval, result) {
    if (!defined(timeInterval)) {
      return undefined;
    }
    if (!defined(result)) {
      return new TimeInterval(timeInterval);
    }
    result.start = timeInterval.start;
    result.stop = timeInterval.stop;
    result.isStartIncluded = timeInterval.isStartIncluded;
    result.isStopIncluded = timeInterval.isStopIncluded;
    result.data = timeInterval.data;
    return result;
  };
  TimeInterval.equals = function(left, right, dataComparer) {
    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
  };
  TimeInterval.equalsEpsilon = function(left, right, epsilon, dataComparer) {
    if (typeof epsilon !== 'number') {
      throw new DeveloperError('epsilon is required and must be a number.');
    }
    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
  };
  TimeInterval.intersect = function(left, right, result, mergeCallback) {
    if (!defined(left)) {
      throw new DeveloperError('left is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    if (!defined(right)) {
      return TimeInterval.clone(TimeInterval.EMPTY, result);
    }
    var leftStart = left.start;
    var leftStop = left.stop;
    var rightStart = right.start;
    var rightStop = right.stop;
    var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);
    var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);
    if (!intersectsStartRight && !intersectsStartLeft) {
      return TimeInterval.clone(TimeInterval.EMPTY, result);
    }
    var leftIsStartIncluded = left.isStartIncluded;
    var leftIsStopIncluded = left.isStopIncluded;
    var rightIsStartIncluded = right.isStartIncluded;
    var rightIsStopIncluded = right.isStopIncluded;
    var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);
    result.start = intersectsStartRight ? rightStart : leftStart;
    result.isStartIncluded = (leftIsStartIncluded && rightIsStartIncluded) || (!JulianDate.equals(rightStart, leftStart) && ((intersectsStartRight && rightIsStartIncluded) || (intersectsStartLeft && leftIsStartIncluded)));
    result.stop = leftLessThanRight ? leftStop : rightStop;
    result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : (leftIsStopIncluded && rightIsStopIncluded) || (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);
    result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
    return result;
  };
  TimeInterval.contains = function(timeInterval, julianDate) {
    if (!defined(timeInterval)) {
      throw new DeveloperError('timeInterval is required.');
    }
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    if (timeInterval.isEmpty) {
      return false;
    }
    var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);
    if (startComparedToDate === 0) {
      return timeInterval.isStartIncluded;
    }
    var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);
    if (dateComparedToStop === 0) {
      return timeInterval.isStopIncluded;
    }
    return startComparedToDate < 0 && dateComparedToStop < 0;
  };
  TimeInterval.prototype.clone = function(result) {
    return TimeInterval.clone(this, result);
  };
  TimeInterval.prototype.equals = function(right, dataComparer) {
    return TimeInterval.equals(this, right, dataComparer);
  };
  TimeInterval.prototype.equalsEpsilon = function(right, epsilon, dataComparer) {
    return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
  };
  TimeInterval.prototype.toString = function() {
    return TimeInterval.toIso8601(this);
  };
  TimeInterval.EMPTY = freezeObject(new TimeInterval({
    start: new JulianDate(),
    stop: new JulianDate(),
    isStartIncluded: false,
    isStopIncluded: false
  }));
  return TimeInterval;
});

})();
(function() {
var define = $__System.amdDefine;
define("19", [], function() {
  'use strict';
  function createGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  return createGuid;
});

})();
(function() {
var define = $__System.amdDefine;
define("1e", ["1f", "15", "5", "6", "7", "8", "20", "21"], function(Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty) {
  'use strict';
  function ConstantPositionProperty(value, referenceFrame) {
    this._definitionChanged = new Event();
    this._value = Cartesian3.clone(value);
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
  }
  defineProperties(ConstantPositionProperty.prototype, {
    isConstant: {get: function() {
        return !defined(this._value) || this._referenceFrame === ReferenceFrame.FIXED;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    referenceFrame: {get: function() {
        return this._referenceFrame;
      }}
  });
  ConstantPositionProperty.prototype.getValue = function(time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
  };
  ConstantPositionProperty.prototype.setValue = function(value, referenceFrame) {
    var definitionChanged = false;
    if (!Cartesian3.equals(this._value, value)) {
      definitionChanged = true;
      this._value = Cartesian3.clone(value);
    }
    if (defined(referenceFrame) && this._referenceFrame !== referenceFrame) {
      definitionChanged = true;
      this._referenceFrame = referenceFrame;
    }
    if (definitionChanged) {
      this._definitionChanged.raiseEvent(this);
    }
  };
  ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
      throw new DeveloperError('referenceFrame is required.');
    }
    return PositionProperty.convertToReferenceFrame(time, this._value, this._referenceFrame, referenceFrame, result);
  };
  ConstantPositionProperty.prototype.equals = function(other) {
    return this === other || (other instanceof ConstantPositionProperty && Cartesian3.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame);
  };
  return ConstantPositionProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("22", ["23"], function(createPropertyDescriptor) {
  'use strict';
  function createRawProperty(value) {
    return value;
  }
  function createRawPropertyDescriptor(name, configurable) {
    return createPropertyDescriptor(name, configurable, createRawProperty);
  }
  return createRawPropertyDescriptor;
});

})();
(function() {
var define = $__System.amdDefine;
define("24", ["5", "6", "8"], function(defined, defineProperties, Event) {
  'use strict';
  function ConstantProperty(value) {
    this._value = undefined;
    this._hasClone = false;
    this._hasEquals = false;
    this._definitionChanged = new Event();
    this.setValue(value);
  }
  defineProperties(ConstantProperty.prototype, {
    isConstant: {value: true},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }}
  });
  ConstantProperty.prototype.getValue = function(time, result) {
    return this._hasClone ? this._value.clone(result) : this._value;
  };
  ConstantProperty.prototype.setValue = function(value) {
    var oldValue = this._value;
    if (oldValue !== value) {
      var isDefined = defined(value);
      var hasClone = isDefined && typeof value.clone === 'function';
      var hasEquals = isDefined && typeof value.equals === 'function';
      var changed = !hasEquals || !value.equals(oldValue);
      if (changed) {
        this._hasClone = hasClone;
        this._hasEquals = hasEquals;
        this._value = !hasClone ? value : value.clone(this._value);
        this._definitionChanged.raiseEvent(this);
      }
    }
  };
  ConstantProperty.prototype.equals = function(other) {
    return this === other || (other instanceof ConstantProperty && ((!this._hasEquals && (this._value === other._value)) || (this._hasEquals && this._value.equals(other._value))));
  };
  ConstantProperty.prototype.valueOf = function() {
    return this._value;
  };
  ConstantProperty.prototype.toString = function() {
    return String(this._value);
  };
  return ConstantProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("23", ["15", "5", "24"], function(defaultValue, defined, ConstantProperty) {
  'use strict';
  function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
    return {
      configurable: configurable,
      get: function() {
        return this[privateName];
      },
      set: function(value) {
        var oldValue = this[privateName];
        var subscription = this[subscriptionName];
        if (defined(subscription)) {
          subscription();
          this[subscriptionName] = undefined;
        }
        var hasValue = value !== undefined;
        if (hasValue && (!defined(value) || !defined(value.getValue)) && defined(createPropertyCallback)) {
          value = createPropertyCallback(value);
        }
        if (oldValue !== value) {
          this[privateName] = value;
          this._definitionChanged.raiseEvent(this, name, value, oldValue);
        }
        if (defined(value) && defined(value.definitionChanged)) {
          this[subscriptionName] = value.definitionChanged.addEventListener(function() {
            this._definitionChanged.raiseEvent(this, name, value, value);
          }, this);
        }
      }
    };
  }
  function createConstantProperty(value) {
    return new ConstantProperty(value);
  }
  function createPropertyDescriptor(name, configurable, createPropertyCallback) {
    return createProperty(name, '_' + name.toString(), '_' + name.toString() + 'Subscription', defaultValue(configurable, false), defaultValue(createPropertyCallback, createConstantProperty));
  }
  return createPropertyDescriptor;
});

})();
(function() {
var define = $__System.amdDefine;
define("25", ["15", "5", "6", "7", "8", "24", "23", "26"], function(defaultValue, defined, defineProperties, DeveloperError, Event, ConstantProperty, createPropertyDescriptor, Property) {
  'use strict';
  var PropertyBag = function(value, createPropertyCallback) {
    this._propertyNames = [];
    this._definitionChanged = new Event();
    if (defined(value)) {
      this.merge(value, createPropertyCallback);
    }
  };
  defineProperties(PropertyBag.prototype, {
    propertyNames: {get: function() {
        return this._propertyNames;
      }},
    isConstant: {get: function() {
        var propertyNames = this._propertyNames;
        for (var i = 0,
            len = propertyNames.length; i < len; i++) {
          if (!Property.isConstant(this[propertyNames[i]])) {
            return false;
          }
        }
        return true;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }}
  });
  PropertyBag.prototype.hasProperty = function(propertyName) {
    return this._propertyNames.indexOf(propertyName) !== -1;
  };
  function createConstantProperty(value) {
    return new ConstantProperty(value);
  }
  PropertyBag.prototype.addProperty = function(propertyName, value, createPropertyCallback) {
    var propertyNames = this._propertyNames;
    if (!defined(propertyName)) {
      throw new DeveloperError('propertyName is required.');
    }
    if (propertyNames.indexOf(propertyName) !== -1) {
      throw new DeveloperError(propertyName + ' is already a registered property.');
    }
    propertyNames.push(propertyName);
    Object.defineProperty(this, propertyName, createPropertyDescriptor(propertyName, true, defaultValue(createPropertyCallback, createConstantProperty)));
    if (defined(value)) {
      this[propertyName] = value;
    }
    this._definitionChanged.raiseEvent(this);
  };
  PropertyBag.prototype.removeProperty = function(propertyName) {
    var propertyNames = this._propertyNames;
    var index = propertyNames.indexOf(propertyName);
    if (!defined(propertyName)) {
      throw new DeveloperError('propertyName is required.');
    }
    if (index === -1) {
      throw new DeveloperError(propertyName + ' is not a registered property.');
    }
    this._propertyNames.splice(index, 1);
    delete this[propertyName];
    this._definitionChanged.raiseEvent(this);
  };
  PropertyBag.prototype.getValue = function(time, result) {
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    if (!defined(result)) {
      result = {};
    }
    var propertyNames = this._propertyNames;
    for (var i = 0,
        len = propertyNames.length; i < len; i++) {
      var propertyName = propertyNames[i];
      result[propertyName] = Property.getValueOrUndefined(this[propertyName], time, result[propertyName]);
    }
    return result;
  };
  PropertyBag.prototype.merge = function(source, createPropertyCallback) {
    if (!defined(source)) {
      throw new DeveloperError('source is required.');
    }
    var propertyNames = this._propertyNames;
    var sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);
    for (var i = 0,
        len = sourcePropertyNames.length; i < len; i++) {
      var name = sourcePropertyNames[i];
      var targetProperty = this[name];
      var sourceProperty = source[name];
      if (targetProperty === undefined && propertyNames.indexOf(name) === -1) {
        this.addProperty(name, undefined, createPropertyCallback);
      }
      if (sourceProperty !== undefined) {
        if (targetProperty !== undefined) {
          if (defined(targetProperty) && defined(targetProperty.merge)) {
            targetProperty.merge(sourceProperty);
          }
        } else if (defined(sourceProperty) && defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
          this[name] = sourceProperty.clone();
        } else {
          this[name] = sourceProperty;
        }
      }
    }
  };
  function propertiesEqual(a, b) {
    var aPropertyNames = a._propertyNames;
    var bPropertyNames = b._propertyNames;
    var len = aPropertyNames.length;
    if (len !== bPropertyNames.length) {
      return false;
    }
    for (var aIndex = 0; aIndex < len; ++aIndex) {
      var name = aPropertyNames[aIndex];
      var bIndex = bPropertyNames.indexOf(name);
      if (bIndex === -1) {
        return false;
      }
      if (!Property.equals(a[name], b[name])) {
        return false;
      }
    }
    return true;
  }
  PropertyBag.prototype.equals = function(other) {
    return this === other || (other instanceof PropertyBag && propertiesEqual(this, other));
  };
  return PropertyBag;
});

})();
(function() {
var define = $__System.amdDefine;
define("1a", ["1f", "19", "15", "5", "6", "7", "8", "27", "28", "29", "2a", "@empty", "@empty", "1e", "@empty", "23", "22", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "@empty", "26", "25", "@empty", "@empty"], function(Cartesian3, createGuid, defaultValue, defined, defineProperties, DeveloperError, Event, Matrix3, Matrix4, Quaternion, Transforms, BillboardGraphics, BoxGraphics, ConstantPositionProperty, CorridorGraphics, createPropertyDescriptor, createRawPropertyDescriptor, CylinderGraphics, EllipseGraphics, EllipsoidGraphics, LabelGraphics, ModelGraphics, PathGraphics, PointGraphics, PolygonGraphics, PolylineGraphics, PolylineVolumeGraphics, Property, PropertyBag, RectangleGraphics, WallGraphics) {
  'use strict';
  function createConstantPositionProperty(value) {
    return new ConstantPositionProperty(value);
  }
  function createPositionPropertyDescriptor(name) {
    return createPropertyDescriptor(name, undefined, createConstantPositionProperty);
  }
  function createPropertyTypeDescriptor(name, Type) {
    return createPropertyDescriptor(name, undefined, function(value) {
      if (value instanceof Type) {
        return value;
      }
      return new Type(value);
    });
  }
  function Entity(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var id = options.id;
    if (!defined(id)) {
      id = createGuid();
    }
    this._availability = undefined;
    this._id = id;
    this._definitionChanged = new Event();
    this._name = options.name;
    this._show = defaultValue(options.show, true);
    this._parent = undefined;
    this._propertyNames = ['billboard', 'box', 'corridor', 'cylinder', 'description', 'ellipse', 'ellipsoid', 'label', 'model', 'orientation', 'path', 'point', 'polygon', 'polyline', 'polylineVolume', 'position', 'properties', 'rectangle', 'viewFrom', 'wall'];
    this._billboard = undefined;
    this._billboardSubscription = undefined;
    this._box = undefined;
    this._boxSubscription = undefined;
    this._corridor = undefined;
    this._corridorSubscription = undefined;
    this._cylinder = undefined;
    this._cylinderSubscription = undefined;
    this._description = undefined;
    this._descriptionSubscription = undefined;
    this._ellipse = undefined;
    this._ellipseSubscription = undefined;
    this._ellipsoid = undefined;
    this._ellipsoidSubscription = undefined;
    this._label = undefined;
    this._labelSubscription = undefined;
    this._model = undefined;
    this._modelSubscription = undefined;
    this._orientation = undefined;
    this._orientationSubscription = undefined;
    this._path = undefined;
    this._pathSubscription = undefined;
    this._point = undefined;
    this._pointSubscription = undefined;
    this._polygon = undefined;
    this._polygonSubscription = undefined;
    this._polyline = undefined;
    this._polylineSubscription = undefined;
    this._polylineVolume = undefined;
    this._polylineVolumeSubscription = undefined;
    this._position = undefined;
    this._positionSubscription = undefined;
    this._properties = undefined;
    this._propertiesSubscription = undefined;
    this._rectangle = undefined;
    this._rectangleSubscription = undefined;
    this._viewFrom = undefined;
    this._viewFromSubscription = undefined;
    this._wall = undefined;
    this._wallSubscription = undefined;
    this._children = [];
    this.entityCollection = undefined;
    this.parent = options.parent;
    this.merge(options);
  }
  function updateShow(entity, children, isShowing) {
    var length = children.length;
    for (var i = 0; i < length; i++) {
      var child = children[i];
      var childShow = child._show;
      var oldValue = !isShowing && childShow;
      var newValue = isShowing && childShow;
      if (oldValue !== newValue) {
        updateShow(child, child._children, isShowing);
      }
    }
    entity._definitionChanged.raiseEvent(entity, 'isShowing', isShowing, !isShowing);
  }
  defineProperties(Entity.prototype, {
    availability: createRawPropertyDescriptor('availability'),
    id: {get: function() {
        return this._id;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    name: createRawPropertyDescriptor('name'),
    show: {
      get: function() {
        return this._show;
      },
      set: function(value) {
        if (!defined(value)) {
          throw new DeveloperError('value is required.');
        }
        if (value === this._show) {
          return;
        }
        var wasShowing = this.isShowing;
        this._show = value;
        var isShowing = this.isShowing;
        if (wasShowing !== isShowing) {
          updateShow(this, this._children, isShowing);
        }
        this._definitionChanged.raiseEvent(this, 'show', value, !value);
      }
    },
    isShowing: {get: function() {
        return this._show && (!defined(this.entityCollection) || this.entityCollection.show) && (!defined(this._parent) || this._parent.isShowing);
      }},
    parent: {
      get: function() {
        return this._parent;
      },
      set: function(value) {
        var oldValue = this._parent;
        if (oldValue === value) {
          return;
        }
        var wasShowing = this.isShowing;
        if (defined(oldValue)) {
          var index = oldValue._children.indexOf(this);
          oldValue._children.splice(index, 1);
        }
        this._parent = value;
        if (defined(value)) {
          value._children.push(this);
        }
        var isShowing = this.isShowing;
        if (wasShowing !== isShowing) {
          updateShow(this, this._children, isShowing);
        }
        this._definitionChanged.raiseEvent(this, 'parent', value, oldValue);
      }
    },
    propertyNames: {get: function() {
        return this._propertyNames;
      }},
    billboard: createPropertyTypeDescriptor('billboard', BillboardGraphics),
    box: createPropertyTypeDescriptor('box', BoxGraphics),
    corridor: createPropertyTypeDescriptor('corridor', CorridorGraphics),
    cylinder: createPropertyTypeDescriptor('cylinder', CylinderGraphics),
    description: createPropertyDescriptor('description'),
    ellipse: createPropertyTypeDescriptor('ellipse', EllipseGraphics),
    ellipsoid: createPropertyTypeDescriptor('ellipsoid', EllipsoidGraphics),
    label: createPropertyTypeDescriptor('label', LabelGraphics),
    model: createPropertyTypeDescriptor('model', ModelGraphics),
    orientation: createPropertyDescriptor('orientation'),
    path: createPropertyTypeDescriptor('path', PathGraphics),
    point: createPropertyTypeDescriptor('point', PointGraphics),
    polygon: createPropertyTypeDescriptor('polygon', PolygonGraphics),
    polyline: createPropertyTypeDescriptor('polyline', PolylineGraphics),
    polylineVolume: createPropertyTypeDescriptor('polylineVolume', PolylineVolumeGraphics),
    properties: createPropertyTypeDescriptor('properties', PropertyBag),
    position: createPositionPropertyDescriptor('position'),
    rectangle: createPropertyTypeDescriptor('rectangle', RectangleGraphics),
    viewFrom: createPropertyDescriptor('viewFrom'),
    wall: createPropertyTypeDescriptor('wall', WallGraphics)
  });
  Entity.prototype.isAvailable = function(time) {
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    var availability = this._availability;
    return !defined(availability) || availability.contains(time);
  };
  Entity.prototype.addProperty = function(propertyName) {
    var propertyNames = this._propertyNames;
    if (!defined(propertyName)) {
      throw new DeveloperError('propertyName is required.');
    }
    if (propertyNames.indexOf(propertyName) !== -1) {
      throw new DeveloperError(propertyName + ' is already a registered property.');
    }
    if (propertyName in this) {
      throw new DeveloperError(propertyName + ' is a reserved property name.');
    }
    propertyNames.push(propertyName);
    Object.defineProperty(this, propertyName, createRawPropertyDescriptor(propertyName, true));
  };
  Entity.prototype.removeProperty = function(propertyName) {
    var propertyNames = this._propertyNames;
    var index = propertyNames.indexOf(propertyName);
    if (!defined(propertyName)) {
      throw new DeveloperError('propertyName is required.');
    }
    if (index === -1) {
      throw new DeveloperError(propertyName + ' is not a registered property.');
    }
    this._propertyNames.splice(index, 1);
    delete this[propertyName];
  };
  Entity.prototype.merge = function(source) {
    if (!defined(source)) {
      throw new DeveloperError('source is required.');
    }
    this.name = defaultValue(this.name, source.name);
    this.availability = defaultValue(source.availability, this.availability);
    var propertyNames = this._propertyNames;
    var sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);
    var propertyNamesLength = sourcePropertyNames.length;
    for (var i = 0; i < propertyNamesLength; i++) {
      var name = sourcePropertyNames[i];
      if (name === 'parent') {
        continue;
      }
      var targetProperty = this[name];
      var sourceProperty = source[name];
      if (!defined(targetProperty) && propertyNames.indexOf(name) === -1) {
        this.addProperty(name);
      }
      if (defined(sourceProperty)) {
        if (defined(targetProperty)) {
          if (defined(targetProperty.merge)) {
            targetProperty.merge(sourceProperty);
          }
        } else if (defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
          this[name] = sourceProperty.clone();
        } else {
          this[name] = sourceProperty;
        }
      }
    }
  };
  var matrix3Scratch = new Matrix3();
  var positionScratch = new Cartesian3();
  var orientationScratch = new Quaternion();
  Entity.prototype._getModelMatrix = function(time, result) {
    var position = Property.getValueOrUndefined(this._position, time, positionScratch);
    if (!defined(position)) {
      return undefined;
    }
    var orientation = Property.getValueOrUndefined(this._orientation, time, orientationScratch);
    if (!defined(orientation)) {
      result = Transforms.eastNorthUpToFixedFrame(position, undefined, result);
    } else {
      result = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, result);
    }
    return result;
  };
  return Entity;
});

})();
(function() {
var define = $__System.amdDefine;
define("1b", ["2b", "19", "5", "6", "7", "8", "1c", "17", "2c", "1d", "1a"], function(AssociativeArray, createGuid, defined, defineProperties, DeveloperError, Event, Iso8601, JulianDate, RuntimeError, TimeInterval, Entity) {
  'use strict';
  var entityOptionsScratch = {id: undefined};
  function fireChangedEvent(collection) {
    if (collection._firing) {
      collection._refire = true;
      return;
    }
    if (collection._suspendCount === 0) {
      var added = collection._addedEntities;
      var removed = collection._removedEntities;
      var changed = collection._changedEntities;
      if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
        collection._firing = true;
        do {
          collection._refire = false;
          var addedArray = added.values.slice(0);
          var removedArray = removed.values.slice(0);
          var changedArray = changed.values.slice(0);
          added.removeAll();
          removed.removeAll();
          changed.removeAll();
          collection._collectionChanged.raiseEvent(collection, addedArray, removedArray, changedArray);
        } while (collection._refire);
        collection._firing = false;
      }
    }
  }
  function EntityCollection(owner) {
    this._owner = owner;
    this._entities = new AssociativeArray();
    this._addedEntities = new AssociativeArray();
    this._removedEntities = new AssociativeArray();
    this._changedEntities = new AssociativeArray();
    this._suspendCount = 0;
    this._collectionChanged = new Event();
    this._id = createGuid();
    this._show = true;
    this._firing = false;
    this._refire = false;
  }
  EntityCollection.prototype.suspendEvents = function() {
    this._suspendCount++;
  };
  EntityCollection.prototype.resumeEvents = function() {
    if (this._suspendCount === 0) {
      throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
    }
    this._suspendCount--;
    fireChangedEvent(this);
  };
  EntityCollection.collectionChangedEventCallback = undefined;
  defineProperties(EntityCollection.prototype, {
    collectionChanged: {get: function() {
        return this._collectionChanged;
      }},
    id: {get: function() {
        return this._id;
      }},
    values: {get: function() {
        return this._entities.values;
      }},
    show: {
      get: function() {
        return this._show;
      },
      set: function(value) {
        if (!defined(value)) {
          throw new DeveloperError('value is required.');
        }
        if (value === this._show) {
          return;
        }
        this.suspendEvents();
        var i;
        var oldShows = [];
        var entities = this._entities.values;
        var entitiesLength = entities.length;
        for (i = 0; i < entitiesLength; i++) {
          oldShows.push(entities[i].isShowing);
        }
        this._show = value;
        for (i = 0; i < entitiesLength; i++) {
          var oldShow = oldShows[i];
          var entity = entities[i];
          if (oldShow !== entity.isShowing) {
            entity.definitionChanged.raiseEvent(entity, 'isShowing', entity.isShowing, oldShow);
          }
        }
        this.resumeEvents();
      }
    },
    owner: {get: function() {
        return this._owner;
      }}
  });
  EntityCollection.prototype.computeAvailability = function() {
    var startTime = Iso8601.MAXIMUM_VALUE;
    var stopTime = Iso8601.MINIMUM_VALUE;
    var entities = this._entities.values;
    for (var i = 0,
        len = entities.length; i < len; i++) {
      var entity = entities[i];
      var availability = entity.availability;
      if (defined(availability)) {
        var start = availability.start;
        var stop = availability.stop;
        if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
          startTime = start;
        }
        if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
          stopTime = stop;
        }
      }
    }
    if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {
      startTime = Iso8601.MINIMUM_VALUE;
    }
    if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {
      stopTime = Iso8601.MAXIMUM_VALUE;
    }
    return new TimeInterval({
      start: startTime,
      stop: stopTime
    });
  };
  EntityCollection.prototype.add = function(entity) {
    if (!defined(entity)) {
      throw new DeveloperError('entity is required.');
    }
    if (!(entity instanceof Entity)) {
      entity = new Entity(entity);
    }
    var id = entity.id;
    var entities = this._entities;
    if (entities.contains(id)) {
      throw new RuntimeError('An entity with id ' + id + ' already exists in this collection.');
    }
    entity.entityCollection = this;
    entities.set(id, entity);
    if (!this._removedEntities.remove(id)) {
      this._addedEntities.set(id, entity);
    }
    entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
    fireChangedEvent(this);
    return entity;
  };
  EntityCollection.prototype.remove = function(entity) {
    if (!defined(entity)) {
      return false;
    }
    return this.removeById(entity.id);
  };
  EntityCollection.prototype.contains = function(entity) {
    if (!defined(entity)) {
      throw new DeveloperError('entity is required');
    }
    return this._entities.get(entity.id) === entity;
  };
  EntityCollection.prototype.removeById = function(id) {
    if (!defined(id)) {
      return false;
    }
    var entities = this._entities;
    var entity = entities.get(id);
    if (!this._entities.remove(id)) {
      return false;
    }
    if (!this._addedEntities.remove(id)) {
      this._removedEntities.set(id, entity);
      this._changedEntities.remove(id);
    }
    this._entities.remove(id);
    entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
    fireChangedEvent(this);
    return true;
  };
  EntityCollection.prototype.removeAll = function() {
    var entities = this._entities;
    var entitiesLength = entities.length;
    var array = entities.values;
    var addedEntities = this._addedEntities;
    var removed = this._removedEntities;
    for (var i = 0; i < entitiesLength; i++) {
      var existingItem = array[i];
      var existingItemId = existingItem.id;
      var addedItem = addedEntities.get(existingItemId);
      if (!defined(addedItem)) {
        existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
        removed.set(existingItemId, existingItem);
      }
    }
    entities.removeAll();
    addedEntities.removeAll();
    this._changedEntities.removeAll();
    fireChangedEvent(this);
  };
  EntityCollection.prototype.getById = function(id) {
    if (!defined(id)) {
      throw new DeveloperError('id is required.');
    }
    return this._entities.get(id);
  };
  EntityCollection.prototype.getOrCreateEntity = function(id) {
    if (!defined(id)) {
      throw new DeveloperError('id is required.');
    }
    var entity = this._entities.get(id);
    if (!defined(entity)) {
      entityOptionsScratch.id = id;
      entity = new Entity(entityOptionsScratch);
      this.add(entity);
    }
    return entity;
  };
  EntityCollection.prototype._onEntityDefinitionChanged = function(entity) {
    var id = entity.id;
    if (!this._addedEntities.contains(id)) {
      this._changedEntities.set(id, entity);
    }
    fireChangedEvent(this);
  };
  return EntityCollection;
});

})();
(function() {
var define = $__System.amdDefine;
define("2d", ["15", "5", "7", "d"], function(defaultValue, defined, DeveloperError, CesiumMath) {
  'use strict';
  var factorial = CesiumMath.factorial;
  function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
    var result = 0;
    var reserved;
    var i;
    var j;
    if (derivOrder > 0) {
      for (i = 0; i < termOrder; i++) {
        reserved = false;
        for (j = 0; j < reservedIndices.length && !reserved; j++) {
          if (i === reservedIndices[j]) {
            reserved = true;
          }
        }
        if (!reserved) {
          reservedIndices.push(i);
          result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
          reservedIndices.splice(reservedIndices.length - 1, 1);
        }
      }
      return result;
    }
    result = 1;
    for (i = 0; i < termOrder; i++) {
      reserved = false;
      for (j = 0; j < reservedIndices.length && !reserved; j++) {
        if (i === reservedIndices[j]) {
          reserved = true;
        }
      }
      if (!reserved) {
        result *= x - xTable[zIndices[i]];
      }
    }
    return result;
  }
  var HermitePolynomialApproximation = {type: 'Hermite'};
  HermitePolynomialApproximation.getRequiredDataPoints = function(degree, inputOrder) {
    inputOrder = defaultValue(inputOrder, 0);
    if (!defined(degree)) {
      throw new DeveloperError('degree is required.');
    }
    if (degree < 0) {
      throw new DeveloperError('degree must be 0 or greater.');
    }
    if (inputOrder < 0) {
      throw new DeveloperError('inputOrder must be 0 or greater.');
    }
    return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
  };
  HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
    if (!defined(result)) {
      result = new Array(yStride);
    }
    var i;
    var j;
    var d;
    var s;
    var len;
    var index;
    var length = xTable.length;
    var coefficients = new Array(yStride);
    for (i = 0; i < yStride; i++) {
      result[i] = 0;
      var l = new Array(length);
      coefficients[i] = l;
      for (j = 0; j < length; j++) {
        l[j] = [];
      }
    }
    var zIndicesLength = length,
        zIndices = new Array(zIndicesLength);
    for (i = 0; i < zIndicesLength; i++) {
      zIndices[i] = i;
    }
    var highestNonZeroCoef = length - 1;
    for (s = 0; s < yStride; s++) {
      for (j = 0; j < zIndicesLength; j++) {
        index = zIndices[j] * yStride + s;
        coefficients[s][0].push(yTable[index]);
      }
      for (i = 1; i < zIndicesLength; i++) {
        var nonZeroCoefficients = false;
        for (j = 0; j < zIndicesLength - i; j++) {
          var zj = xTable[zIndices[j]];
          var zn = xTable[zIndices[j + i]];
          var numerator;
          if (zn - zj <= 0) {
            index = zIndices[j] * yStride + yStride * i + s;
            numerator = yTable[index];
            coefficients[s][i].push(numerator / factorial(i));
          } else {
            numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
            coefficients[s][i].push(numerator / (zn - zj));
          }
          nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
        }
        if (!nonZeroCoefficients) {
          highestNonZeroCoef = i - 1;
        }
      }
    }
    for (d = 0, len = 0; d <= len; d++) {
      for (i = d; i <= highestNonZeroCoef; i++) {
        var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
        for (s = 0; s < yStride; s++) {
          var coeff = coefficients[s][i][0];
          result[s + d * yStride] += coeff * tempTerm;
        }
      }
    }
    return result;
  };
  var arrayScratch = [];
  HermitePolynomialApproximation.interpolate = function(x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
    var resultLength = yStride * (outputOrder + 1);
    if (!defined(result)) {
      result = new Array(resultLength);
    }
    for (var r = 0; r < resultLength; r++) {
      result[r] = 0;
    }
    var length = xTable.length;
    var zIndices = new Array(length * (inputOrder + 1));
    for (var i = 0; i < length; i++) {
      for (var j = 0; j < (inputOrder + 1); j++) {
        zIndices[i * (inputOrder + 1) + j] = i;
      }
    }
    var zIndiceslength = zIndices.length;
    var coefficients = arrayScratch;
    var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
    var reservedIndices = [];
    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
    var loopStop = Math.min(highestNonZeroCoef, outputOrder);
    for (var d = 0; d <= loopStop; d++) {
      for (i = d; i <= highestNonZeroCoef; i++) {
        reservedIndices.length = 0;
        var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
        var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
        for (var s = 0; s < yStride; s++) {
          var dimOne = Math.floor(s * tmp);
          var coef = coefficients[dimOne + dimTwo];
          result[s + d * yStride] += coef * tempTerm;
        }
      }
    }
    return result;
  };
  function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
    var j;
    var index;
    var highestNonZero = -1;
    var zIndiceslength = zIndices.length;
    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
    for (var s = 0; s < yStride; s++) {
      var dimOne = Math.floor(s * tmp);
      for (j = 0; j < zIndiceslength; j++) {
        index = zIndices[j] * yStride * (inputOrder + 1) + s;
        coefficients[dimOne + j] = yTable[index];
      }
      for (var i = 1; i < zIndiceslength; i++) {
        var coefIndex = 0;
        var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
        var nonZeroCoefficients = false;
        for (j = 0; j < zIndiceslength - i; j++) {
          var zj = xTable[zIndices[j]];
          var zn = xTable[zIndices[j + i]];
          var numerator;
          var coefficient;
          if (zn - zj <= 0) {
            index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
            numerator = yTable[index];
            coefficient = (numerator / CesiumMath.factorial(i));
            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
            coefIndex++;
          } else {
            var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + (zIndiceslength * (i - 1));
            numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
            coefficient = (numerator / (zn - zj));
            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
            coefIndex++;
          }
          nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0.0);
        }
        if (nonZeroCoefficients) {
          highestNonZero = Math.max(highestNonZero, i);
        }
      }
    }
    return highestNonZero;
  }
  return HermitePolynomialApproximation;
});

})();
(function() {
var define = $__System.amdDefine;
define("2e", ["5", "6", "7", "27", "29", "20", "2a"], function(defined, defineProperties, DeveloperError, Matrix3, Quaternion, ReferenceFrame, Transforms) {
  "use strict";
  var OrientationProperty = function() {
    DeveloperError.throwInstantiationError();
  };
  defineProperties(OrientationProperty.prototype, {
    isConstant: {get: DeveloperError.throwInstantiationError},
    definitionChanged: {get: DeveloperError.throwInstantiationError}
  });
  OrientationProperty.prototype.getValue = DeveloperError.throwInstantiationError;
  OrientationProperty.prototype.equals = DeveloperError.throwInstantiationError;
  function framesEqual(frame1, frame2) {
    return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
  }
  function frameParents(frame) {
    var frames = [];
    while (defined(frame)) {
      frames.unshift(frame);
      frame = frame.position && frame.position.referenceFrame;
    }
    return frames;
  }
  function lowestCommonAncestor(parents1, parents2) {
    if (!framesEqual(parents1[0], parents2[0])) {
      return -1;
    }
    var h = Math.min(parents1.length, parents2.length);
    for (var i = 0; i <= h; i++) {
      if (!framesEqual(parents1[i], parents2[i])) {
        return i - 1;
      }
    }
    return -1;
  }
  var scratchIcrfToFixedMatrix3 = new Matrix3();
  var scratchIcrfToFixed = new Quaternion();
  function getIcrfToFixed(time) {
    var icrfToFixedRotation = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
    if (!defined(icrfToFixedRotation)) {
      icrfToFixedRotation = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
    }
    return Quaternion.fromRotationMatrix(icrfToFixedRotation, scratchIcrfToFixed);
  }
  var scratchQuaternion = new Quaternion();
  OrientationProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
    if (!defined(value)) {
      return value;
    }
    if (!defined(result)) {
      result = new Quaternion();
    }
    if (inputFrame === outputFrame) {
      return Quaternion.clone(value, result);
    }
    if (!defined(inputFrame) || !defined(outputFrame)) {
      return undefined;
    }
    var inputFrameParents = frameParents(inputFrame);
    var outputFrameParents = frameParents(outputFrame);
    var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
    var lcaFrame = inputFrameParents[lcaIndex];
    var inputOrientationAccumulator = function(accumulatedOrientationValue, frame) {
      if (!defined(accumulatedOrientationValue)) {
        return accumulatedOrientationValue;
      }
      var frameOrientationProperty = frame.orientation;
      if (!defined(frameOrientationProperty)) {
        return undefined;
      }
      var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
      if (!defined(frameOrientationValue)) {
        return undefined;
      }
      return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
    };
    var outputOrientationAccumulator = function(accumulatedOrientationValue, frame) {
      if (!defined(accumulatedOrientationValue)) {
        return accumulatedOrientationValue;
      }
      var frameOrientationProperty = frame.orientation;
      if (!defined(frameOrientationProperty)) {
        return undefined;
      }
      var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
      if (!defined(frameOrientationValue)) {
        return undefined;
      }
      Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
      return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
    };
    if (defined(lcaFrame)) {
      inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
      outputFrameParents = outputFrameParents.slice(lcaIndex + 1);
      var lcaFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
      if (!defined(lcaFrameValue)) {
        return undefined;
      }
      return outputFrameParents.reduce(outputOrientationAccumulator, lcaFrameValue);
    }
    var inputRootFrame = inputFrameParents.shift();
    var outputRootFrame = outputFrameParents.shift();
    var fixedFrameValue,
        inertialFrameValue;
    if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
      inertialFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
      if (!defined(inertialFrameValue)) {
        return undefined;
      }
      fixedFrameValue = Quaternion.multiply(getIcrfToFixed(time), inertialFrameValue, result);
      return outputFrameParents.reduce(outputOrientationAccumulator, fixedFrameValue);
    }
    if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
      fixedFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
      if (!defined(fixedFrameValue)) {
        return undefined;
      }
      var fixedToIcrf = Quaternion.conjugate(getIcrfToFixed(time), scratchQuaternion);
      inertialFrameValue = Quaternion.multiply(fixedToIcrf, fixedFrameValue, result);
      return outputFrameParents.reduce(outputOrientationAccumulator, inertialFrameValue);
    }
    return undefined;
  };
  return OrientationProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("2f", ["5", "6", "7", "30"], function(defined, defineProperties, DeveloperError, PerspectiveOffCenterFrustum) {
  'use strict';
  function PerspectiveFrustum() {
    this._offCenterFrustum = new PerspectiveOffCenterFrustum();
    this.fov = undefined;
    this._fov = undefined;
    this._fovy = undefined;
    this._sseDenominator = undefined;
    this.aspectRatio = undefined;
    this._aspectRatio = undefined;
    this.near = 1.0;
    this._near = this.near;
    this.far = 500000000.0;
    this._far = this.far;
    this.xOffset = 0.0;
    this._xOffset = this.xOffset;
    this.yOffset = 0.0;
    this._yOffset = this.yOffset;
  }
  function update(frustum) {
    if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
      throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
    }
    var f = frustum._offCenterFrustum;
    if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
      if (frustum.fov < 0 || frustum.fov >= Math.PI) {
        throw new DeveloperError('fov must be in the range [0, PI).');
      }
      if (frustum.aspectRatio < 0) {
        throw new DeveloperError('aspectRatio must be positive.');
      }
      if (frustum.near < 0 || frustum.near > frustum.far) {
        throw new DeveloperError('near must be greater than zero and less than far.');
      }
      frustum._aspectRatio = frustum.aspectRatio;
      frustum._fov = frustum.fov;
      frustum._fovy = (frustum.aspectRatio <= 1) ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
      frustum._near = frustum.near;
      frustum._far = frustum.far;
      frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
      frustum._xOffset = frustum.xOffset;
      frustum._yOffset = frustum.yOffset;
      f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
      f.bottom = -f.top;
      f.right = frustum.aspectRatio * f.top;
      f.left = -f.right;
      f.near = frustum.near;
      f.far = frustum.far;
      f.right += frustum.xOffset;
      f.left += frustum.xOffset;
      f.top += frustum.yOffset;
      f.bottom += frustum.yOffset;
    }
  }
  defineProperties(PerspectiveFrustum.prototype, {
    projectionMatrix: {get: function() {
        update(this);
        return this._offCenterFrustum.projectionMatrix;
      }},
    infiniteProjectionMatrix: {get: function() {
        update(this);
        return this._offCenterFrustum.infiniteProjectionMatrix;
      }},
    fovy: {get: function() {
        update(this);
        return this._fovy;
      }},
    sseDenominator: {get: function() {
        update(this);
        return this._sseDenominator;
      }}
  });
  PerspectiveFrustum.prototype.computeCullingVolume = function(position, direction, up) {
    update(this);
    return this._offCenterFrustum.computeCullingVolume(position, direction, up);
  };
  PerspectiveFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, result) {
    update(this);
    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);
  };
  PerspectiveFrustum.prototype.clone = function(result) {
    if (!defined(result)) {
      result = new PerspectiveFrustum();
    }
    result.aspectRatio = this.aspectRatio;
    result.fov = this.fov;
    result.near = this.near;
    result.far = this.far;
    result._aspectRatio = undefined;
    result._fov = undefined;
    result._near = undefined;
    result._far = undefined;
    this._offCenterFrustum.clone(result._offCenterFrustum);
    return result;
  };
  PerspectiveFrustum.prototype.equals = function(other) {
    if (!defined(other)) {
      return false;
    }
    update(this);
    update(other);
    return (this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum));
  };
  return PerspectiveFrustum;
});

})();
(function() {
var define = $__System.amdDefine;
define("31", ["1f", "32", "15", "5", "7", "33", "34"], function(Cartesian3, Cartesian4, defaultValue, defined, DeveloperError, Intersect, Plane) {
  'use strict';
  function CullingVolume(planes) {
    this.planes = defaultValue(planes, []);
  }
  var faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];
  Cartesian3.clone(Cartesian3.UNIT_X, faces[0]);
  Cartesian3.clone(Cartesian3.UNIT_Y, faces[1]);
  Cartesian3.clone(Cartesian3.UNIT_Z, faces[2]);
  var scratchPlaneCenter = new Cartesian3();
  var scratchPlaneNormal = new Cartesian3();
  var scratchPlane = new Plane(new Cartesian3(), 0.0);
  CullingVolume.fromBoundingSphere = function(boundingSphere, result) {
    if (!defined(boundingSphere)) {
      throw new DeveloperError('boundingSphere is required.');
    }
    if (!defined(result)) {
      result = new CullingVolume();
    }
    var length = faces.length;
    var planes = result.planes;
    planes.length = 2 * length;
    var center = boundingSphere.center;
    var radius = boundingSphere.radius;
    var planeIndex = 0;
    for (var i = 0; i < length; ++i) {
      var faceNormal = faces[i];
      var plane0 = planes[planeIndex];
      var plane1 = planes[planeIndex + 1];
      if (!defined(plane0)) {
        plane0 = planes[planeIndex] = new Cartesian4();
      }
      if (!defined(plane1)) {
        plane1 = planes[planeIndex + 1] = new Cartesian4();
      }
      Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);
      Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);
      plane0.x = faceNormal.x;
      plane0.y = faceNormal.y;
      plane0.z = faceNormal.z;
      plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);
      Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);
      Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);
      plane1.x = -faceNormal.x;
      plane1.y = -faceNormal.y;
      plane1.z = -faceNormal.z;
      plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);
      planeIndex += 2;
    }
    return result;
  };
  CullingVolume.prototype.computeVisibility = function(boundingVolume) {
    if (!defined(boundingVolume)) {
      throw new DeveloperError('boundingVolume is required.');
    }
    var planes = this.planes;
    var intersecting = false;
    for (var k = 0,
        len = planes.length; k < len; ++k) {
      var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
      if (result === Intersect.OUTSIDE) {
        return Intersect.OUTSIDE;
      } else if (result === Intersect.INTERSECTING) {
        intersecting = true;
      }
    }
    return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
  };
  CullingVolume.prototype.computeVisibilityWithPlaneMask = function(boundingVolume, parentPlaneMask) {
    if (!defined(boundingVolume)) {
      throw new DeveloperError('boundingVolume is required.');
    }
    if (!defined(parentPlaneMask)) {
      throw new DeveloperError('parentPlaneMask is required.');
    }
    if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
      return parentPlaneMask;
    }
    var mask = CullingVolume.MASK_INSIDE;
    var planes = this.planes;
    for (var k = 0,
        len = planes.length; k < len; ++k) {
      var flag = (k < 31) ? (1 << k) : 0;
      if (k < 31 && (parentPlaneMask & flag) === 0) {
        continue;
      }
      var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
      if (result === Intersect.OUTSIDE) {
        return CullingVolume.MASK_OUTSIDE;
      } else if (result === Intersect.INTERSECTING) {
        mask |= flag;
      }
    }
    return mask;
  };
  CullingVolume.MASK_OUTSIDE = 0xffffffff;
  CullingVolume.MASK_INSIDE = 0x00000000;
  CullingVolume.MASK_INDETERMINATE = 0x7fffffff;
  return CullingVolume;
});

})();
(function() {
var define = $__System.amdDefine;
define("30", ["1f", "32", "5", "6", "7", "28", "31"], function(Cartesian3, Cartesian4, defined, defineProperties, DeveloperError, Matrix4, CullingVolume) {
  'use strict';
  function PerspectiveOffCenterFrustum() {
    this.left = undefined;
    this._left = undefined;
    this.right = undefined;
    this._right = undefined;
    this.top = undefined;
    this._top = undefined;
    this.bottom = undefined;
    this._bottom = undefined;
    this.near = 1.0;
    this._near = this.near;
    this.far = 500000000.0;
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
  }
  function update(frustum) {
    if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
      throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
    }
    var t = frustum.top;
    var b = frustum.bottom;
    var r = frustum.right;
    var l = frustum.left;
    var n = frustum.near;
    var f = frustum.far;
    if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
      if (frustum.near <= 0 || frustum.near > frustum.far) {
        throw new DeveloperError('near must be greater than zero and less than far.');
      }
      frustum._left = l;
      frustum._right = r;
      frustum._top = t;
      frustum._bottom = b;
      frustum._near = n;
      frustum._far = f;
      frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
      frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
    }
  }
  defineProperties(PerspectiveOffCenterFrustum.prototype, {
    projectionMatrix: {get: function() {
        update(this);
        return this._perspectiveMatrix;
      }},
    infiniteProjectionMatrix: {get: function() {
        update(this);
        return this._infinitePerspective;
      }}
  });
  var getPlanesRight = new Cartesian3();
  var getPlanesNearCenter = new Cartesian3();
  var getPlanesFarCenter = new Cartesian3();
  var getPlanesNormal = new Cartesian3();
  PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {
    if (!defined(position)) {
      throw new DeveloperError('position is required.');
    }
    if (!defined(direction)) {
      throw new DeveloperError('direction is required.');
    }
    if (!defined(up)) {
      throw new DeveloperError('up is required.');
    }
    var planes = this._cullingVolume.planes;
    var t = this.top;
    var b = this.bottom;
    var r = this.right;
    var l = this.left;
    var n = this.near;
    var f = this.far;
    var right = Cartesian3.cross(direction, up, getPlanesRight);
    var nearCenter = getPlanesNearCenter;
    Cartesian3.multiplyByScalar(direction, n, nearCenter);
    Cartesian3.add(position, nearCenter, nearCenter);
    var farCenter = getPlanesFarCenter;
    Cartesian3.multiplyByScalar(direction, f, farCenter);
    Cartesian3.add(position, farCenter, farCenter);
    var normal = getPlanesNormal;
    Cartesian3.multiplyByScalar(right, l, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(normal, up, normal);
    var plane = planes[0];
    if (!defined(plane)) {
      plane = planes[0] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(right, r, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(up, normal, normal);
    plane = planes[1];
    if (!defined(plane)) {
      plane = planes[1] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(up, b, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(right, normal, normal);
    plane = planes[2];
    if (!defined(plane)) {
      plane = planes[2] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(up, t, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(normal, right, normal);
    plane = planes[3];
    if (!defined(plane)) {
      plane = planes[3] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    plane = planes[4];
    if (!defined(plane)) {
      plane = planes[4] = new Cartesian4();
    }
    plane.x = direction.x;
    plane.y = direction.y;
    plane.z = direction.z;
    plane.w = -Cartesian3.dot(direction, nearCenter);
    Cartesian3.negate(direction, normal);
    plane = planes[5];
    if (!defined(plane)) {
      plane = planes[5] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, farCenter);
    return this._cullingVolume;
  };
  PerspectiveOffCenterFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, result) {
    update(this);
    if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {
      throw new DeveloperError('Both drawingBufferWidth and drawingBufferHeight are required.');
    }
    if (drawingBufferWidth <= 0) {
      throw new DeveloperError('drawingBufferWidth must be greater than zero.');
    }
    if (drawingBufferHeight <= 0) {
      throw new DeveloperError('drawingBufferHeight must be greater than zero.');
    }
    if (!defined(distance)) {
      throw new DeveloperError('distance is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('A result object is required.');
    }
    var inverseNear = 1.0 / this.near;
    var tanTheta = this.top * inverseNear;
    var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
    tanTheta = this.right * inverseNear;
    var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
    result.x = pixelWidth;
    result.y = pixelHeight;
    return result;
  };
  PerspectiveOffCenterFrustum.prototype.clone = function(result) {
    if (!defined(result)) {
      result = new PerspectiveOffCenterFrustum();
    }
    result.right = this.right;
    result.left = this.left;
    result.top = this.top;
    result.bottom = this.bottom;
    result.near = this.near;
    result.far = this.far;
    result._left = undefined;
    result._right = undefined;
    result._top = undefined;
    result._bottom = undefined;
    result._near = undefined;
    result._far = undefined;
    return result;
  };
  PerspectiveOffCenterFrustum.prototype.equals = function(other) {
    return (defined(other) && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far);
  };
  return PerspectiveOffCenterFrustum;
});

})();
(function() {
var define = $__System.amdDefine;
define("35", ["5", "6", "7", "8", "26"], function(defined, defineProperties, DeveloperError, Event, Property) {
  "use strict";
  function resolve(that) {
    var targetEntity = that._targetEntity;
    if (that._resolveEntity) {
      targetEntity = that._targetCollection.getById(that._targetId);
      if (defined(targetEntity)) {
        that._targetEntity = targetEntity;
        that._resolveEntity = false;
      }
    }
    return targetEntity;
  }
  var ReferenceEntity = function(targetCollection, targetId) {
    if (!defined(targetCollection)) {
      throw new DeveloperError('targetCollection is required.');
    }
    if (!defined(targetId) || targetId === '') {
      throw new DeveloperError('targetId is required.');
    }
    this._targetCollection = targetCollection;
    this._targetId = targetId;
    this._targetEntity = undefined;
    this._definitionChanged = new Event();
    this._resolveEntity = true;
    targetCollection.collectionChanged.addEventListener(ReferenceEntity.prototype._onCollectionChanged, this);
  };
  defineProperties(ReferenceEntity.prototype, {
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    id: {get: function() {
        return this._targetId;
      }},
    position: {get: function() {
        var entity = resolve(this);
        return defined(entity) ? entity.position : undefined;
      }},
    orientation: {get: function() {
        var entity = resolve(this);
        return defined(entity) ? entity.orientation : undefined;
      }},
    targetId: {get: function() {
        return this._targetId;
      }},
    targetCollection: {get: function() {
        return this._targetCollection;
      }},
    resolvedEntity: {get: function() {
        return resolve(this);
      }}
  });
  ReferenceEntity.prototype._onCollectionChanged = function(collection, added, removed) {
    var targetEntity = this._targetEntity;
    if (defined(targetEntity)) {
      if (removed.indexOf(targetEntity) !== -1) {
        this._resolveEntity = true;
      } else if (this._resolveEntity) {
        resolve(this);
        if (!this._resolveEntity) {
          this._definitionChanged.raiseEvent(this);
        }
      }
    }
  };
  return ReferenceEntity;
});

})();
(function() {
var define = $__System.amdDefine;
define("36", ["5", "6", "7", "8", "2c", "26"], function(defined, defineProperties, DeveloperError, Event, RuntimeError, Property) {
  'use strict';
  function resolveEntity(that) {
    var entityIsResolved = true;
    if (that._resolveEntity) {
      var targetEntity = that._targetCollection.getById(that._targetId);
      if (defined(targetEntity)) {
        targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
        that._targetEntity = targetEntity;
        that._resolveEntity = false;
      } else {
        targetEntity = that._targetEntity;
        entityIsResolved = false;
      }
      if (!defined(targetEntity)) {
        throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
      }
    }
    return entityIsResolved;
  }
  function resolve(that) {
    var targetProperty = that._targetProperty;
    if (that._resolveProperty) {
      var entityIsResolved = resolveEntity(that);
      var names = that._targetPropertyNames;
      targetProperty = that._targetEntity;
      var length = names.length;
      for (var i = 0; i < length && defined(targetProperty); i++) {
        targetProperty = targetProperty[names[i]];
      }
      if (defined(targetProperty)) {
        that._targetProperty = targetProperty;
        that._resolveProperty = !entityIsResolved;
      } else if (!defined(that._targetProperty)) {
        throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
      }
    }
    return targetProperty;
  }
  function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {
    if (!defined(targetCollection)) {
      throw new DeveloperError('targetCollection is required.');
    }
    if (!defined(targetId) || targetId === '') {
      throw new DeveloperError('targetId is required.');
    }
    if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
      throw new DeveloperError('targetPropertyNames is required.');
    }
    for (var i = 0; i < targetPropertyNames.length; i++) {
      var item = targetPropertyNames[i];
      if (!defined(item) || item === '') {
        throw new DeveloperError('reference contains invalid properties.');
      }
    }
    this._targetCollection = targetCollection;
    this._targetId = targetId;
    this._targetPropertyNames = targetPropertyNames;
    this._targetProperty = undefined;
    this._targetEntity = undefined;
    this._definitionChanged = new Event();
    this._resolveEntity = true;
    this._resolveProperty = true;
    targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
  }
  defineProperties(ReferenceProperty.prototype, {
    isConstant: {get: function() {
        return Property.isConstant(resolve(this));
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    referenceFrame: {get: function() {
        return resolve(this).referenceFrame;
      }},
    targetId: {get: function() {
        return this._targetId;
      }},
    targetCollection: {get: function() {
        return this._targetCollection;
      }},
    targetPropertyNames: {get: function() {
        return this._targetPropertyNames;
      }},
    resolvedProperty: {get: function() {
        return resolve(this);
      }}
  });
  ReferenceProperty.fromString = function(targetCollection, referenceString) {
    if (!defined(targetCollection)) {
      throw new DeveloperError('targetCollection is required.');
    }
    if (!defined(referenceString)) {
      throw new DeveloperError('referenceString is required.');
    }
    var identifier;
    var values = [];
    var inIdentifier = true;
    var isEscaped = false;
    var token = '';
    for (var i = 0; i < referenceString.length; ++i) {
      var c = referenceString.charAt(i);
      if (isEscaped) {
        token += c;
        isEscaped = false;
      } else if (c === '\\') {
        isEscaped = true;
      } else if (inIdentifier && c === '#') {
        identifier = token;
        inIdentifier = false;
        token = '';
      } else if (!inIdentifier && c === '.') {
        values.push(token);
        token = '';
      } else {
        token += c;
      }
    }
    values.push(token);
    return new ReferenceProperty(targetCollection, identifier, values);
  };
  ReferenceProperty.prototype.getValue = function(time, result) {
    return resolve(this).getValue(time, result);
  };
  ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
    return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
  };
  ReferenceProperty.prototype.getType = function(time) {
    return resolve(this).getType(time);
  };
  ReferenceProperty.prototype.equals = function(other) {
    if (this === other) {
      return true;
    }
    var names = this._targetPropertyNames;
    var otherNames = other._targetPropertyNames;
    if (this._targetCollection !== other._targetCollection || this._targetId !== other._targetId || names.length !== otherNames.length) {
      return false;
    }
    var length = this._targetPropertyNames.length;
    for (var i = 0; i < length; i++) {
      if (names[i] !== otherNames[i]) {
        return false;
      }
    }
    return true;
  };
  ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {
    if (this._targetPropertyNames[0] === name) {
      this._resolveProperty = true;
      this._definitionChanged.raiseEvent(this);
    }
  };
  ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {
    var targetEntity = this._targetEntity;
    if (defined(targetEntity)) {
      if (removed.indexOf(targetEntity) !== -1) {
        targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
        this._resolveEntity = true;
        this._resolveProperty = true;
      } else if (this._resolveEntity) {
        resolve(this);
        if (!this._resolveEntity) {
          this._definitionChanged.raiseEvent(this);
        }
      }
    }
  };
  return ReferenceProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("20", ["11"], function(freezeObject) {
  'use strict';
  var ReferenceFrame = {
    FIXED: 0,
    INERTIAL: 1
  };
  return freezeObject(ReferenceFrame);
});

})();
(function() {
var define = $__System.amdDefine;
define("21", ["1f", "5", "6", "7", "27", "28", "29", "20", "2a"], function(Cartesian3, defined, defineProperties, DeveloperError, Matrix3, Matrix4, Quaternion, ReferenceFrame, Transforms) {
  'use strict';
  function PositionProperty() {
    DeveloperError.throwInstantiationError();
  }
  defineProperties(PositionProperty.prototype, {
    isConstant: {get: DeveloperError.throwInstantiationError},
    definitionChanged: {get: DeveloperError.throwInstantiationError},
    referenceFrame: {get: DeveloperError.throwInstantiationError}
  });
  PositionProperty.prototype.getValue = DeveloperError.throwInstantiationError;
  PositionProperty.prototype.getValueInReferenceFrame = DeveloperError.throwInstantiationError;
  PositionProperty.prototype.equals = DeveloperError.throwInstantiationError;
  function framesEqual(frame1, frame2) {
    return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
  }
  function frameParents(frame) {
    var frames = [];
    while (defined(frame)) {
      frames.unshift(frame);
      frame = frame.position && frame.position.referenceFrame;
    }
    return frames;
  }
  function lowestCommonAncestor(parents1, parents2) {
    if (!framesEqual(parents1[0], parents2[0])) {
      return -1;
    }
    var h = Math.min(parents1.length, parents2.length);
    for (var i = 0; i <= h; i++) {
      if (!framesEqual(parents1[i], parents2[i])) {
        return i - 1;
      }
    }
    return -1;
  }
  var scratchIcrfToFixedMatrix3 = new Matrix3();
  function getIcrfToFixed(time) {
    var icrfToFixed = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
    if (!defined(icrfToFixed)) {
      icrfToFixed = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
    }
    return icrfToFixed;
  }
  var scratchMatrix3 = new Matrix3();
  var scratchCartesian3 = new Cartesian3();
  var scratchQuaternion = new Quaternion();
  PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
    if (!defined(value)) {
      return value;
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    if (inputFrame === outputFrame) {
      return Cartesian3.clone(value, result);
    }
    if (!defined(inputFrame) || !defined(outputFrame)) {
      return undefined;
    }
    var inputFrameParents = frameParents(inputFrame);
    var outputFrameParents = frameParents(outputFrame);
    var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
    var lcaFrame = inputFrameParents[lcaIndex];
    var inputPositionAccumulator = function(accumulatedPositionValue, frame) {
      if (!defined(accumulatedPositionValue)) {
        return accumulatedPositionValue;
      }
      var framePositionProperty = frame.position;
      if (!defined(framePositionProperty)) {
        return undefined;
      }
      var frameReferenceFrame = framePositionProperty.referenceFrame;
      var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
      if (!defined(framePositionValue)) {
        return undefined;
      }
      var frameOrientationProperty = frame.orientation;
      if (defined(frameOrientationProperty)) {
        var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
        if (!defined(frameOrientationValue)) {
          return undefined;
        }
        Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
        Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
        return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
      }
      return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
    };
    var outputPositionAccumulator = function(accumulatedPositionValue, frame) {
      if (!defined(accumulatedPositionValue)) {
        return accumulatedPositionValue;
      }
      var framePositionProperty = frame.position;
      if (!defined(framePositionProperty)) {
        return undefined;
      }
      var frameReferenceFrame = framePositionProperty.referenceFrame;
      var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
      if (!defined(framePositionValue)) {
        return undefined;
      }
      accumulatedPositionValue = Cartesian3.subtract(accumulatedPositionValue, framePositionValue, accumulatedPositionValue);
      var frameOrientationProperty = frame.orientation;
      if (defined(frameOrientationProperty)) {
        var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
        if (!defined(frameOrientationValue)) {
          return undefined;
        }
        Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
        Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
        Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
      }
      return accumulatedPositionValue;
    };
    if (defined(lcaFrame)) {
      inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
      outputFrameParents = outputFrameParents.slice(lcaIndex + 1);
      var lcaFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
      if (!defined(lcaFrameValue)) {
        return undefined;
      }
      return outputFrameParents.reduce(outputPositionAccumulator, lcaFrameValue);
    }
    var inputRootFrame = inputFrameParents.shift();
    var outputRootFrame = outputFrameParents.shift();
    var fixedFrameValue,
        inertialFrameValue;
    if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
      inertialFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
      if (!defined(inertialFrameValue)) {
        return undefined;
      }
      fixedFrameValue = Matrix3.multiplyByVector(getIcrfToFixed(time), inertialFrameValue, result);
      return outputFrameParents.reduce(outputPositionAccumulator, fixedFrameValue);
    }
    if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
      fixedFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
      if (!defined(fixedFrameValue)) {
        return undefined;
      }
      var fixedToIcrf = Matrix3.transpose(getIcrfToFixed(time), scratchMatrix3);
      inertialFrameValue = Matrix3.multiplyByVector(fixedToIcrf, fixedFrameValue, result);
      return outputFrameParents.reduce(outputPositionAccumulator, inertialFrameValue);
    }
    return undefined;
  };
  return PositionProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("26", ["15", "5", "6", "7"], function(defaultValue, defined, defineProperties, DeveloperError) {
  'use strict';
  function Property() {
    DeveloperError.throwInstantiationError();
  }
  defineProperties(Property.prototype, {
    isConstant: {get: DeveloperError.throwInstantiationError},
    definitionChanged: {get: DeveloperError.throwInstantiationError}
  });
  Property.prototype.getValue = DeveloperError.throwInstantiationError;
  Property.prototype.equals = DeveloperError.throwInstantiationError;
  Property.equals = function(left, right) {
    return left === right || (defined(left) && left.equals(right));
  };
  Property.arrayEquals = function(left, right) {
    if (left === right) {
      return true;
    }
    if ((!defined(left) || !defined(right)) || (left.length !== right.length)) {
      return false;
    }
    var length = left.length;
    for (var i = 0; i < length; i++) {
      if (!Property.equals(left[i], right[i])) {
        return false;
      }
    }
    return true;
  };
  Property.isConstant = function(property) {
    return !defined(property) || property.isConstant;
  };
  Property.getValueOrUndefined = function(property, time, result) {
    return defined(property) ? property.getValue(time, result) : undefined;
  };
  Property.getValueOrDefault = function(property, time, valueDefault, result) {
    return defined(property) ? defaultValue(property.getValue(time, result), valueDefault) : valueDefault;
  };
  Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
    var value;
    if (defined(property)) {
      value = property.getValue(time, result);
    }
    if (!defined(value)) {
      value = valueDefault.clone(value);
    }
    return value;
  };
  return Property;
});

})();
(function() {
var define = $__System.amdDefine;
define("37", ["1f", "15", "5", "6", "7", "8", "20", "21", "26", "38"], function(Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty, Property, SampledProperty) {
  'use strict';
  function SampledPositionProperty(referenceFrame, numberOfDerivatives) {
    numberOfDerivatives = defaultValue(numberOfDerivatives, 0);
    var derivativeTypes;
    if (numberOfDerivatives > 0) {
      derivativeTypes = new Array(numberOfDerivatives);
      for (var i = 0; i < numberOfDerivatives; i++) {
        derivativeTypes[i] = Cartesian3;
      }
    }
    this._numberOfDerivatives = numberOfDerivatives;
    this._property = new SampledProperty(Cartesian3, derivativeTypes);
    this._definitionChanged = new Event();
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
    this._property._definitionChanged.addEventListener(function() {
      this._definitionChanged.raiseEvent(this);
    }, this);
  }
  defineProperties(SampledPositionProperty.prototype, {
    isConstant: {get: function() {
        return this._property.isConstant;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    referenceFrame: {get: function() {
        return this._referenceFrame;
      }},
    interpolationDegree: {get: function() {
        return this._property.interpolationDegree;
      }},
    interpolationAlgorithm: {get: function() {
        return this._property.interpolationAlgorithm;
      }},
    numberOfDerivatives: {get: function() {
        return this._numberOfDerivatives;
      }},
    forwardExtrapolationType: {
      get: function() {
        return this._property.forwardExtrapolationType;
      },
      set: function(value) {
        this._property.forwardExtrapolationType = value;
      }
    },
    forwardExtrapolationDuration: {
      get: function() {
        return this._property.forwardExtrapolationDuration;
      },
      set: function(value) {
        this._property.forwardExtrapolationDuration = value;
      }
    },
    backwardExtrapolationType: {
      get: function() {
        return this._property.backwardExtrapolationType;
      },
      set: function(value) {
        this._property.backwardExtrapolationType = value;
      }
    },
    backwardExtrapolationDuration: {
      get: function() {
        return this._property.backwardExtrapolationDuration;
      },
      set: function(value) {
        this._property.backwardExtrapolationDuration = value;
      }
    }
  });
  SampledPositionProperty.prototype.getValue = function(time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
  };
  SampledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
      throw new DeveloperError('referenceFrame is required.');
    }
    result = this._property.getValue(time, result);
    if (defined(result)) {
      return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);
    }
    return undefined;
  };
  SampledPositionProperty.prototype.setInterpolationOptions = function(options) {
    this._property.setInterpolationOptions(options);
  };
  SampledPositionProperty.prototype.addSample = function(time, position, derivatives) {
    var numberOfDerivatives = this._numberOfDerivatives;
    if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {
      throw new DeveloperError('derivatives length must be equal to the number of derivatives.');
    }
    this._property.addSample(time, position, derivatives);
  };
  SampledPositionProperty.prototype.addSamples = function(times, positions, derivatives) {
    this._property.addSamples(times, positions, derivatives);
  };
  SampledPositionProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
    this._property.addSamplesPackedArray(packedSamples, epoch);
  };
  SampledPositionProperty.prototype.equals = function(other) {
    return this === other || (other instanceof SampledPositionProperty && Property.equals(this._property, other._property) && this._referenceFrame === other._referenceFrame);
  };
  return SampledPositionProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("8", ["5", "6", "7"], function(defined, defineProperties, DeveloperError) {
  'use strict';
  function Event() {
    this._listeners = [];
    this._scopes = [];
    this._toRemove = [];
    this._insideRaiseEvent = false;
  }
  defineProperties(Event.prototype, {numberOfListeners: {get: function() {
        return this._listeners.length - this._toRemove.length;
      }}});
  Event.prototype.addEventListener = function(listener, scope) {
    if (typeof listener !== 'function') {
      throw new DeveloperError('listener is required and must be a function.');
    }
    this._listeners.push(listener);
    this._scopes.push(scope);
    var event = this;
    return function() {
      event.removeEventListener(listener, scope);
    };
  };
  Event.prototype.removeEventListener = function(listener, scope) {
    if (typeof listener !== 'function') {
      throw new DeveloperError('listener is required and must be a function.');
    }
    var listeners = this._listeners;
    var scopes = this._scopes;
    var index = -1;
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener && scopes[i] === scope) {
        index = i;
        break;
      }
    }
    if (index !== -1) {
      if (this._insideRaiseEvent) {
        this._toRemove.push(index);
        listeners[index] = undefined;
        scopes[index] = undefined;
      } else {
        listeners.splice(index, 1);
        scopes.splice(index, 1);
      }
      return true;
    }
    return false;
  };
  Event.prototype.raiseEvent = function() {
    this._insideRaiseEvent = true;
    var i;
    var listeners = this._listeners;
    var scopes = this._scopes;
    var length = listeners.length;
    for (i = 0; i < length; i++) {
      var listener = listeners[i];
      if (defined(listener)) {
        listeners[i].apply(scopes[i], arguments);
      }
    }
    var toRemove = this._toRemove;
    length = toRemove.length;
    for (i = 0; i < length; i++) {
      var index = toRemove[i];
      listeners.splice(index, 1);
      scopes.splice(index, 1);
    }
    toRemove.length = 0;
    this._insideRaiseEvent = false;
  };
  return Event;
});

})();
(function() {
var define = $__System.amdDefine;
define("39", ["11"], function(freezeObject) {
  'use strict';
  var ExtrapolationType = {
    NONE: 0,
    HOLD: 1,
    EXTRAPOLATE: 2
  };
  return freezeObject(ExtrapolationType);
});

})();
(function() {
var define = $__System.amdDefine;
define("3a", ["5", "7"], function(defined, DeveloperError) {
  'use strict';
  var LinearApproximation = {type: 'Linear'};
  LinearApproximation.getRequiredDataPoints = function(degree) {
    return 2;
  };
  LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
    if (xTable.length !== 2) {
      throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
    } else if (yStride <= 0) {
      throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
    }
    if (!defined(result)) {
      result = new Array(yStride);
    }
    var i;
    var y0;
    var y1;
    var x0 = xTable[0];
    var x1 = xTable[1];
    if (x0 === x1) {
      throw new DeveloperError('Divide by zero error: xTable[0] and xTable[1] are equal');
    }
    for (i = 0; i < yStride; i++) {
      y0 = yTable[i];
      y1 = yTable[i + yStride];
      result[i] = (((y1 - y0) * x) + (x1 * y0) - (x0 * y1)) / (x1 - x0);
    }
    return result;
  };
  return LinearApproximation;
});

})();
(function() {
var define = $__System.amdDefine;
define("38", ["3b", "15", "5", "6", "7", "8", "39", "17", "3a"], function(binarySearch, defaultValue, defined, defineProperties, DeveloperError, Event, ExtrapolationType, JulianDate, LinearApproximation) {
  'use strict';
  var PackableNumber = {
    packedLength: 1,
    pack: function(value, array, startingIndex) {
      startingIndex = defaultValue(startingIndex, 0);
      array[startingIndex] = value;
    },
    unpack: function(array, startingIndex, result) {
      startingIndex = defaultValue(startingIndex, 0);
      return array[startingIndex];
    }
  };
  function arrayInsert(array, startIndex, items) {
    var i;
    var arrayLength = array.length;
    var itemsLength = items.length;
    var newLength = arrayLength + itemsLength;
    array.length = newLength;
    if (arrayLength !== startIndex) {
      var q = arrayLength - 1;
      for (i = newLength - 1; i >= startIndex; i--) {
        array[i] = array[q--];
      }
    }
    for (i = 0; i < itemsLength; i++) {
      array[startIndex++] = items[i];
    }
  }
  function convertDate(date, epoch) {
    if (date instanceof JulianDate) {
      return date;
    }
    if (typeof date === 'string') {
      return JulianDate.fromIso8601(date);
    }
    return JulianDate.addSeconds(epoch, date, new JulianDate());
  }
  var timesSpliceArgs = [];
  var valuesSpliceArgs = [];
  function mergeNewSamples(epoch, times, values, newData, packedLength) {
    var newDataIndex = 0;
    var i;
    var prevItem;
    var timesInsertionPoint;
    var valuesInsertionPoint;
    var currentTime;
    var nextTime;
    while (newDataIndex < newData.length) {
      currentTime = convertDate(newData[newDataIndex], epoch);
      timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);
      var timesSpliceArgsCount = 0;
      var valuesSpliceArgsCount = 0;
      if (timesInsertionPoint < 0) {
        timesInsertionPoint = ~timesInsertionPoint;
        valuesInsertionPoint = timesInsertionPoint * packedLength;
        prevItem = undefined;
        nextTime = times[timesInsertionPoint];
        while (newDataIndex < newData.length) {
          currentTime = convertDate(newData[newDataIndex], epoch);
          if ((defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0) || (defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0)) {
            break;
          }
          timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
          newDataIndex = newDataIndex + 1;
          for (i = 0; i < packedLength; i++) {
            valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
            newDataIndex = newDataIndex + 1;
          }
          prevItem = currentTime;
        }
        if (timesSpliceArgsCount > 0) {
          valuesSpliceArgs.length = valuesSpliceArgsCount;
          arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);
          timesSpliceArgs.length = timesSpliceArgsCount;
          arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
        }
      } else {
        for (i = 0; i < packedLength; i++) {
          newDataIndex++;
          values[(timesInsertionPoint * packedLength) + i] = newData[newDataIndex];
        }
        newDataIndex++;
      }
    }
  }
  function SampledProperty(type, derivativeTypes) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var innerType = type;
    if (innerType === Number) {
      innerType = PackableNumber;
    }
    var packedLength = innerType.packedLength;
    var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);
    var inputOrder = 0;
    var innerDerivativeTypes;
    if (defined(derivativeTypes)) {
      var length = derivativeTypes.length;
      innerDerivativeTypes = new Array(length);
      for (var i = 0; i < length; i++) {
        var derivativeType = derivativeTypes[i];
        if (derivativeType === Number) {
          derivativeType = PackableNumber;
        }
        var derivativePackedLength = derivativeType.packedLength;
        packedLength += derivativePackedLength;
        packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);
        innerDerivativeTypes[i] = derivativeType;
      }
      inputOrder = length;
    }
    this._type = type;
    this._innerType = innerType;
    this._interpolationDegree = 1;
    this._interpolationAlgorithm = LinearApproximation;
    this._numberOfPoints = 0;
    this._times = [];
    this._values = [];
    this._xTable = [];
    this._yTable = [];
    this._packedLength = packedLength;
    this._packedInterpolationLength = packedInterpolationLength;
    this._updateTableLength = true;
    this._interpolationResult = new Array(packedInterpolationLength);
    this._definitionChanged = new Event();
    this._derivativeTypes = derivativeTypes;
    this._innerDerivativeTypes = innerDerivativeTypes;
    this._inputOrder = inputOrder;
    this._forwardExtrapolationType = ExtrapolationType.NONE;
    this._forwardExtrapolationDuration = 0;
    this._backwardExtrapolationType = ExtrapolationType.NONE;
    this._backwardExtrapolationDuration = 0;
  }
  defineProperties(SampledProperty.prototype, {
    isConstant: {get: function() {
        return this._values.length === 0;
      }},
    definitionChanged: {get: function() {
        return this._definitionChanged;
      }},
    type: {get: function() {
        return this._type;
      }},
    derivativeTypes: {get: function() {
        return this._derivativeTypes;
      }},
    interpolationDegree: {get: function() {
        return this._interpolationDegree;
      }},
    interpolationAlgorithm: {get: function() {
        return this._interpolationAlgorithm;
      }},
    forwardExtrapolationType: {
      get: function() {
        return this._forwardExtrapolationType;
      },
      set: function(value) {
        if (this._forwardExtrapolationType !== value) {
          this._forwardExtrapolationType = value;
          this._definitionChanged.raiseEvent(this);
        }
      }
    },
    forwardExtrapolationDuration: {
      get: function() {
        return this._forwardExtrapolationDuration;
      },
      set: function(value) {
        if (this._forwardExtrapolationDuration !== value) {
          this._forwardExtrapolationDuration = value;
          this._definitionChanged.raiseEvent(this);
        }
      }
    },
    backwardExtrapolationType: {
      get: function() {
        return this._backwardExtrapolationType;
      },
      set: function(value) {
        if (this._backwardExtrapolationType !== value) {
          this._backwardExtrapolationType = value;
          this._definitionChanged.raiseEvent(this);
        }
      }
    },
    backwardExtrapolationDuration: {
      get: function() {
        return this._backwardExtrapolationDuration;
      },
      set: function(value) {
        if (this._backwardExtrapolationDuration !== value) {
          this._backwardExtrapolationDuration = value;
          this._definitionChanged.raiseEvent(this);
        }
      }
    }
  });
  SampledProperty.prototype.getValue = function(time, result) {
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    var times = this._times;
    var timesLength = times.length;
    if (timesLength === 0) {
      return undefined;
    }
    var timeout;
    var innerType = this._innerType;
    var values = this._values;
    var index = binarySearch(times, time, JulianDate.compare);
    if (index < 0) {
      index = ~index;
      if (index === 0) {
        var startTime = times[index];
        timeout = this._backwardExtrapolationDuration;
        if (this._backwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout)) {
          return undefined;
        }
        if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {
          return innerType.unpack(values, 0, result);
        }
      }
      if (index >= timesLength) {
        index = timesLength - 1;
        var endTime = times[index];
        timeout = this._forwardExtrapolationDuration;
        if (this._forwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout)) {
          return undefined;
        }
        if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {
          index = timesLength - 1;
          return innerType.unpack(values, index * innerType.packedLength, result);
        }
      }
      var xTable = this._xTable;
      var yTable = this._yTable;
      var interpolationAlgorithm = this._interpolationAlgorithm;
      var packedInterpolationLength = this._packedInterpolationLength;
      var inputOrder = this._inputOrder;
      if (this._updateTableLength) {
        this._updateTableLength = false;
        var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);
        if (numberOfPoints !== this._numberOfPoints) {
          this._numberOfPoints = numberOfPoints;
          xTable.length = numberOfPoints;
          yTable.length = numberOfPoints * packedInterpolationLength;
        }
      }
      var degree = this._numberOfPoints - 1;
      if (degree < 1) {
        return undefined;
      }
      var firstIndex = 0;
      var lastIndex = timesLength - 1;
      var pointsInCollection = lastIndex - firstIndex + 1;
      if (pointsInCollection >= degree + 1) {
        var computedFirstIndex = index - ((degree / 2) | 0) - 1;
        if (computedFirstIndex < firstIndex) {
          computedFirstIndex = firstIndex;
        }
        var computedLastIndex = computedFirstIndex + degree;
        if (computedLastIndex > lastIndex) {
          computedLastIndex = lastIndex;
          computedFirstIndex = computedLastIndex - degree;
          if (computedFirstIndex < firstIndex) {
            computedFirstIndex = firstIndex;
          }
        }
        firstIndex = computedFirstIndex;
        lastIndex = computedLastIndex;
      }
      var length = lastIndex - firstIndex + 1;
      for (var i = 0; i < length; ++i) {
        xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
      }
      if (!defined(innerType.convertPackedArrayForInterpolation)) {
        var destinationIndex = 0;
        var packedLength = this._packedLength;
        var sourceIndex = firstIndex * packedLength;
        var stop = (lastIndex + 1) * packedLength;
        while (sourceIndex < stop) {
          yTable[destinationIndex] = values[sourceIndex];
          sourceIndex++;
          destinationIndex++;
        }
      } else {
        innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
      }
      var x = JulianDate.secondsDifference(time, times[lastIndex]);
      var interpolationResult;
      if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {
        interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);
      } else {
        var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
        interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);
      }
      if (!defined(innerType.unpackInterpolationResult)) {
        return innerType.unpack(interpolationResult, 0, result);
      }
      return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);
    }
    return innerType.unpack(values, index * this._packedLength, result);
  };
  SampledProperty.prototype.setInterpolationOptions = function(options) {
    if (!defined(options)) {
      throw new DeveloperError('options is required.');
    }
    var valuesChanged = false;
    var interpolationAlgorithm = options.interpolationAlgorithm;
    var interpolationDegree = options.interpolationDegree;
    if (this._interpolationAlgorithm !== interpolationAlgorithm) {
      this._interpolationAlgorithm = interpolationAlgorithm;
      valuesChanged = true;
    }
    if (this._interpolationDegree !== interpolationDegree) {
      this._interpolationDegree = interpolationDegree;
      valuesChanged = true;
    }
    if (valuesChanged) {
      this._updateTableLength = true;
      this._definitionChanged.raiseEvent(this);
    }
  };
  SampledProperty.prototype.addSample = function(time, value, derivatives) {
    var innerDerivativeTypes = this._innerDerivativeTypes;
    var hasDerivatives = defined(innerDerivativeTypes);
    if (!defined(time)) {
      throw new DeveloperError('time is required.');
    }
    if (!defined(value)) {
      throw new DeveloperError('value is required.');
    }
    if (hasDerivatives && !defined(derivatives)) {
      throw new DeveloperError('derivatives is required.');
    }
    var innerType = this._innerType;
    var data = [];
    data.push(time);
    innerType.pack(value, data, data.length);
    if (hasDerivatives) {
      var derivativesLength = innerDerivativeTypes.length;
      for (var x = 0; x < derivativesLength; x++) {
        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
      }
    }
    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
  };
  SampledProperty.prototype.addSamples = function(times, values, derivativeValues) {
    var innerDerivativeTypes = this._innerDerivativeTypes;
    var hasDerivatives = defined(innerDerivativeTypes);
    if (!defined(times)) {
      throw new DeveloperError('times is required.');
    }
    if (!defined(values)) {
      throw new DeveloperError('values is required.');
    }
    if (times.length !== values.length) {
      throw new DeveloperError('times and values must be the same length.');
    }
    if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {
      throw new DeveloperError('times and derivativeValues must be the same length.');
    }
    var innerType = this._innerType;
    var length = times.length;
    var data = [];
    for (var i = 0; i < length; i++) {
      data.push(times[i]);
      innerType.pack(values[i], data, data.length);
      if (hasDerivatives) {
        var derivatives = derivativeValues[i];
        var derivativesLength = innerDerivativeTypes.length;
        for (var x = 0; x < derivativesLength; x++) {
          innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
        }
      }
    }
    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
  };
  SampledProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
    if (!defined(packedSamples)) {
      throw new DeveloperError('packedSamples is required.');
    }
    mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
  };
  SampledProperty.prototype.equals = function(other) {
    if (this === other) {
      return true;
    }
    if (!defined(other)) {
      return false;
    }
    if (this._type !== other._type || this._interpolationDegree !== other._interpolationDegree || this._interpolationAlgorithm !== other._interpolationAlgorithm) {
      return false;
    }
    var derivativeTypes = this._derivativeTypes;
    var hasDerivatives = defined(derivativeTypes);
    var otherDerivativeTypes = other._derivativeTypes;
    var otherHasDerivatives = defined(otherDerivativeTypes);
    if (hasDerivatives !== otherHasDerivatives) {
      return false;
    }
    var i;
    var length;
    if (hasDerivatives) {
      length = derivativeTypes.length;
      if (length !== otherDerivativeTypes.length) {
        return false;
      }
      for (i = 0; i < length; i++) {
        if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
          return false;
        }
      }
    }
    var times = this._times;
    var otherTimes = other._times;
    length = times.length;
    if (length !== otherTimes.length) {
      return false;
    }
    for (i = 0; i < length; i++) {
      if (!JulianDate.equals(times[i], otherTimes[i])) {
        return false;
      }
    }
    var values = this._values;
    var otherValues = other._values;
    for (i = 0; i < length; i++) {
      if (values[i] !== otherValues[i]) {
        return false;
      }
    }
    return true;
  };
  SampledProperty._mergeNewSamples = mergeNewSamples;
  return SampledProperty;
});

})();
(function() {
var define = $__System.amdDefine;
define("2b", ["5", "6", "7"], function(defined, defineProperties, DeveloperError) {
  'use strict';
  function AssociativeArray() {
    this._array = [];
    this._hash = {};
  }
  defineProperties(AssociativeArray.prototype, {
    length: {get: function() {
        return this._array.length;
      }},
    values: {get: function() {
        return this._array;
      }}
  });
  AssociativeArray.prototype.contains = function(key) {
    if (typeof key !== 'string' && typeof key !== 'number') {
      throw new DeveloperError('key is required to be a string or number.');
    }
    return defined(this._hash[key]);
  };
  AssociativeArray.prototype.set = function(key, value) {
    if (typeof key !== 'string' && typeof key !== 'number') {
      throw new DeveloperError('key is required to be a string or number.');
    }
    var oldValue = this._hash[key];
    if (value !== oldValue) {
      this.remove(key);
      this._hash[key] = value;
      this._array.push(value);
    }
  };
  AssociativeArray.prototype.get = function(key) {
    if (typeof key !== 'string' && typeof key !== 'number') {
      throw new DeveloperError('key is required to be a string or number.');
    }
    return this._hash[key];
  };
  AssociativeArray.prototype.remove = function(key) {
    if (defined(key) && typeof key !== 'string' && typeof key !== 'number') {
      throw new DeveloperError('key is required to be a string or number.');
    }
    var value = this._hash[key];
    var hasValue = defined(value);
    if (hasValue) {
      var array = this._array;
      array.splice(array.indexOf(value), 1);
      delete this._hash[key];
    }
    return hasValue;
  };
  AssociativeArray.prototype.removeAll = function() {
    var array = this._array;
    if (array.length > 0) {
      this._hash = {};
      array.length = 0;
    }
  };
  return AssociativeArray;
});

})();
(function() {
var define = $__System.amdDefine;
define("16", ["5"], function(defined) {
  'use strict';
  var getTimestamp;
  if (typeof performance !== 'undefined' && defined(performance.now)) {
    getTimestamp = function() {
      return performance.now();
    };
  } else {
    getTimestamp = function() {
      return Date.now();
    };
  }
  return getTimestamp;
});

})();
(function() {
var define = $__System.amdDefine;
define("c", ["11"], function(freezeObject) {
  'use strict';
  var KeyboardEventModifier = {
    SHIFT: 0,
    CTRL: 1,
    ALT: 2
  };
  return freezeObject(KeyboardEventModifier);
});

})();
(function() {
var define = $__System.amdDefine;
define("e", ["2b", "a", "15", "5", "b", "7", "3c", "16", "c", "f"], function(AssociativeArray, Cartesian2, defaultValue, defined, destroyObject, DeveloperError, FeatureDetection, getTimestamp, KeyboardEventModifier, ScreenSpaceEventType) {
  'use strict';
  function getPosition(screenSpaceEventHandler, event, result) {
    var element = screenSpaceEventHandler._element;
    if (element === document) {
      result.x = event.clientX;
      result.y = event.clientY;
      return result;
    }
    var rect = element.getBoundingClientRect();
    result.x = event.clientX - rect.left;
    result.y = event.clientY - rect.top;
    return result;
  }
  function getInputEventKey(type, modifier) {
    var key = type;
    if (defined(modifier)) {
      key += '+' + modifier;
    }
    return key;
  }
  function getModifier(event) {
    if (event.shiftKey) {
      return KeyboardEventModifier.SHIFT;
    } else if (event.ctrlKey) {
      return KeyboardEventModifier.CTRL;
    } else if (event.altKey) {
      return KeyboardEventModifier.ALT;
    }
    return undefined;
  }
  var MouseButton = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
  };
  function registerListener(screenSpaceEventHandler, domType, element, callback) {
    function listener(e) {
      callback(screenSpaceEventHandler, e);
    }
    element.addEventListener(domType, listener, false);
    screenSpaceEventHandler._removalFunctions.push(function() {
      element.removeEventListener(domType, listener, false);
    });
  }
  function registerListeners(screenSpaceEventHandler) {
    var element = screenSpaceEventHandler._element;
    var alternateElement = !defined(element.disableRootEvents) ? document : element;
    if (FeatureDetection.supportsPointerEvents()) {
      registerListener(screenSpaceEventHandler, 'pointerdown', element, handlePointerDown);
      registerListener(screenSpaceEventHandler, 'pointerup', element, handlePointerUp);
      registerListener(screenSpaceEventHandler, 'pointermove', element, handlePointerMove);
      registerListener(screenSpaceEventHandler, 'pointercancel', element, handlePointerUp);
    } else {
      registerListener(screenSpaceEventHandler, 'mousedown', element, handleMouseDown);
      registerListener(screenSpaceEventHandler, 'mouseup', alternateElement, handleMouseUp);
      registerListener(screenSpaceEventHandler, 'mousemove', alternateElement, handleMouseMove);
      registerListener(screenSpaceEventHandler, 'touchstart', element, handleTouchStart);
      registerListener(screenSpaceEventHandler, 'touchend', alternateElement, handleTouchEnd);
      registerListener(screenSpaceEventHandler, 'touchmove', alternateElement, handleTouchMove);
      registerListener(screenSpaceEventHandler, 'touchcancel', alternateElement, handleTouchEnd);
    }
    registerListener(screenSpaceEventHandler, 'dblclick', element, handleDblClick);
    var wheelEvent;
    if ('onwheel' in element) {
      wheelEvent = 'wheel';
    } else if (document.onmousewheel !== undefined) {
      wheelEvent = 'mousewheel';
    } else {
      wheelEvent = 'DOMMouseScroll';
    }
    registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);
  }
  function unregisterListeners(screenSpaceEventHandler) {
    var removalFunctions = screenSpaceEventHandler._removalFunctions;
    for (var i = 0; i < removalFunctions.length; ++i) {
      removalFunctions[i]();
    }
  }
  var mouseDownEvent = {position: new Cartesian2()};
  function gotTouchEvent(screenSpaceEventHandler) {
    screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp();
  }
  function canProcessMouseEvent(screenSpaceEventHandler) {
    return (getTimestamp() - screenSpaceEventHandler._lastSeenTouchEvent) > ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
  }
  function handleMouseDown(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var button = event.button;
    screenSpaceEventHandler._buttonDown = button;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
      screenSpaceEventType = ScreenSpaceEventType.LEFT_DOWN;
    } else if (button === MouseButton.MIDDLE) {
      screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOWN;
    } else if (button === MouseButton.RIGHT) {
      screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOWN;
    } else {
      return;
    }
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined(action)) {
      Cartesian2.clone(position, mouseDownEvent.position);
      action(mouseDownEvent);
      event.preventDefault();
    }
  }
  var mouseUpEvent = {position: new Cartesian2()};
  var mouseClickEvent = {position: new Cartesian2()};
  function handleMouseUp(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var button = event.button;
    screenSpaceEventHandler._buttonDown = undefined;
    var screenSpaceEventType;
    var clickScreenSpaceEventType;
    if (button === MouseButton.LEFT) {
      screenSpaceEventType = ScreenSpaceEventType.LEFT_UP;
      clickScreenSpaceEventType = ScreenSpaceEventType.LEFT_CLICK;
    } else if (button === MouseButton.MIDDLE) {
      screenSpaceEventType = ScreenSpaceEventType.MIDDLE_UP;
      clickScreenSpaceEventType = ScreenSpaceEventType.MIDDLE_CLICK;
    } else if (button === MouseButton.RIGHT) {
      screenSpaceEventType = ScreenSpaceEventType.RIGHT_UP;
      clickScreenSpaceEventType = ScreenSpaceEventType.RIGHT_CLICK;
    } else {
      return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    var clickAction = screenSpaceEventHandler.getInputAction(clickScreenSpaceEventType, modifier);
    if (defined(action) || defined(clickAction)) {
      var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
      if (defined(action)) {
        Cartesian2.clone(position, mouseUpEvent.position);
        action(mouseUpEvent);
      }
      if (defined(clickAction)) {
        var startPosition = screenSpaceEventHandler._primaryStartPosition;
        var xDiff = startPosition.x - position.x;
        var yDiff = startPosition.y - position.y;
        var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        if (totalPixels < screenSpaceEventHandler._clickPixelTolerance) {
          Cartesian2.clone(position, mouseClickEvent.position);
          clickAction(mouseClickEvent);
        }
      }
    }
  }
  var mouseMoveEvent = {
    startPosition: new Cartesian2(),
    endPosition: new Cartesian2()
  };
  function handleMouseMove(screenSpaceEventHandler, event) {
    if (!canProcessMouseEvent(screenSpaceEventHandler)) {
      return;
    }
    var modifier = getModifier(event);
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);
    if (defined(action)) {
      Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);
      Cartesian2.clone(position, mouseMoveEvent.endPosition);
      action(mouseMoveEvent);
    }
    Cartesian2.clone(position, previousPosition);
    if (defined(screenSpaceEventHandler._buttonDown)) {
      event.preventDefault();
    }
  }
  var mouseDblClickEvent = {position: new Cartesian2()};
  function handleDblClick(screenSpaceEventHandler, event) {
    var button = event.button;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
      screenSpaceEventType = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;
    } else {
      return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined(action)) {
      getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);
      action(mouseDblClickEvent);
    }
  }
  function handleWheel(screenSpaceEventHandler, event) {
    var delta;
    if (defined(event.deltaY)) {
      var deltaMode = event.deltaMode;
      if (deltaMode === event.DOM_DELTA_PIXEL) {
        delta = -event.deltaY;
      } else if (deltaMode === event.DOM_DELTA_LINE) {
        delta = -event.deltaY * 40;
      } else {
        delta = -event.deltaY * 120;
      }
    } else if (event.detail > 0) {
      delta = event.detail * -120;
    } else {
      delta = event.wheelDelta;
    }
    if (!defined(delta)) {
      return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.WHEEL, modifier);
    if (defined(action)) {
      action(delta);
      event.preventDefault();
    }
  }
  function handleTouchStart(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      positions.set(identifier, getPosition(screenSpaceEventHandler, touch, new Cartesian2()));
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    }
  }
  function handleTouchEnd(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      positions.remove(identifier);
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      previousPositions.remove(identifier);
    }
  }
  var touchStartEvent = {position: new Cartesian2()};
  var touch2StartEvent = {
    position1: new Cartesian2(),
    position2: new Cartesian2()
  };
  var touchEndEvent = {position: new Cartesian2()};
  var touchClickEvent = {position: new Cartesian2()};
  function fireTouchEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var previousPositions = screenSpaceEventHandler._previousPositions;
    var numberOfTouches = positions.length;
    var action;
    var clickAction;
    if (numberOfTouches !== 1 && screenSpaceEventHandler._buttonDown === MouseButton.LEFT) {
      screenSpaceEventHandler._buttonDown = undefined;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_UP, modifier);
      if (defined(action)) {
        Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchEndEvent.position);
        action(touchEndEvent);
      }
      if (numberOfTouches === 0) {
        clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_CLICK, modifier);
        if (defined(clickAction)) {
          var startPosition = screenSpaceEventHandler._primaryStartPosition;
          var endPosition = previousPositions.values[0];
          var xDiff = startPosition.x - endPosition.x;
          var yDiff = startPosition.y - endPosition.y;
          var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
          if (totalPixels < screenSpaceEventHandler._clickPixelTolerance) {
            Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchClickEvent.position);
            clickAction(touchClickEvent);
          }
        }
      }
    }
    if (numberOfTouches !== 2 && screenSpaceEventHandler._isPinching) {
      screenSpaceEventHandler._isPinching = false;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_END, modifier);
      if (defined(action)) {
        action();
      }
    }
    if (numberOfTouches === 1) {
      var position = positions.values[0];
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
      Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
      screenSpaceEventHandler._buttonDown = MouseButton.LEFT;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_DOWN, modifier);
      if (defined(action)) {
        Cartesian2.clone(position, touchStartEvent.position);
        action(touchStartEvent);
      }
      event.preventDefault();
    }
    if (numberOfTouches === 2) {
      screenSpaceEventHandler._isPinching = true;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_START, modifier);
      if (defined(action)) {
        Cartesian2.clone(positions.values[0], touch2StartEvent.position1);
        Cartesian2.clone(positions.values[1], touch2StartEvent.position2);
        action(touch2StartEvent);
        event.preventDefault();
      }
    }
  }
  function handleTouchMove(screenSpaceEventHandler, event) {
    gotTouchEvent(screenSpaceEventHandler);
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      var position = positions.get(identifier);
      if (defined(position)) {
        getPosition(screenSpaceEventHandler, touch, position);
      }
    }
    fireTouchMoveEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
      touch = changedTouches[i];
      identifier = touch.identifier;
      Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    }
  }
  var touchMoveEvent = {
    startPosition: new Cartesian2(),
    endPosition: new Cartesian2()
  };
  var touchPinchMovementEvent = {
    distance: {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    },
    angleAndHeight: {
      startPosition: new Cartesian2(),
      endPosition: new Cartesian2()
    }
  };
  function fireTouchMoveEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var previousPositions = screenSpaceEventHandler._previousPositions;
    var numberOfTouches = positions.length;
    var action;
    if (numberOfTouches === 1 && screenSpaceEventHandler._buttonDown === MouseButton.LEFT) {
      var position = positions.values[0];
      Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
      var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);
      if (defined(action)) {
        Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);
        Cartesian2.clone(position, touchMoveEvent.endPosition);
        action(touchMoveEvent);
      }
      Cartesian2.clone(position, previousPosition);
      event.preventDefault();
    } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {
      action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_MOVE, modifier);
      if (defined(action)) {
        var position1 = positions.values[0];
        var position2 = positions.values[1];
        var previousPosition1 = previousPositions.values[0];
        var previousPosition2 = previousPositions.values[1];
        var dX = position2.x - position1.x;
        var dY = position2.y - position1.y;
        var dist = Math.sqrt(dX * dX + dY * dY) * 0.25;
        var prevDX = previousPosition2.x - previousPosition1.x;
        var prevDY = previousPosition2.y - previousPosition1.y;
        var prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;
        var cY = (position2.y + position1.y) * 0.125;
        var prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;
        var angle = Math.atan2(dY, dX);
        var prevAngle = Math.atan2(prevDY, prevDX);
        Cartesian2.fromElements(0.0, prevDist, touchPinchMovementEvent.distance.startPosition);
        Cartesian2.fromElements(0.0, dist, touchPinchMovementEvent.distance.endPosition);
        Cartesian2.fromElements(prevAngle, prevCY, touchPinchMovementEvent.angleAndHeight.startPosition);
        Cartesian2.fromElements(angle, cY, touchPinchMovementEvent.angleAndHeight.endPosition);
        action(touchPinchMovementEvent);
      }
    }
  }
  function handlePointerDown(screenSpaceEventHandler, event) {
    event.target.setPointerCapture(event.pointerId);
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      positions.set(identifier, getPosition(screenSpaceEventHandler, event, new Cartesian2()));
      fireTouchEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    } else {
      handleMouseDown(screenSpaceEventHandler, event);
    }
  }
  function handlePointerUp(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      positions.remove(identifier);
      fireTouchEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      previousPositions.remove(identifier);
    } else {
      handleMouseUp(screenSpaceEventHandler, event);
    }
  }
  function handlePointerMove(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
      var positions = screenSpaceEventHandler._positions;
      var identifier = event.pointerId;
      var position = positions.get(identifier);
      if (!defined(position)) {
        return;
      }
      getPosition(screenSpaceEventHandler, event, position);
      fireTouchMoveEvents(screenSpaceEventHandler, event);
      var previousPositions = screenSpaceEventHandler._previousPositions;
      Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    } else {
      handleMouseMove(screenSpaceEventHandler, event);
    }
  }
  function ScreenSpaceEventHandler(element) {
    this._inputEvents = {};
    this._buttonDown = undefined;
    this._isPinching = false;
    this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
    this._primaryStartPosition = new Cartesian2();
    this._primaryPosition = new Cartesian2();
    this._primaryPreviousPosition = new Cartesian2();
    this._positions = new AssociativeArray();
    this._previousPositions = new AssociativeArray();
    this._removalFunctions = [];
    this._clickPixelTolerance = 5;
    this._element = defaultValue(element, document);
    registerListeners(this);
  }
  ScreenSpaceEventHandler.prototype.setInputAction = function(action, type, modifier) {
    if (!defined(action)) {
      throw new DeveloperError('action is required.');
    }
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    this._inputEvents[key] = action;
  };
  ScreenSpaceEventHandler.prototype.getInputAction = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    return this._inputEvents[key];
  };
  ScreenSpaceEventHandler.prototype.removeInputAction = function(type, modifier) {
    if (!defined(type)) {
      throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    delete this._inputEvents[key];
  };
  ScreenSpaceEventHandler.prototype.isDestroyed = function() {
    return false;
  };
  ScreenSpaceEventHandler.prototype.destroy = function() {
    unregisterListeners(this);
    return destroyObject(this);
  };
  ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;
  return ScreenSpaceEventHandler;
});

})();
(function() {
var define = $__System.amdDefine;
define("f", ["11"], function(freezeObject) {
  'use strict';
  var ScreenSpaceEventType = {
    LEFT_DOWN: 0,
    LEFT_UP: 1,
    LEFT_CLICK: 2,
    LEFT_DOUBLE_CLICK: 3,
    RIGHT_DOWN: 5,
    RIGHT_UP: 6,
    RIGHT_CLICK: 7,
    MIDDLE_DOWN: 10,
    MIDDLE_UP: 11,
    MIDDLE_CLICK: 12,
    MOUSE_MOVE: 15,
    WHEEL: 16,
    PINCH_START: 17,
    PINCH_END: 18,
    PINCH_MOVE: 19
  };
  return freezeObject(ScreenSpaceEventType);
});

})();
(function() {
var define = $__System.amdDefine;
define("3d", ["1f", "5", "7", "17", "d", "27", "3e", "3f"], function(Cartesian3, defined, DeveloperError, JulianDate, CesiumMath, Matrix3, TimeConstants, TimeStandard) {
  'use strict';
  var Simon1994PlanetaryPositions = {};
  function computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {
    var g = 6.239996 + (0.0172019696544) * daysSinceJ2000InTerrestrialTime;
    return 1.657e-3 * Math.sin(g + 1.671e-2 * Math.sin(g));
  }
  var TdtMinusTai = 32.184;
  var J2000d = 2451545;
  function taiToTdb(date, result) {
    result = JulianDate.addSeconds(date, TdtMinusTai, result);
    var days = JulianDate.totalDays(result) - J2000d;
    result = JulianDate.addSeconds(result, computeTdbMinusTtSpice(days), result);
    return result;
  }
  var epoch = new JulianDate(2451545, 0, TimeStandard.TAI);
  var MetersPerKilometer = 1000.0;
  var RadiansPerDegree = CesiumMath.RADIANS_PER_DEGREE;
  var RadiansPerArcSecond = CesiumMath.RADIANS_PER_ARCSECOND;
  var MetersPerAstronomicalUnit = 1.49597870e+11;
  var perifocalToEquatorial = new Matrix3();
  function elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, result) {
    if (inclination < 0.0) {
      inclination = -inclination;
      longitudeOfNode += CesiumMath.PI;
    }
    if (inclination < 0 || inclination > CesiumMath.PI) {
      throw new DeveloperError('The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.');
    }
    var radiusOfPeriapsis = semimajorAxis * (1.0 - eccentricity);
    var argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;
    var rightAscensionOfAscendingNode = longitudeOfNode;
    var trueAnomaly = meanAnomalyToTrueAnomaly(meanLongitude - longitudeOfPerigee, eccentricity);
    var type = chooseOrbit(eccentricity, 0.0);
    if (type === 'Hyperbolic' && Math.abs(CesiumMath.negativePiToPi(trueAnomaly)) >= Math.acos(-1.0 / eccentricity)) {
      throw new DeveloperError('The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.');
    }
    perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscensionOfAscendingNode, perifocalToEquatorial);
    var semilatus = radiusOfPeriapsis * (1.0 + eccentricity);
    var costheta = Math.cos(trueAnomaly);
    var sintheta = Math.sin(trueAnomaly);
    var denom = (1.0 + eccentricity * costheta);
    if (denom <= CesiumMath.Epsilon10) {
      throw new DeveloperError('elements cannot be converted to cartesian');
    }
    var radius = semilatus / denom;
    if (!defined(result)) {
      result = new Cartesian3(radius * costheta, radius * sintheta, 0.0);
    } else {
      result.x = radius * costheta;
      result.y = radius * sintheta;
      result.z = 0.0;
    }
    return Matrix3.multiplyByVector(perifocalToEquatorial, result, result);
  }
  function chooseOrbit(eccentricity, tolerance) {
    if (eccentricity < 0) {
      throw new DeveloperError('eccentricity cannot be negative.');
    }
    if (eccentricity <= tolerance) {
      return 'Circular';
    } else if (eccentricity < 1.0 - tolerance) {
      return 'Elliptical';
    } else if (eccentricity <= 1.0 + tolerance) {
      return 'Parabolic';
    } else {
      return 'Hyperbolic';
    }
  }
  function meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {
    if (eccentricity < 0.0 || eccentricity >= 1.0) {
      throw new DeveloperError('eccentricity out of range.');
    }
    var eccentricAnomaly = meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity);
    return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);
  }
  var maxIterationCount = 50;
  var keplerEqConvergence = CesiumMath.EPSILON8;
  function meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {
    if (eccentricity < 0.0 || eccentricity >= 1.0) {
      throw new DeveloperError('eccentricity out of range.');
    }
    var revs = Math.floor(meanAnomaly / CesiumMath.TWO_PI);
    meanAnomaly -= revs * CesiumMath.TWO_PI;
    var iterationValue = meanAnomaly + (eccentricity * Math.sin(meanAnomaly)) / (1.0 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));
    var eccentricAnomaly = Number.MAX_VALUE;
    var count;
    for (count = 0; count < maxIterationCount && Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence; ++count) {
      eccentricAnomaly = iterationValue;
      var NRfunction = eccentricAnomaly - eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;
      var dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);
      iterationValue = eccentricAnomaly - NRfunction / dNRfunction;
    }
    if (count >= maxIterationCount) {
      throw new DeveloperError('Kepler equation did not converge');
    }
    eccentricAnomaly = iterationValue + revs * CesiumMath.TWO_PI;
    return eccentricAnomaly;
  }
  function eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {
    if (eccentricity < 0.0 || eccentricity >= 1.0) {
      throw new DeveloperError('eccentricity out of range.');
    }
    var revs = Math.floor(eccentricAnomaly / CesiumMath.TWO_PI);
    eccentricAnomaly -= revs * CesiumMath.TWO_PI;
    var trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;
    var trueAnomalyY = Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);
    var trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);
    trueAnomaly = CesiumMath.zeroToTwoPi(trueAnomaly);
    if (eccentricAnomaly < 0) {
      trueAnomaly -= CesiumMath.TWO_PI;
    }
    trueAnomaly += revs * CesiumMath.TWO_PI;
    return trueAnomaly;
  }
  function perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscension, result) {
    if (inclination < 0 || inclination > CesiumMath.PI) {
      throw new DeveloperError('inclination out of range');
    }
    var cosap = Math.cos(argumentOfPeriapsis);
    var sinap = Math.sin(argumentOfPeriapsis);
    var cosi = Math.cos(inclination);
    var sini = Math.sin(inclination);
    var cosraan = Math.cos(rightAscension);
    var sinraan = Math.sin(rightAscension);
    if (!defined(result)) {
      result = new Matrix3(cosraan * cosap - sinraan * sinap * cosi, -cosraan * sinap - sinraan * cosap * cosi, sinraan * sini, sinraan * cosap + cosraan * sinap * cosi, -sinraan * sinap + cosraan * cosap * cosi, -cosraan * sini, sinap * sini, cosap * sini, cosi);
    } else {
      result[0] = cosraan * cosap - sinraan * sinap * cosi;
      result[1] = sinraan * cosap + cosraan * sinap * cosi;
      result[2] = sinap * sini;
      result[3] = -cosraan * sinap - sinraan * cosap * cosi;
      result[4] = -sinraan * sinap + cosraan * cosap * cosi;
      result[5] = cosap * sini;
      result[6] = sinraan * sini;
      result[7] = -cosraan * sini;
      result[8] = cosi;
    }
    return result;
  }
  var semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;
  var meanLongitude0 = 100.46645683 * RadiansPerDegree;
  var meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;
  var p1u = 16002;
  var p2u = 21863;
  var p3u = 32004;
  var p4u = 10931;
  var p5u = 14529;
  var p6u = 16368;
  var p7u = 15318;
  var p8u = 32794;
  var Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;
  var Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;
  var Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;
  var q1u = 10;
  var q2u = 16002;
  var q3u = 21863;
  var q4u = 10931;
  var q5u = 1473;
  var q6u = 32004;
  var q7u = 4387;
  var q8u = 73;
  var Cl1 = -325 * 1e-7;
  var Cl2 = -322 * 1e-7;
  var Cl3 = -79 * 1e-7;
  var Cl4 = 232 * 1e-7;
  var Cl5 = -52 * 1e-7;
  var Cl6 = 97 * 1e-7;
  var Cl7 = 55 * 1e-7;
  var Cl8 = -41 * 1e-7;
  var Sl1 = -105 * 1e-7;
  var Sl2 = -137 * 1e-7;
  var Sl3 = 258 * 1e-7;
  var Sl4 = 35 * 1e-7;
  var Sl5 = -116 * 1e-7;
  var Sl6 = -88 * 1e-7;
  var Sl7 = -112 * 1e-7;
  var Sl8 = -80 * 1e-7;
  var scratchDate = new JulianDate(0, 0.0, TimeStandard.TAI);
  function computeSimonEarthMoonBarycenter(date, result) {
    taiToTdb(date, scratchDate);
    var x = (scratchDate.dayNumber - epoch.dayNumber) + ((scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY);
    var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY * 10.0);
    var u = 0.35953620 * t;
    var semimajorAxis = semiMajorAxis0 + Ca1 * Math.cos(p1u * u) + Sa1 * Math.sin(p1u * u) + Ca2 * Math.cos(p2u * u) + Sa2 * Math.sin(p2u * u) + Ca3 * Math.cos(p3u * u) + Sa3 * Math.sin(p3u * u) + Ca4 * Math.cos(p4u * u) + Sa4 * Math.sin(p4u * u) + Ca5 * Math.cos(p5u * u) + Sa5 * Math.sin(p5u * u) + Ca6 * Math.cos(p6u * u) + Sa6 * Math.sin(p6u * u) + Ca7 * Math.cos(p7u * u) + Sa7 * Math.sin(p7u * u) + Ca8 * Math.cos(p8u * u) + Sa8 * Math.sin(p8u * u);
    var meanLongitude = meanLongitude0 + meanLongitude1 * t + Cl1 * Math.cos(q1u * u) + Sl1 * Math.sin(q1u * u) + Cl2 * Math.cos(q2u * u) + Sl2 * Math.sin(q2u * u) + Cl3 * Math.cos(q3u * u) + Sl3 * Math.sin(q3u * u) + Cl4 * Math.cos(q4u * u) + Sl4 * Math.sin(q4u * u) + Cl5 * Math.cos(q5u * u) + Sl5 * Math.sin(q5u * u) + Cl6 * Math.cos(q6u * u) + Sl6 * Math.sin(q6u * u) + Cl7 * Math.cos(q7u * u) + Sl7 * Math.sin(q7u * u) + Cl8 * Math.cos(q8u * u) + Sl8 * Math.sin(q8u * u);
    var eccentricity = 0.0167086342 - 0.0004203654 * t;
    var longitudeOfPerigee = 102.93734808 * RadiansPerDegree + 11612.35290 * RadiansPerArcSecond * t;
    var inclination = 469.97289 * RadiansPerArcSecond * t;
    var longitudeOfNode = 174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;
    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, result);
  }
  function computeSimonMoon(date, result) {
    taiToTdb(date, scratchDate);
    var x = (scratchDate.dayNumber - epoch.dayNumber) + ((scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY);
    var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY);
    var t2 = t * t;
    var t3 = t2 * t;
    var t4 = t3 * t;
    var semimajorAxis = 383397.7725 + 0.0040 * t;
    var eccentricity = 0.055545526 - 0.000000016 * t;
    var inclinationConstant = 5.15668983 * RadiansPerDegree;
    var inclinationSecPart = -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 0.00000013 * t4;
    var longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;
    var longitudeOfPerigeeSecPart = 14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;
    var longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;
    var longitudeOfNodeSecPart = -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;
    var meanLongitudeConstant = 218.31664563 * RadiansPerDegree;
    var meanLongitudeSecPart = 1732559343.48470 * t - 6.3910 * t2 + 0.006588 * t3 - 0.00003169 * t4;
    var D = 297.85019547 * RadiansPerDegree + RadiansPerArcSecond * (1602961601.2090 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);
    var F = 93.27209062 * RadiansPerDegree + RadiansPerArcSecond * (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);
    var l = 134.96340251 * RadiansPerDegree + RadiansPerArcSecond * (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.00024470 * t4);
    var lprime = 357.52910918 * RadiansPerDegree + RadiansPerArcSecond * (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);
    var psi = 310.17137918 * RadiansPerDegree - RadiansPerArcSecond * (6967051.4360 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);
    var twoD = 2.0 * D;
    var fourD = 4.0 * D;
    var sixD = 6.0 * D;
    var twol = 2.0 * l;
    var threel = 3.0 * l;
    var fourl = 4.0 * l;
    var twoF = 2.0 * F;
    semimajorAxis += 3400.4 * Math.cos(twoD) - 635.6 * Math.cos(twoD - l) - 235.6 * Math.cos(l) + 218.1 * Math.cos(twoD - lprime) + 181.0 * Math.cos(twoD + l);
    eccentricity += 0.014216 * Math.cos(twoD - l) + 0.008551 * Math.cos(twoD - twol) - 0.001383 * Math.cos(l) + 0.001356 * Math.cos(twoD + l) - 0.001147 * Math.cos(fourD - threel) - 0.000914 * Math.cos(fourD - twol) + 0.000869 * Math.cos(twoD - lprime - l) - 0.000627 * Math.cos(twoD) - 0.000394 * Math.cos(fourD - fourl) + 0.000282 * Math.cos(twoD - lprime - twol) - 0.000279 * Math.cos(D - l) - 0.000236 * Math.cos(twol) + 0.000231 * Math.cos(fourD) + 0.000229 * Math.cos(sixD - fourl) - 0.000201 * Math.cos(twol - twoF);
    inclinationSecPart += 486.26 * Math.cos(twoD - twoF) - 40.13 * Math.cos(twoD) + 37.51 * Math.cos(twoF) + 25.73 * Math.cos(twol - twoF) + 19.97 * Math.cos(twoD - lprime - twoF);
    longitudeOfPerigeeSecPart += -55609 * Math.sin(twoD - l) - 34711 * Math.sin(twoD - twol) - 9792 * Math.sin(l) + 9385 * Math.sin(fourD - threel) + 7505 * Math.sin(fourD - twol) + 5318 * Math.sin(twoD + l) + 3484 * Math.sin(fourD - fourl) - 3417 * Math.sin(twoD - lprime - l) - 2530 * Math.sin(sixD - fourl) - 2376 * Math.sin(twoD) - 2075 * Math.sin(twoD - threel) - 1883 * Math.sin(twol) - 1736 * Math.sin(sixD - 5.0 * l) + 1626 * Math.sin(lprime) - 1370 * Math.sin(sixD - threel);
    longitudeOfNodeSecPart += -5392 * Math.sin(twoD - twoF) - 540 * Math.sin(lprime) - 441 * Math.sin(twoD) + 423 * Math.sin(twoF) - 288 * Math.sin(twol - twoF);
    meanLongitudeSecPart += -3332.9 * Math.sin(twoD) + 1197.4 * Math.sin(twoD - l) - 662.5 * Math.sin(lprime) + 396.3 * Math.sin(l) - 218.0 * Math.sin(twoD - lprime);
    var twoPsi = 2.0 * psi;
    var threePsi = 3.0 * psi;
    inclinationSecPart += 46.997 * Math.cos(psi) * t - 0.614 * Math.cos(twoD - twoF + psi) * t + 0.614 * Math.cos(twoD - twoF - psi) * t - 0.0297 * Math.cos(twoPsi) * t2 - 0.0335 * Math.cos(psi) * t2 + 0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 - 0.00016 * Math.cos(psi) * t3 + 0.00004 * Math.cos(threePsi) * t3 + 0.00004 * Math.cos(twoPsi) * t3;
    var perigeeAndMean = 2.116 * Math.sin(psi) * t - 0.111 * Math.sin(twoD - twoF - psi) * t - 0.0015 * Math.sin(psi) * t2;
    longitudeOfPerigeeSecPart += perigeeAndMean;
    meanLongitudeSecPart += perigeeAndMean;
    longitudeOfNodeSecPart += -520.77 * Math.sin(psi) * t + 13.66 * Math.sin(twoD - twoF + psi) * t + 1.12 * Math.sin(twoD - psi) * t - 1.06 * Math.sin(twoF - psi) * t + 0.660 * Math.sin(twoPsi) * t2 + 0.371 * Math.sin(psi) * t2 - 0.035 * Math.sin(twoD - twoF + twoPsi) * t2 - 0.015 * Math.sin(twoD - twoF + psi) * t2 + 0.0014 * Math.sin(psi) * t3 - 0.0011 * Math.sin(threePsi) * t3 - 0.0009 * Math.sin(twoPsi) * t3;
    semimajorAxis *= MetersPerKilometer;
    var inclination = inclinationConstant + inclinationSecPart * RadiansPerArcSecond;
    var longitudeOfPerigee = longitudeOfPerigeeConstant + longitudeOfPerigeeSecPart * RadiansPerArcSecond;
    var meanLongitude = meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;
    var longitudeOfNode = longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;
    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, result);
  }
  var moonEarthMassRatio = 0.012300034;
  var factor = moonEarthMassRatio / (moonEarthMassRatio + 1.0) * -1;
  function computeSimonEarth(date, result) {
    result = computeSimonMoon(date, result);
    return Cartesian3.multiplyByScalar(result, factor, result);
  }
  var axesTransformation = new Matrix3(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, 0.9174820620691819, -0.39777715593191376, -2.23970096136568e-16, 0.39777715593191376, 0.9174820620691819);
  var translation = new Cartesian3();
  Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function(julianDate, result) {
    if (!defined(julianDate)) {
      julianDate = JulianDate.now();
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    translation = computeSimonEarthMoonBarycenter(julianDate, translation);
    result = Cartesian3.negate(translation, result);
    computeSimonEarth(julianDate, translation);
    Cartesian3.subtract(result, translation, result);
    Matrix3.multiplyByVector(axesTransformation, result, result);
    return result;
  };
  Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function(julianDate, result) {
    if (!defined(julianDate)) {
      julianDate = JulianDate.now();
    }
    result = computeSimonMoon(julianDate, result);
    Matrix3.multiplyByVector(axesTransformation, result, result);
    return result;
  };
  return Simon1994PlanetaryPositions;
});

})();
(function() {
var define = $__System.amdDefine;
define("40", ["1f", "41", "15", "5", "6", "7", "42", "d"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, CesiumMath) {
  'use strict';
  function setConstants(ellipsoidGeodesic) {
    var uSquared = ellipsoidGeodesic._uSquared;
    var a = ellipsoidGeodesic._ellipsoid.maximumRadius;
    var b = ellipsoidGeodesic._ellipsoid.minimumRadius;
    var f = (a - b) / a;
    var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);
    var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);
    var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);
    var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);
    var sineU = cosineU * tanU;
    var sigma = Math.atan2(tanU, cosineHeading);
    var sineAlpha = cosineU * sineHeading;
    var sineSquaredAlpha = sineAlpha * sineAlpha;
    var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;
    var cosineAlpha = Math.sqrt(cosineSquaredAlpha);
    var u2Over4 = uSquared / 4.0;
    var u4Over16 = u2Over4 * u2Over4;
    var u6Over64 = u4Over16 * u2Over4;
    var u8Over256 = u4Over16 * u4Over16;
    var a0 = (1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0);
    var a1 = (1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0);
    var a2 = (1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0);
    var a3 = (1.0 - 5.0 * u2Over4);
    var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 - a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;
    var constants = ellipsoidGeodesic._constants;
    constants.a = a;
    constants.b = b;
    constants.f = f;
    constants.cosineHeading = cosineHeading;
    constants.sineHeading = sineHeading;
    constants.tanU = tanU;
    constants.cosineU = cosineU;
    constants.sineU = sineU;
    constants.sigma = sigma;
    constants.sineAlpha = sineAlpha;
    constants.sineSquaredAlpha = sineSquaredAlpha;
    constants.cosineSquaredAlpha = cosineSquaredAlpha;
    constants.cosineAlpha = cosineAlpha;
    constants.u2Over4 = u2Over4;
    constants.u4Over16 = u4Over16;
    constants.u6Over64 = u6Over64;
    constants.u8Over256 = u8Over256;
    constants.a0 = a0;
    constants.a1 = a1;
    constants.a2 = a2;
    constants.a3 = a3;
    constants.distanceRatio = distanceRatio;
  }
  function computeC(f, cosineSquaredAlpha) {
    return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;
  }
  function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {
    var C = computeC(f, cosineSquaredAlpha);
    return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));
  }
  function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
    var eff = (major - minor) / major;
    var l = secondLongitude - firstLongitude;
    var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));
    var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));
    var cosineU1 = Math.cos(u1);
    var sineU1 = Math.sin(u1);
    var cosineU2 = Math.cos(u2);
    var sineU2 = Math.sin(u2);
    var cc = cosineU1 * cosineU2;
    var cs = cosineU1 * sineU2;
    var ss = sineU1 * sineU2;
    var sc = sineU1 * cosineU2;
    var lambda = l;
    var lambdaDot = CesiumMath.TWO_PI;
    var cosineLambda = Math.cos(lambda);
    var sineLambda = Math.sin(lambda);
    var sigma;
    var cosineSigma;
    var sineSigma;
    var cosineSquaredAlpha;
    var cosineTwiceSigmaMidpoint;
    do {
      cosineLambda = Math.cos(lambda);
      sineLambda = Math.sin(lambda);
      var temp = cs - sc * cosineLambda;
      sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);
      cosineSigma = ss + cc * cosineLambda;
      sigma = Math.atan2(sineSigma, cosineSigma);
      var sineAlpha;
      if (sineSigma === 0.0) {
        sineAlpha = 0.0;
        cosineSquaredAlpha = 1.0;
      } else {
        sineAlpha = cc * sineLambda / sineSigma;
        cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;
      }
      lambdaDot = lambda;
      cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;
      if (isNaN(cosineTwiceSigmaMidpoint)) {
        cosineTwiceSigmaMidpoint = 0.0;
      }
      lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
    } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);
    var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);
    var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;
    var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;
    var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;
    var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint * (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);
    var distance = minor * A * (sigma - deltaSigma);
    var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);
    var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);
    ellipsoidGeodesic._distance = distance;
    ellipsoidGeodesic._startHeading = startHeading;
    ellipsoidGeodesic._endHeading = endHeading;
    ellipsoidGeodesic._uSquared = uSquared;
  }
  function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {
    var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);
    var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);
    if (Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI) < 0.0125) {
      throw new DeveloperError('geodesic position is not unique');
    }
    vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);
    ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);
    ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);
    ellipsoidGeodesic._start.height = 0;
    ellipsoidGeodesic._end.height = 0;
    setConstants(ellipsoidGeodesic);
  }
  var scratchCart1 = new Cartesian3();
  var scratchCart2 = new Cartesian3();
  function EllipsoidGeodesic(start, end, ellipsoid) {
    var e = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._ellipsoid = e;
    this._start = new Cartographic();
    this._end = new Cartographic();
    this._constants = {};
    this._startHeading = undefined;
    this._endHeading = undefined;
    this._distance = undefined;
    this._uSquared = undefined;
    if (defined(start) && defined(end)) {
      computeProperties(this, start, end, e);
    }
  }
  defineProperties(EllipsoidGeodesic.prototype, {
    ellipsoid: {get: function() {
        return this._ellipsoid;
      }},
    surfaceDistance: {get: function() {
        if (!defined(this._distance)) {
          throw new DeveloperError('set end positions before getting surfaceDistance');
        }
        return this._distance;
      }},
    start: {get: function() {
        return this._start;
      }},
    end: {get: function() {
        return this._end;
      }},
    startHeading: {get: function() {
        if (!defined(this._distance)) {
          throw new DeveloperError('set end positions before getting startHeading');
        }
        return this._startHeading;
      }},
    endHeading: {get: function() {
        if (!defined(this._distance)) {
          throw new DeveloperError('set end positions before getting endHeading');
        }
        return this._endHeading;
      }}
  });
  EllipsoidGeodesic.prototype.setEndPoints = function(start, end) {
    if (!defined(start)) {
      throw new DeveloperError('start cartographic position is required');
    }
    if (!defined(end)) {
      throw new DeveloperError('end cartgraphic position is required');
    }
    computeProperties(this, start, end, this._ellipsoid);
  };
  EllipsoidGeodesic.prototype.interpolateUsingFraction = function(fraction, result) {
    return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);
  };
  EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(distance, result) {
    if (!defined(this._distance)) {
      throw new DeveloperError('start and end must be set before calling function interpolateUsingSurfaceDistance');
    }
    var constants = this._constants;
    var s = constants.distanceRatio + distance / constants.b;
    var cosine2S = Math.cos(2.0 * s);
    var cosine4S = Math.cos(4.0 * s);
    var cosine6S = Math.cos(6.0 * s);
    var sine2S = Math.sin(2.0 * s);
    var sine4S = Math.sin(4.0 * s);
    var sine6S = Math.sin(6.0 * s);
    var sine8S = Math.sin(8.0 * s);
    var s2 = s * s;
    var s3 = s * s2;
    var u8Over256 = constants.u8Over256;
    var u2Over4 = constants.u2Over4;
    var u6Over64 = constants.u6Over64;
    var u4Over16 = constants.u4Over16;
    var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 + s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 - (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S - (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S - 29.0 * u8Over256 * cosine6S / 16.0) + (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S + (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S - s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) + (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S + 539.0 * u8Over256 * sine8S / 1536.0;
    var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);
    var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));
    sigma = sigma - constants.sigma;
    var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);
    var sineSigma = Math.sin(sigma);
    var cosineSigma = Math.cos(sigma);
    var cc = constants.cosineU * cosineSigma;
    var ss = constants.sineU * sineSigma;
    var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);
    var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
    if (defined(result)) {
      result.longitude = this._start.longitude + l;
      result.latitude = latitude;
      result.height = 0.0;
      return result;
    }
    return new Cartographic(this._start.longitude + l, latitude, 0.0);
  };
  return EllipsoidGeodesic;
});

})();
(function() {
var define = $__System.amdDefine;
define("43", ["5"], function(defined) {
  'use strict';
  var isArray = Array.isArray;
  if (!defined(isArray)) {
    isArray = function(value) {
      return Object.prototype.toString.call(value) === '[object Array]';
    };
  }
  return isArray;
});

})();
(function() {
var define = $__System.amdDefine;
define("44", ["1f", "41", "15", "5", "7", "42", "40", "45", "43", "d", "28", "34"], function(Cartesian3, Cartographic, defaultValue, defined, DeveloperError, Ellipsoid, EllipsoidGeodesic, IntersectionTests, isArray, CesiumMath, Matrix4, Plane) {
  'use strict';
  var PolylinePipeline = {};
  PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {
    var distance = Cartesian3.distance(p0, p1);
    return Math.ceil(distance / minDistance);
  };
  var cartoScratch = new Cartographic();
  PolylinePipeline.extractHeights = function(positions, ellipsoid) {
    var length = positions.length;
    var heights = new Array(length);
    for (var i = 0; i < length; i++) {
      var p = positions[i];
      heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;
    }
    return heights;
  };
  var wrapLongitudeInversMatrix = new Matrix4();
  var wrapLongitudeOrigin = new Cartesian3();
  var wrapLongitudeXZNormal = new Cartesian3();
  var wrapLongitudeXZPlane = new Plane(Cartesian3.ZERO, 0.0);
  var wrapLongitudeYZNormal = new Cartesian3();
  var wrapLongitudeYZPlane = new Plane(Cartesian3.ZERO, 0.0);
  var wrapLongitudeIntersection = new Cartesian3();
  var wrapLongitudeOffset = new Cartesian3();
  var subdivideHeightsScratchArray = [];
  function subdivideHeights(numPoints, h0, h1) {
    var heights = subdivideHeightsScratchArray;
    heights.length = numPoints;
    var i;
    if (h0 === h1) {
      for (i = 0; i < numPoints; i++) {
        heights[i] = h0;
      }
      return heights;
    }
    var dHeight = h1 - h0;
    var heightPerVertex = dHeight / numPoints;
    for (i = 0; i < numPoints; i++) {
      var h = h0 + i * heightPerVertex;
      heights[i] = h;
    }
    return heights;
  }
  var carto1 = new Cartographic();
  var carto2 = new Cartographic();
  var cartesian = new Cartesian3();
  var scaleFirst = new Cartesian3();
  var scaleLast = new Cartesian3();
  var ellipsoidGeodesic = new EllipsoidGeodesic();
  function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {
    var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);
    var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);
    var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
    var start = ellipsoid.cartesianToCartographic(first, carto1);
    var end = ellipsoid.cartesianToCartographic(last, carto2);
    var heights = subdivideHeights(numPoints, h0, h1);
    ellipsoidGeodesic.setEndPoints(start, end);
    var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;
    var index = offset;
    start.height = h0;
    var cart = ellipsoid.cartographicToCartesian(start, cartesian);
    Cartesian3.pack(cart, array, index);
    index += 3;
    for (var i = 1; i < numPoints; i++) {
      var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);
      carto.height = heights[i];
      cart = ellipsoid.cartographicToCartesian(carto, cartesian);
      Cartesian3.pack(cart, array, index);
      index += 3;
    }
    return index;
  }
  PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {
    var cartesians = [];
    var segments = [];
    if (defined(positions) && positions.length > 0) {
      modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);
      var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);
      var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);
      var xzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal);
      var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);
      var yzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal);
      var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);
      var count = 1;
      cartesians.push(Cartesian3.clone(positions[0]));
      var prev = cartesians[0];
      var length = positions.length;
      for (var i = 1; i < length; ++i) {
        var cur = positions[i];
        if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {
          var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);
          if (defined(intersection)) {
            var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);
            if (Plane.getPointDistance(xzPlane, prev) < 0.0) {
              Cartesian3.negate(offset, offset);
            }
            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
            segments.push(count + 1);
            Cartesian3.negate(offset, offset);
            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
            count = 1;
          }
        }
        cartesians.push(Cartesian3.clone(positions[i]));
        count++;
        prev = cur;
      }
      segments.push(count);
    }
    return {
      positions: cartesians,
      lengths: segments
    };
  };
  PolylinePipeline.generateArc = function(options) {
    if (!defined(options)) {
      options = {};
    }
    var positions = options.positions;
    if (!defined(positions)) {
      throw new DeveloperError('options.positions is required.');
    }
    var length = positions.length;
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var height = defaultValue(options.height, 0);
    var hasHeightArray = isArray(height);
    if (length < 1) {
      return [];
    } else if (length === 1) {
      var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);
      height = hasHeightArray ? height[0] : height;
      if (height !== 0) {
        var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);
        Cartesian3.multiplyByScalar(n, height, n);
        Cartesian3.add(p, n, p);
      }
      return [p.x, p.y, p.z];
    }
    var minDistance = options.minDistance;
    if (!defined(minDistance)) {
      var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
      minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    }
    var numPoints = 0;
    var i;
    for (i = 0; i < length - 1; i++) {
      numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);
    }
    var arrayLength = (numPoints + 1) * 3;
    var newPositions = new Array(arrayLength);
    var offset = 0;
    for (i = 0; i < length - 1; i++) {
      var p0 = positions[i];
      var p1 = positions[i + 1];
      var h0 = hasHeightArray ? height[i] : height;
      var h1 = hasHeightArray ? height[i + 1] : height;
      offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);
    }
    subdivideHeightsScratchArray.length = 0;
    var lastPoint = positions[length - 1];
    var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);
    carto.height = hasHeightArray ? height[length - 1] : height;
    var cart = ellipsoid.cartographicToCartesian(carto, cartesian);
    Cartesian3.pack(cart, newPositions, arrayLength - 3);
    return newPositions;
  };
  PolylinePipeline.generateCartesianArc = function(options) {
    var numberArray = PolylinePipeline.generateArc(options);
    var size = numberArray.length / 3;
    var newPositions = new Array(size);
    for (var i = 0; i < size; i++) {
      newPositions[i] = Cartesian3.unpack(numberArray, i * 3);
    }
    return newPositions;
  };
  return PolylinePipeline;
});

})();
(function() {
var define = $__System.amdDefine;
define("46", ["47", "48", "15"], function(Uri, when, defaultValue) {
  'use strict';
  var activeRequests = {};
  var pageUri = typeof document !== 'undefined' ? new Uri(document.location.href) : new Uri();
  function getServer(url) {
    var uri = new Uri(url).resolve(pageUri);
    uri.normalize();
    var server = uri.authority;
    if (!/:/.test(server)) {
      server = server + ':' + (uri.scheme === 'https' ? '443' : '80');
    }
    return server;
  }
  function throttleRequestByServer(url, requestFunction) {
    var server = getServer(url);
    var activeRequestsForServer = defaultValue(activeRequests[server], 0);
    if (activeRequestsForServer >= throttleRequestByServer.maximumRequestsPerServer) {
      return undefined;
    }
    activeRequests[server] = activeRequestsForServer + 1;
    return when(requestFunction(url), function(result) {
      activeRequests[server]--;
      return result;
    }).otherwise(function(error) {
      activeRequests[server]--;
      return when.reject(error);
    });
  }
  throttleRequestByServer.maximumRequestsPerServer = 6;
  return throttleRequestByServer;
});

})();
(function() {
var define = $__System.amdDefine;
define("49", ["48", "15", "5", "7", "4a", "4b"], function(when, defaultValue, defined, DeveloperError, isCrossOriginUrl, TrustedServers) {
  'use strict';
  var dataUriRegex = /^data:/;
  function loadImage(url, allowCrossOrigin) {
    if (!defined(url)) {
      throw new DeveloperError('url is required.');
    }
    allowCrossOrigin = defaultValue(allowCrossOrigin, true);
    return when(url, function(url) {
      var crossOrigin;
      if (dataUriRegex.test(url) || !allowCrossOrigin) {
        crossOrigin = false;
      } else {
        crossOrigin = isCrossOriginUrl(url);
      }
      var deferred = when.defer();
      loadImage.createImage(url, crossOrigin, deferred);
      return deferred.promise;
    });
  }
  loadImage.createImage = function(url, crossOrigin, deferred) {
    var image = new Image();
    image.onload = function() {
      deferred.resolve(image);
    };
    image.onerror = function(e) {
      deferred.reject(e);
    };
    if (crossOrigin) {
      if (TrustedServers.contains(url)) {
        image.crossOrigin = 'use-credentials';
      } else {
        image.crossOrigin = '';
      }
    }
    image.src = url;
  };
  loadImage.defaultCreateImage = loadImage.createImage;
  return loadImage;
});

})();
(function() {
var define = $__System.amdDefine;
define("4c", ["a", "15", "5", "6", "42", "4d", "4e"], function(Cartesian2, defaultValue, defined, defineProperties, Ellipsoid, Rectangle, WebMercatorProjection) {
  'use strict';
  function WebMercatorTilingScheme(options) {
    options = defaultValue(options, {});
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 1);
    this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);
    this._projection = new WebMercatorProjection(this._ellipsoid);
    if (defined(options.rectangleSouthwestInMeters) && defined(options.rectangleNortheastInMeters)) {
      this._rectangleSouthwestInMeters = options.rectangleSouthwestInMeters;
      this._rectangleNortheastInMeters = options.rectangleNortheastInMeters;
    } else {
      var semimajorAxisTimesPi = this._ellipsoid.maximumRadius * Math.PI;
      this._rectangleSouthwestInMeters = new Cartesian2(-semimajorAxisTimesPi, -semimajorAxisTimesPi);
      this._rectangleNortheastInMeters = new Cartesian2(semimajorAxisTimesPi, semimajorAxisTimesPi);
    }
    var southwest = this._projection.unproject(this._rectangleSouthwestInMeters);
    var northeast = this._projection.unproject(this._rectangleNortheastInMeters);
    this._rectangle = new Rectangle(southwest.longitude, southwest.latitude, northeast.longitude, northeast.latitude);
  }
  defineProperties(WebMercatorTilingScheme.prototype, {
    ellipsoid: {get: function() {
        return this._ellipsoid;
      }},
    rectangle: {get: function() {
        return this._rectangle;
      }},
    projection: {get: function() {
        return this._projection;
      }}
  });
  WebMercatorTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
    return this._numberOfLevelZeroTilesX << level;
  };
  WebMercatorTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
    return this._numberOfLevelZeroTilesY << level;
  };
  WebMercatorTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {
    var projection = this._projection;
    var southwest = projection.project(Rectangle.southwest(rectangle));
    var northeast = projection.project(Rectangle.northeast(rectangle));
    if (!defined(result)) {
      return new Rectangle(southwest.x, southwest.y, northeast.x, northeast.y);
    }
    result.west = southwest.x;
    result.south = southwest.y;
    result.east = northeast.x;
    result.north = northeast.y;
    return result;
  };
  WebMercatorTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / xTiles;
    var west = this._rectangleSouthwestInMeters.x + x * xTileWidth;
    var east = this._rectangleSouthwestInMeters.x + (x + 1) * xTileWidth;
    var yTileHeight = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / yTiles;
    var north = this._rectangleNortheastInMeters.y - y * yTileHeight;
    var south = this._rectangleNortheastInMeters.y - (y + 1) * yTileHeight;
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  WebMercatorTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {
    var nativeRectangle = this.tileXYToNativeRectangle(x, y, level, result);
    var projection = this._projection;
    var southwest = projection.unproject(new Cartesian2(nativeRectangle.west, nativeRectangle.south));
    var northeast = projection.unproject(new Cartesian2(nativeRectangle.east, nativeRectangle.north));
    nativeRectangle.west = southwest.longitude;
    nativeRectangle.south = southwest.latitude;
    nativeRectangle.east = northeast.longitude;
    nativeRectangle.north = northeast.latitude;
    return nativeRectangle;
  };
  WebMercatorTilingScheme.prototype.positionToTileXY = function(position, level, result) {
    var rectangle = this._rectangle;
    if (!Rectangle.contains(rectangle, position)) {
      return undefined;
    }
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var overallWidth = this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x;
    var xTileWidth = overallWidth / xTiles;
    var overallHeight = this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y;
    var yTileHeight = overallHeight / yTiles;
    var projection = this._projection;
    var webMercatorPosition = projection.project(position);
    var distanceFromWest = webMercatorPosition.x - this._rectangleSouthwestInMeters.x;
    var distanceFromNorth = this._rectangleNortheastInMeters.y - webMercatorPosition.y;
    var xTileCoordinate = distanceFromWest / xTileWidth | 0;
    if (xTileCoordinate >= xTiles) {
      xTileCoordinate = xTiles - 1;
    }
    var yTileCoordinate = distanceFromNorth / yTileHeight | 0;
    if (yTileCoordinate >= yTiles) {
      yTileCoordinate = yTiles - 1;
    }
    if (!defined(result)) {
      return new Cartesian2(xTileCoordinate, yTileCoordinate);
    }
    result.x = xTileCoordinate;
    result.y = yTileCoordinate;
    return result;
  };
  return WebMercatorTilingScheme;
});

})();
(function() {
var define = $__System.amdDefine;
define("4f", ["5"], function(defined) {
  'use strict';
  var context2DsByWidthAndHeight = {};
  function getImagePixels(image, width, height) {
    if (!defined(width)) {
      width = image.width;
    }
    if (!defined(height)) {
      height = image.height;
    }
    var context2DsByHeight = context2DsByWidthAndHeight[width];
    if (!defined(context2DsByHeight)) {
      context2DsByHeight = {};
      context2DsByWidthAndHeight[width] = context2DsByHeight;
    }
    var context2d = context2DsByHeight[height];
    if (!defined(context2d)) {
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      context2d = canvas.getContext('2d');
      context2d.globalCompositeOperation = 'copy';
      context2DsByHeight[height] = context2d;
    }
    context2d.drawImage(image, 0, 0, width, height);
    return context2d.getImageData(0, 0, width, height).data;
  }
  return getImagePixels;
});

})();
(function() {
var define = $__System.amdDefine;
define("50", ["a", "15", "5", "6", "7", "42", "51", "d", "4d"], function(Cartesian2, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, GeographicProjection, CesiumMath, Rectangle) {
  'use strict';
  function GeographicTilingScheme(options) {
    options = defaultValue(options, {});
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);
    this._projection = new GeographicProjection(this._ellipsoid);
    this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);
    this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);
  }
  defineProperties(GeographicTilingScheme.prototype, {
    ellipsoid: {get: function() {
        return this._ellipsoid;
      }},
    rectangle: {get: function() {
        return this._rectangle;
      }},
    projection: {get: function() {
        return this._projection;
      }}
  });
  GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {
    return this._numberOfLevelZeroTilesX << level;
  };
  GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {
    return this._numberOfLevelZeroTilesY << level;
  };
  GeographicTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {
    if (!defined(rectangle)) {
      throw new DeveloperError('rectangle is required.');
    }
    var west = CesiumMath.toDegrees(rectangle.west);
    var south = CesiumMath.toDegrees(rectangle.south);
    var east = CesiumMath.toDegrees(rectangle.east);
    var north = CesiumMath.toDegrees(rectangle.north);
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  GeographicTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {
    var rectangleRadians = this.tileXYToRectangle(x, y, level, result);
    rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);
    rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);
    rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);
    rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);
    return rectangleRadians;
  };
  GeographicTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {
    var rectangle = this._rectangle;
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = rectangle.width / xTiles;
    var west = x * xTileWidth + rectangle.west;
    var east = (x + 1) * xTileWidth + rectangle.west;
    var yTileHeight = rectangle.height / yTiles;
    var north = rectangle.north - y * yTileHeight;
    var south = rectangle.north - (y + 1) * yTileHeight;
    if (!defined(result)) {
      result = new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {
    var rectangle = this._rectangle;
    if (!Rectangle.contains(rectangle, position)) {
      return undefined;
    }
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = rectangle.width / xTiles;
    var yTileHeight = rectangle.height / yTiles;
    var longitude = position.longitude;
    if (rectangle.east < rectangle.west) {
      longitude += CesiumMath.TWO_PI;
    }
    var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;
    if (xTileCoordinate >= xTiles) {
      xTileCoordinate = xTiles - 1;
    }
    var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;
    if (yTileCoordinate >= yTiles) {
      yTileCoordinate = yTiles - 1;
    }
    if (!defined(result)) {
      return new Cartesian2(xTileCoordinate, yTileCoordinate);
    }
    result.x = xTileCoordinate;
    result.y = yTileCoordinate;
    return result;
  };
  return GeographicTilingScheme;
});

})();
(function() {
var define = $__System.amdDefine;
define("52", ["53", "1f", "15", "5", "6", "7", "4d"], function(BoundingSphere, Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Rectangle) {
  'use strict';
  function EllipsoidalOccluder(ellipsoid, cameraPosition) {
    if (!defined(ellipsoid)) {
      throw new DeveloperError('ellipsoid is required.');
    }
    this._ellipsoid = ellipsoid;
    this._cameraPosition = new Cartesian3();
    this._cameraPositionInScaledSpace = new Cartesian3();
    this._distanceToLimbInScaledSpaceSquared = 0.0;
    if (defined(cameraPosition)) {
      this.cameraPosition = cameraPosition;
    }
  }
  defineProperties(EllipsoidalOccluder.prototype, {
    ellipsoid: {get: function() {
        return this._ellipsoid;
      }},
    cameraPosition: {
      get: function() {
        return this._cameraPosition;
      },
      set: function(cameraPosition) {
        var ellipsoid = this._ellipsoid;
        var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);
        var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;
        Cartesian3.clone(cameraPosition, this._cameraPosition);
        this._cameraPositionInScaledSpace = cv;
        this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;
      }
    }
  });
  var scratchCartesian = new Cartesian3();
  EllipsoidalOccluder.prototype.isPointVisible = function(occludee) {
    var ellipsoid = this._ellipsoid;
    var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);
    return this.isScaledSpacePointVisible(occludeeScaledSpacePosition);
  };
  EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function(occludeeScaledSpacePosition) {
    var cv = this._cameraPositionInScaledSpace;
    var vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;
    var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);
    var vtDotVc = -Cartesian3.dot(vt, cv);
    var isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : (vtDotVc > vhMagnitudeSquared && vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared);
    return !isOccluded;
  };
  EllipsoidalOccluder.prototype.computeHorizonCullingPoint = function(directionToPoint, positions, result) {
    if (!defined(directionToPoint)) {
      throw new DeveloperError('directionToPoint is required');
    }
    if (!defined(positions)) {
      throw new DeveloperError('positions is required');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    var ellipsoid = this._ellipsoid;
    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);
    var resultMagnitude = 0.0;
    for (var i = 0,
        len = positions.length; i < len; ++i) {
      var position = positions[i];
      var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);
      resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);
    }
    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);
  };
  var positionScratch = new Cartesian3();
  EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function(directionToPoint, vertices, stride, center, result) {
    if (!defined(directionToPoint)) {
      throw new DeveloperError('directionToPoint is required');
    }
    if (!defined(vertices)) {
      throw new DeveloperError('vertices is required');
    }
    if (!defined(stride)) {
      throw new DeveloperError('stride is required');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    center = defaultValue(center, Cartesian3.ZERO);
    var ellipsoid = this._ellipsoid;
    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);
    var resultMagnitude = 0.0;
    for (var i = 0,
        len = vertices.length; i < len; i += stride) {
      positionScratch.x = vertices[i] + center.x;
      positionScratch.y = vertices[i + 1] + center.y;
      positionScratch.z = vertices[i + 2] + center.z;
      var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);
      resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);
    }
    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);
  };
  var subsampleScratch = [];
  EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function(rectangle, ellipsoid, result) {
    if (!defined(rectangle)) {
      throw new DeveloperError('rectangle is required.');
    }
    var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);
    var bs = BoundingSphere.fromPoints(positions);
    if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {
      return undefined;
    }
    return this.computeHorizonCullingPoint(bs.center, positions, result);
  };
  var scaledSpaceScratch = new Cartesian3();
  var directionScratch = new Cartesian3();
  function computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {
    var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);
    var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);
    var magnitude = Math.sqrt(magnitudeSquared);
    var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);
    magnitudeSquared = Math.max(1.0, magnitudeSquared);
    magnitude = Math.max(1.0, magnitude);
    var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);
    var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));
    var cosBeta = 1.0 / magnitude;
    var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;
    return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);
  }
  function magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {
    if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {
      return undefined;
    }
    return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);
  }
  var directionToPointScratch = new Cartesian3();
  function computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {
    if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {
      return directionToPoint;
    }
    ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);
    return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);
  }
  return EllipsoidalOccluder;
});

})();
(function() {
var define = $__System.amdDefine;
define("51", ["1f", "41", "15", "5", "6", "7", "42"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid) {
  'use strict';
  function GeographicProjection(ellipsoid) {
    this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._semimajorAxis = this._ellipsoid.maximumRadius;
    this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
  }
  defineProperties(GeographicProjection.prototype, {ellipsoid: {get: function() {
        return this._ellipsoid;
      }}});
  GeographicProjection.prototype.project = function(cartographic, result) {
    var semimajorAxis = this._semimajorAxis;
    var x = cartographic.longitude * semimajorAxis;
    var y = cartographic.latitude * semimajorAxis;
    var z = cartographic.height;
    if (!defined(result)) {
      return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  GeographicProjection.prototype.unproject = function(cartesian, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required');
    }
    var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
    var longitude = cartesian.x * oneOverEarthSemimajorAxis;
    var latitude = cartesian.y * oneOverEarthSemimajorAxis;
    var height = cartesian.z;
    if (!defined(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };
  return GeographicProjection;
});

})();
(function() {
var define = $__System.amdDefine;
define("53", ["1f", "41", "54", "15", "5", "42", "51", "33", "55", "27", "28", "4d"], function(Cartesian3, Cartographic, Check, defaultValue, defined, Ellipsoid, GeographicProjection, Intersect, Interval, Matrix3, Matrix4, Rectangle) {
  'use strict';
  function BoundingSphere(center, radius) {
    this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));
    this.radius = defaultValue(radius, 0.0);
  }
  var fromPointsXMin = new Cartesian3();
  var fromPointsYMin = new Cartesian3();
  var fromPointsZMin = new Cartesian3();
  var fromPointsXMax = new Cartesian3();
  var fromPointsYMax = new Cartesian3();
  var fromPointsZMax = new Cartesian3();
  var fromPointsCurrentPos = new Cartesian3();
  var fromPointsScratch = new Cartesian3();
  var fromPointsRitterCenter = new Cartesian3();
  var fromPointsMinBoxPt = new Cartesian3();
  var fromPointsMaxBoxPt = new Cartesian3();
  var fromPointsNaiveCenterScratch = new Cartesian3();
  BoundingSphere.fromPoints = function(positions, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    if (!defined(positions) || positions.length === 0) {
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      result.radius = 0.0;
      return result;
    }
    var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);
    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);
    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);
    var numPositions = positions.length;
    for (var i = 1; i < numPositions; i++) {
      Cartesian3.clone(positions[i], currentPos);
      var x = currentPos.x;
      var y = currentPos.y;
      var z = currentPos.z;
      if (x < xMin.x) {
        Cartesian3.clone(currentPos, xMin);
      }
      if (x > xMax.x) {
        Cartesian3.clone(currentPos, xMax);
      }
      if (y < yMin.y) {
        Cartesian3.clone(currentPos, yMin);
      }
      if (y > yMax.y) {
        Cartesian3.clone(currentPos, yMax);
      }
      if (z < zMin.z) {
        Cartesian3.clone(currentPos, zMin);
      }
      if (z > zMax.z) {
        Cartesian3.clone(currentPos, zMax);
      }
    }
    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));
    var diameter1 = xMin;
    var diameter2 = xMax;
    var maxSpan = xSpan;
    if (ySpan > maxSpan) {
      maxSpan = ySpan;
      diameter1 = yMin;
      diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
      maxSpan = zSpan;
      diameter1 = zMin;
      diameter2 = zMax;
    }
    var ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
    var ritterRadius = Math.sqrt(radiusSquared);
    var minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    var maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);
    var naiveRadius = 0;
    for (i = 0; i < numPositions; i++) {
      Cartesian3.clone(positions[i], currentPos);
      var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
      if (r > naiveRadius) {
        naiveRadius = r;
      }
      var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
      if (oldCenterToPointSquared > radiusSquared) {
        var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
        ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
        radiusSquared = ritterRadius * ritterRadius;
        var oldToNew = oldCenterToPoint - ritterRadius;
        ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
        ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
        ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
      }
    }
    if (ritterRadius < naiveRadius) {
      Cartesian3.clone(ritterCenter, result.center);
      result.radius = ritterRadius;
    } else {
      Cartesian3.clone(naiveCenter, result.center);
      result.radius = naiveRadius;
    }
    return result;
  };
  var defaultProjection = new GeographicProjection();
  var fromRectangle2DLowerLeft = new Cartesian3();
  var fromRectangle2DUpperRight = new Cartesian3();
  var fromRectangle2DSouthwest = new Cartographic();
  var fromRectangle2DNortheast = new Cartographic();
  BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {
    return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);
  };
  BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    if (!defined(rectangle)) {
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      result.radius = 0.0;
      return result;
    }
    projection = defaultValue(projection, defaultProjection);
    Rectangle.southwest(rectangle, fromRectangle2DSouthwest);
    fromRectangle2DSouthwest.height = minimumHeight;
    Rectangle.northeast(rectangle, fromRectangle2DNortheast);
    fromRectangle2DNortheast.height = maximumHeight;
    var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);
    var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);
    var width = upperRight.x - lowerLeft.x;
    var height = upperRight.y - lowerLeft.y;
    var elevation = upperRight.z - lowerLeft.z;
    result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;
    var center = result.center;
    center.x = lowerLeft.x + width * 0.5;
    center.y = lowerLeft.y + height * 0.5;
    center.z = lowerLeft.z + elevation * 0.5;
    return result;
  };
  var fromRectangle3DScratch = [];
  BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    surfaceHeight = defaultValue(surfaceHeight, 0.0);
    var positions;
    if (defined(rectangle)) {
      positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);
    }
    return BoundingSphere.fromPoints(positions, result);
  };
  BoundingSphere.fromVertices = function(positions, center, stride, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    if (!defined(positions) || positions.length === 0) {
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      result.radius = 0.0;
      return result;
    }
    center = defaultValue(center, Cartesian3.ZERO);
    stride = defaultValue(stride, 3);
    Check.typeOf.number.greaterThanOrEquals('stride', stride, 3);
    var currentPos = fromPointsCurrentPos;
    currentPos.x = positions[0] + center.x;
    currentPos.y = positions[1] + center.y;
    currentPos.z = positions[2] + center.z;
    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);
    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);
    var numElements = positions.length;
    for (var i = 0; i < numElements; i += stride) {
      var x = positions[i] + center.x;
      var y = positions[i + 1] + center.y;
      var z = positions[i + 2] + center.z;
      currentPos.x = x;
      currentPos.y = y;
      currentPos.z = z;
      if (x < xMin.x) {
        Cartesian3.clone(currentPos, xMin);
      }
      if (x > xMax.x) {
        Cartesian3.clone(currentPos, xMax);
      }
      if (y < yMin.y) {
        Cartesian3.clone(currentPos, yMin);
      }
      if (y > yMax.y) {
        Cartesian3.clone(currentPos, yMax);
      }
      if (z < zMin.z) {
        Cartesian3.clone(currentPos, zMin);
      }
      if (z > zMax.z) {
        Cartesian3.clone(currentPos, zMax);
      }
    }
    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));
    var diameter1 = xMin;
    var diameter2 = xMax;
    var maxSpan = xSpan;
    if (ySpan > maxSpan) {
      maxSpan = ySpan;
      diameter1 = yMin;
      diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
      maxSpan = zSpan;
      diameter1 = zMin;
      diameter2 = zMax;
    }
    var ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
    var ritterRadius = Math.sqrt(radiusSquared);
    var minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    var maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);
    var naiveRadius = 0;
    for (i = 0; i < numElements; i += stride) {
      currentPos.x = positions[i] + center.x;
      currentPos.y = positions[i + 1] + center.y;
      currentPos.z = positions[i + 2] + center.z;
      var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
      if (r > naiveRadius) {
        naiveRadius = r;
      }
      var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
      if (oldCenterToPointSquared > radiusSquared) {
        var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
        ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
        radiusSquared = ritterRadius * ritterRadius;
        var oldToNew = oldCenterToPoint - ritterRadius;
        ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
        ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
        ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
      }
    }
    if (ritterRadius < naiveRadius) {
      Cartesian3.clone(ritterCenter, result.center);
      result.radius = ritterRadius;
    } else {
      Cartesian3.clone(naiveCenter, result.center);
      result.radius = naiveRadius;
    }
    return result;
  };
  BoundingSphere.fromEncodedCartesianVertices = function(positionsHigh, positionsLow, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    if (!defined(positionsHigh) || !defined(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      result.radius = 0.0;
      return result;
    }
    var currentPos = fromPointsCurrentPos;
    currentPos.x = positionsHigh[0] + positionsLow[0];
    currentPos.y = positionsHigh[1] + positionsLow[1];
    currentPos.z = positionsHigh[2] + positionsLow[2];
    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);
    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);
    var numElements = positionsHigh.length;
    for (var i = 0; i < numElements; i += 3) {
      var x = positionsHigh[i] + positionsLow[i];
      var y = positionsHigh[i + 1] + positionsLow[i + 1];
      var z = positionsHigh[i + 2] + positionsLow[i + 2];
      currentPos.x = x;
      currentPos.y = y;
      currentPos.z = z;
      if (x < xMin.x) {
        Cartesian3.clone(currentPos, xMin);
      }
      if (x > xMax.x) {
        Cartesian3.clone(currentPos, xMax);
      }
      if (y < yMin.y) {
        Cartesian3.clone(currentPos, yMin);
      }
      if (y > yMax.y) {
        Cartesian3.clone(currentPos, yMax);
      }
      if (z < zMin.z) {
        Cartesian3.clone(currentPos, zMin);
      }
      if (z > zMax.z) {
        Cartesian3.clone(currentPos, zMax);
      }
    }
    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));
    var diameter1 = xMin;
    var diameter2 = xMax;
    var maxSpan = xSpan;
    if (ySpan > maxSpan) {
      maxSpan = ySpan;
      diameter1 = yMin;
      diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
      maxSpan = zSpan;
      diameter1 = zMin;
      diameter2 = zMax;
    }
    var ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
    var ritterRadius = Math.sqrt(radiusSquared);
    var minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    var maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);
    var naiveRadius = 0;
    for (i = 0; i < numElements; i += 3) {
      currentPos.x = positionsHigh[i] + positionsLow[i];
      currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];
      currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];
      var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
      if (r > naiveRadius) {
        naiveRadius = r;
      }
      var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
      if (oldCenterToPointSquared > radiusSquared) {
        var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
        ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
        radiusSquared = ritterRadius * ritterRadius;
        var oldToNew = oldCenterToPoint - ritterRadius;
        ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
        ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
        ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
      }
    }
    if (ritterRadius < naiveRadius) {
      Cartesian3.clone(ritterCenter, result.center);
      result.radius = ritterRadius;
    } else {
      Cartesian3.clone(naiveCenter, result.center);
      result.radius = naiveRadius;
    }
    return result;
  };
  BoundingSphere.fromCornerPoints = function(corner, oppositeCorner, result) {
    Check.typeOf.object('corner', corner);
    Check.typeOf.object('oppositeCorner', oppositeCorner);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    var center = result.center;
    Cartesian3.add(corner, oppositeCorner, center);
    Cartesian3.multiplyByScalar(center, 0.5, center);
    result.radius = Cartesian3.distance(center, oppositeCorner);
    return result;
  };
  BoundingSphere.fromEllipsoid = function(ellipsoid, result) {
    Check.typeOf.object('ellipsoid', ellipsoid);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    Cartesian3.clone(Cartesian3.ZERO, result.center);
    result.radius = ellipsoid.maximumRadius;
    return result;
  };
  var fromBoundingSpheresScratch = new Cartesian3();
  BoundingSphere.fromBoundingSpheres = function(boundingSpheres, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    if (!defined(boundingSpheres) || boundingSpheres.length === 0) {
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      result.radius = 0.0;
      return result;
    }
    var length = boundingSpheres.length;
    if (length === 1) {
      return BoundingSphere.clone(boundingSpheres[0], result);
    }
    if (length === 2) {
      return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);
    }
    var positions = [];
    for (var i = 0; i < length; i++) {
      positions.push(boundingSpheres[i].center);
    }
    result = BoundingSphere.fromPoints(positions, result);
    var center = result.center;
    var radius = result.radius;
    for (i = 0; i < length; i++) {
      var tmp = boundingSpheres[i];
      radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);
    }
    result.radius = radius;
    return result;
  };
  var fromOrientedBoundingBoxScratchU = new Cartesian3();
  var fromOrientedBoundingBoxScratchV = new Cartesian3();
  var fromOrientedBoundingBoxScratchW = new Cartesian3();
  BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    var halfAxes = orientedBoundingBox.halfAxes;
    var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);
    var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);
    var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);
    var uHalf = Cartesian3.magnitude(u);
    var vHalf = Cartesian3.magnitude(v);
    var wHalf = Cartesian3.magnitude(w);
    result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);
    result.radius = Math.max(uHalf, vHalf, wHalf);
    return result;
  };
  BoundingSphere.clone = function(sphere, result) {
    if (!defined(sphere)) {
      return undefined;
    }
    if (!defined(result)) {
      return new BoundingSphere(sphere.center, sphere.radius);
    }
    result.center = Cartesian3.clone(sphere.center, result.center);
    result.radius = sphere.radius;
    return result;
  };
  BoundingSphere.packedLength = 4;
  BoundingSphere.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    var center = value.center;
    array[startingIndex++] = center.x;
    array[startingIndex++] = center.y;
    array[startingIndex++] = center.z;
    array[startingIndex] = value.radius;
    return array;
  };
  BoundingSphere.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    var center = result.center;
    center.x = array[startingIndex++];
    center.y = array[startingIndex++];
    center.z = array[startingIndex++];
    result.radius = array[startingIndex];
    return result;
  };
  var unionScratch = new Cartesian3();
  var unionScratchCenter = new Cartesian3();
  BoundingSphere.union = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    var leftCenter = left.center;
    var leftRadius = left.radius;
    var rightCenter = right.center;
    var rightRadius = right.radius;
    var toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);
    var centerSeparation = Cartesian3.magnitude(toRightCenter);
    if (leftRadius >= (centerSeparation + rightRadius)) {
      left.clone(result);
      return result;
    }
    if (rightRadius >= (centerSeparation + leftRadius)) {
      right.clone(result);
      return result;
    }
    var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
    var center = Cartesian3.multiplyByScalar(toRightCenter, (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);
    Cartesian3.add(center, leftCenter, center);
    Cartesian3.clone(center, result.center);
    result.radius = halfDistanceBetweenTangentPoints;
    return result;
  };
  var expandScratch = new Cartesian3();
  BoundingSphere.expand = function(sphere, point, result) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('point', point);
    result = BoundingSphere.clone(sphere, result);
    var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));
    if (radius > result.radius) {
      result.radius = radius;
    }
    return result;
  };
  BoundingSphere.intersectPlane = function(sphere, plane) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('plane', plane);
    var center = sphere.center;
    var radius = sphere.radius;
    var normal = plane.normal;
    var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;
    if (distanceToPlane < -radius) {
      return Intersect.OUTSIDE;
    } else if (distanceToPlane < radius) {
      return Intersect.INTERSECTING;
    }
    return Intersect.INSIDE;
  };
  BoundingSphere.transform = function(sphere, transform, result) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('transform', transform);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);
    result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;
    return result;
  };
  var distanceSquaredToScratch = new Cartesian3();
  BoundingSphere.distanceSquaredTo = function(sphere, cartesian) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('cartesian', cartesian);
    var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);
    return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;
  };
  BoundingSphere.transformWithoutScale = function(sphere, transform, result) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('transform', transform);
    if (!defined(result)) {
      result = new BoundingSphere();
    }
    result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);
    result.radius = sphere.radius;
    return result;
  };
  var scratchCartesian3 = new Cartesian3();
  BoundingSphere.computePlaneDistances = function(sphere, position, direction, result) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('position', position);
    Check.typeOf.object('direction', direction);
    if (!defined(result)) {
      result = new Interval();
    }
    var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);
    var mag = Cartesian3.dot(direction, toCenter);
    result.start = mag - sphere.radius;
    result.stop = mag + sphere.radius;
    return result;
  };
  var projectTo2DNormalScratch = new Cartesian3();
  var projectTo2DEastScratch = new Cartesian3();
  var projectTo2DNorthScratch = new Cartesian3();
  var projectTo2DWestScratch = new Cartesian3();
  var projectTo2DSouthScratch = new Cartesian3();
  var projectTo2DCartographicScratch = new Cartographic();
  var projectTo2DPositionsScratch = new Array(8);
  for (var n = 0; n < 8; ++n) {
    projectTo2DPositionsScratch[n] = new Cartesian3();
  }
  var projectTo2DProjection = new GeographicProjection();
  BoundingSphere.projectTo2D = function(sphere, projection, result) {
    Check.typeOf.object('sphere', sphere);
    projection = defaultValue(projection, projectTo2DProjection);
    var ellipsoid = projection.ellipsoid;
    var center = sphere.center;
    var radius = sphere.radius;
    var normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);
    var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);
    Cartesian3.normalize(east, east);
    var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);
    Cartesian3.normalize(north, north);
    Cartesian3.multiplyByScalar(normal, radius, normal);
    Cartesian3.multiplyByScalar(north, radius, north);
    Cartesian3.multiplyByScalar(east, radius, east);
    var south = Cartesian3.negate(north, projectTo2DSouthScratch);
    var west = Cartesian3.negate(east, projectTo2DWestScratch);
    var positions = projectTo2DPositionsScratch;
    var corner = positions[0];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, east, corner);
    corner = positions[1];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[2];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[3];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, east, corner);
    Cartesian3.negate(normal, normal);
    corner = positions[4];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, east, corner);
    corner = positions[5];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[6];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[7];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, east, corner);
    var length = positions.length;
    for (var i = 0; i < length; ++i) {
      var position = positions[i];
      Cartesian3.add(center, position, position);
      var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);
      projection.project(cartographic, position);
    }
    result = BoundingSphere.fromPoints(positions, result);
    center = result.center;
    var x = center.x;
    var y = center.y;
    var z = center.z;
    center.x = z;
    center.y = x;
    center.z = y;
    return result;
  };
  BoundingSphere.isOccluded = function(sphere, occluder) {
    Check.typeOf.object('sphere', sphere);
    Check.typeOf.object('occluder', occluder);
    return !occluder.isBoundingSphereVisible(sphere);
  };
  BoundingSphere.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && Cartesian3.equals(left.center, right.center) && left.radius === right.radius);
  };
  BoundingSphere.prototype.intersectPlane = function(plane) {
    return BoundingSphere.intersectPlane(this, plane);
  };
  BoundingSphere.prototype.distanceSquaredTo = function(cartesian) {
    return BoundingSphere.distanceSquaredTo(this, cartesian);
  };
  BoundingSphere.prototype.computePlaneDistances = function(position, direction, result) {
    return BoundingSphere.computePlaneDistances(this, position, direction, result);
  };
  BoundingSphere.prototype.isOccluded = function(occluder) {
    return BoundingSphere.isOccluded(this, occluder);
  };
  BoundingSphere.prototype.equals = function(right) {
    return BoundingSphere.equals(this, right);
  };
  BoundingSphere.prototype.clone = function(result) {
    return BoundingSphere.clone(this, result);
  };
  return BoundingSphere;
});

})();
(function() {
var define = $__System.amdDefine;
define("56", ["1f", "15", "5", "7", "33"], function(Cartesian3, defaultValue, defined, DeveloperError, Intersect) {
  'use strict';
  function AxisAlignedBoundingBox(minimum, maximum, center) {
    this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));
    this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));
    if (!defined(center)) {
      center = Cartesian3.add(this.minimum, this.maximum, new Cartesian3());
      Cartesian3.multiplyByScalar(center, 0.5, center);
    } else {
      center = Cartesian3.clone(center);
    }
    this.center = center;
  }
  AxisAlignedBoundingBox.fromPoints = function(positions, result) {
    if (!defined(result)) {
      result = new AxisAlignedBoundingBox();
    }
    if (!defined(positions) || positions.length === 0) {
      result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);
      result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);
      result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
      return result;
    }
    var minimumX = positions[0].x;
    var minimumY = positions[0].y;
    var minimumZ = positions[0].z;
    var maximumX = positions[0].x;
    var maximumY = positions[0].y;
    var maximumZ = positions[0].z;
    var length = positions.length;
    for (var i = 1; i < length; i++) {
      var p = positions[i];
      var x = p.x;
      var y = p.y;
      var z = p.z;
      minimumX = Math.min(x, minimumX);
      maximumX = Math.max(x, maximumX);
      minimumY = Math.min(y, minimumY);
      maximumY = Math.max(y, maximumY);
      minimumZ = Math.min(z, minimumZ);
      maximumZ = Math.max(z, maximumZ);
    }
    var minimum = result.minimum;
    minimum.x = minimumX;
    minimum.y = minimumY;
    minimum.z = minimumZ;
    var maximum = result.maximum;
    maximum.x = maximumX;
    maximum.y = maximumY;
    maximum.z = maximumZ;
    var center = Cartesian3.add(minimum, maximum, result.center);
    Cartesian3.multiplyByScalar(center, 0.5, center);
    return result;
  };
  AxisAlignedBoundingBox.clone = function(box, result) {
    if (!defined(box)) {
      return undefined;
    }
    if (!defined(result)) {
      return new AxisAlignedBoundingBox(box.minimum, box.maximum);
    }
    result.minimum = Cartesian3.clone(box.minimum, result.minimum);
    result.maximum = Cartesian3.clone(box.maximum, result.maximum);
    result.center = Cartesian3.clone(box.center, result.center);
    return result;
  };
  AxisAlignedBoundingBox.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && Cartesian3.equals(left.center, right.center) && Cartesian3.equals(left.minimum, right.minimum) && Cartesian3.equals(left.maximum, right.maximum));
  };
  var intersectScratch = new Cartesian3();
  AxisAlignedBoundingBox.intersectPlane = function(box, plane) {
    if (!defined(box)) {
      throw new DeveloperError('box is required.');
    }
    if (!defined(plane)) {
      throw new DeveloperError('plane is required.');
    }
    intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);
    var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch);
    var normal = plane.normal;
    var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);
    var s = Cartesian3.dot(box.center, normal) + plane.distance;
    if (s - e > 0) {
      return Intersect.INSIDE;
    }
    if (s + e < 0) {
      return Intersect.OUTSIDE;
    }
    return Intersect.INTERSECTING;
  };
  AxisAlignedBoundingBox.prototype.clone = function(result) {
    return AxisAlignedBoundingBox.clone(this, result);
  };
  AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {
    return AxisAlignedBoundingBox.intersectPlane(this, plane);
  };
  AxisAlignedBoundingBox.prototype.equals = function(right) {
    return AxisAlignedBoundingBox.equals(this, right);
  };
  return AxisAlignedBoundingBox;
});

})();
(function() {
var define = $__System.amdDefine;
define("57", ["7", "58"], function(DeveloperError, QuadraticRealPolynomial) {
  'use strict';
  var CubicRealPolynomial = {};
  CubicRealPolynomial.computeDiscriminant = function(a, b, c, d) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
      throw new DeveloperError('d is a required number.');
    }
    var a2 = a * a;
    var b2 = b * b;
    var c2 = c * c;
    var d2 = d * d;
    var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);
    return discriminant;
  };
  function computeRealRoots(a, b, c, d) {
    var A = a;
    var B = b / 3.0;
    var C = c / 3.0;
    var D = d;
    var AC = A * C;
    var BD = B * D;
    var B2 = B * B;
    var C2 = C * C;
    var delta1 = A * C - B2;
    var delta2 = A * D - B * C;
    var delta3 = B * D - C2;
    var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;
    var temp;
    var temp1;
    if (discriminant < 0.0) {
      var ABar;
      var CBar;
      var DBar;
      if (B2 * BD >= AC * C2) {
        ABar = A;
        CBar = delta1;
        DBar = -2.0 * B * delta1 + A * delta2;
      } else {
        ABar = D;
        CBar = delta3;
        DBar = -D * delta2 + 2.0 * C * delta3;
      }
      var s = (DBar < 0.0) ? -1.0 : 1.0;
      var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
      temp1 = -DBar + temp0;
      var x = temp1 / 2.0;
      var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);
      var q = (temp1 === temp0) ? -p : -CBar / p;
      temp = (CBar <= 0.0) ? p + q : -DBar / (p * p + q * q + CBar);
      if (B2 * BD >= AC * C2) {
        return [(temp - B) / A];
      }
      return [-D / (temp + C)];
    }
    var CBarA = delta1;
    var DBarA = -2.0 * B * delta1 + A * delta2;
    var CBarD = delta3;
    var DBarD = -D * delta2 + 2.0 * C * delta3;
    var squareRootOfDiscriminant = Math.sqrt(discriminant);
    var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;
    var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);
    temp = 2.0 * Math.sqrt(-CBarA);
    var cosine = Math.cos(theta);
    temp1 = temp * cosine;
    var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));
    var numeratorLarge = (temp1 + temp3 > 2.0 * B) ? temp1 - B : temp3 - B;
    var denominatorLarge = A;
    var root1 = numeratorLarge / denominatorLarge;
    theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);
    temp = 2.0 * Math.sqrt(-CBarD);
    cosine = Math.cos(theta);
    temp1 = temp * cosine;
    temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));
    var numeratorSmall = -D;
    var denominatorSmall = (temp1 + temp3 < 2.0 * C) ? temp1 + C : temp3 + C;
    var root3 = numeratorSmall / denominatorSmall;
    var E = denominatorLarge * denominatorSmall;
    var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
    var G = numeratorLarge * numeratorSmall;
    var root2 = (C * F - B * G) / (-B * F + C * E);
    if (root1 <= root2) {
      if (root1 <= root3) {
        if (root2 <= root3) {
          return [root1, root2, root3];
        }
        return [root1, root3, root2];
      }
      return [root3, root1, root2];
    }
    if (root1 <= root3) {
      return [root2, root1, root3];
    }
    if (root2 <= root3) {
      return [root2, root3, root1];
    }
    return [root3, root2, root1];
  }
  CubicRealPolynomial.computeRealRoots = function(a, b, c, d) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
      throw new DeveloperError('d is a required number.');
    }
    var roots;
    var ratio;
    if (a === 0.0) {
      return QuadraticRealPolynomial.computeRealRoots(b, c, d);
    } else if (b === 0.0) {
      if (c === 0.0) {
        if (d === 0.0) {
          return [0.0, 0.0, 0.0];
        }
        ratio = -d / a;
        var root = (ratio < 0.0) ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);
        return [root, root, root];
      } else if (d === 0.0) {
        roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);
        if (roots.Length === 0) {
          return [0.0];
        }
        return [roots[0], 0.0, roots[1]];
      }
      return computeRealRoots(a, 0, c, d);
    } else if (c === 0.0) {
      if (d === 0.0) {
        ratio = -b / a;
        if (ratio < 0.0) {
          return [ratio, 0.0, 0.0];
        }
        return [0.0, 0.0, ratio];
      }
      return computeRealRoots(a, b, 0, d);
    } else if (d === 0.0) {
      roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);
      if (roots.length === 0) {
        return [0.0];
      } else if (roots[1] <= 0.0) {
        return [roots[0], roots[1], 0.0];
      } else if (roots[0] >= 0.0) {
        return [0.0, roots[0], roots[1]];
      }
      return [roots[0], 0.0, roots[1]];
    }
    return computeRealRoots(a, b, c, d);
  };
  return CubicRealPolynomial;
});

})();
(function() {
var define = $__System.amdDefine;
define("58", ["7", "d"], function(DeveloperError, CesiumMath) {
  'use strict';
  var QuadraticRealPolynomial = {};
  QuadraticRealPolynomial.computeDiscriminant = function(a, b, c) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    var discriminant = b * b - 4.0 * a * c;
    return discriminant;
  };
  function addWithCancellationCheck(left, right, tolerance) {
    var difference = left + right;
    if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
      return 0.0;
    }
    return difference;
  }
  QuadraticRealPolynomial.computeRealRoots = function(a, b, c) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    var ratio;
    if (a === 0.0) {
      if (b === 0.0) {
        return [];
      }
      return [-c / b];
    } else if (b === 0.0) {
      if (c === 0.0) {
        return [0.0, 0.0];
      }
      var cMagnitude = Math.abs(c);
      var aMagnitude = Math.abs(a);
      if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < CesiumMath.EPSILON14)) {
        return [0.0, 0.0];
      } else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < CesiumMath.EPSILON14)) {
        return [];
      }
      ratio = -c / a;
      if (ratio < 0.0) {
        return [];
      }
      var root = Math.sqrt(ratio);
      return [-root, root];
    } else if (c === 0.0) {
      ratio = -b / a;
      if (ratio < 0.0) {
        return [ratio, 0.0];
      }
      return [0.0, ratio];
    }
    var b2 = b * b;
    var four_ac = 4.0 * a * c;
    var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);
    if (radicand < 0.0) {
      return [];
    }
    var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);
    if (b > 0.0) {
      return [q / a, c / q];
    }
    return [c / q, q / a];
  };
  return QuadraticRealPolynomial;
});

})();
(function() {
var define = $__System.amdDefine;
define("59", ["57", "7", "d", "58"], function(CubicRealPolynomial, DeveloperError, CesiumMath, QuadraticRealPolynomial) {
  'use strict';
  var QuarticRealPolynomial = {};
  QuarticRealPolynomial.computeDiscriminant = function(a, b, c, d, e) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
      throw new DeveloperError('d is a required number.');
    }
    if (typeof e !== 'number') {
      throw new DeveloperError('e is a required number.');
    }
    var a2 = a * a;
    var a3 = a2 * a;
    var b2 = b * b;
    var b3 = b2 * b;
    var c2 = c * c;
    var c3 = c2 * c;
    var d2 = d * d;
    var d3 = d2 * d;
    var e2 = e * e;
    var e3 = e2 * e;
    var discriminant = (b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3) + e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) + e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);
    return discriminant;
  };
  function original(a3, a2, a1, a0) {
    var a3Squared = a3 * a3;
    var p = a2 - 3.0 * a3Squared / 8.0;
    var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;
    var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;
    var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, 2.0 * p, p * p - 4.0 * r, -q * q);
    if (cubicRoots.length > 0) {
      var temp = -a3 / 4.0;
      var hSquared = cubicRoots[cubicRoots.length - 1];
      if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
        var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);
        if (roots.length === 2) {
          var root0 = roots[0];
          var root1 = roots[1];
          var y;
          if (root0 >= 0.0 && root1 >= 0.0) {
            var y0 = Math.sqrt(root0);
            var y1 = Math.sqrt(root1);
            return [temp - y1, temp - y0, temp + y0, temp + y1];
          } else if (root0 >= 0.0 && root1 < 0.0) {
            y = Math.sqrt(root0);
            return [temp - y, temp + y];
          } else if (root0 < 0.0 && root1 >= 0.0) {
            y = Math.sqrt(root1);
            return [temp - y, temp + y];
          }
        }
        return [];
      } else if (hSquared > 0.0) {
        var h = Math.sqrt(hSquared);
        var m = (p + hSquared - q / h) / 2.0;
        var n = (p + hSquared + q / h) / 2.0;
        var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);
        var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);
        if (roots1.length !== 0) {
          roots1[0] += temp;
          roots1[1] += temp;
          if (roots2.length !== 0) {
            roots2[0] += temp;
            roots2[1] += temp;
            if (roots1[1] <= roots2[0]) {
              return [roots1[0], roots1[1], roots2[0], roots2[1]];
            } else if (roots2[1] <= roots1[0]) {
              return [roots2[0], roots2[1], roots1[0], roots1[1]];
            } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
              return [roots2[0], roots1[0], roots1[1], roots2[1]];
            } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
              return [roots1[0], roots2[0], roots2[1], roots1[1]];
            } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
              return [roots2[0], roots1[0], roots2[1], roots1[1]];
            }
            return [roots1[0], roots2[0], roots1[1], roots2[1]];
          }
          return roots1;
        }
        if (roots2.length !== 0) {
          roots2[0] += temp;
          roots2[1] += temp;
          return roots2;
        }
        return [];
      }
    }
    return [];
  }
  function neumark(a3, a2, a1, a0) {
    var a1Squared = a1 * a1;
    var a2Squared = a2 * a2;
    var a3Squared = a3 * a3;
    var p = -2.0 * a2;
    var q = a1 * a3 + a2Squared - 4.0 * a0;
    var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;
    var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);
    if (cubicRoots.length > 0) {
      var y = cubicRoots[0];
      var temp = (a2 - y);
      var tempSquared = temp * temp;
      var g1 = a3 / 2.0;
      var h1 = temp / 2.0;
      var m = tempSquared - 4.0 * a0;
      var mError = tempSquared + 4.0 * Math.abs(a0);
      var n = a3Squared - 4.0 * y;
      var nError = a3Squared + 4.0 * Math.abs(y);
      var g2;
      var h2;
      if (y < 0.0 || (m * nError < n * mError)) {
        var squareRootOfN = Math.sqrt(n);
        g2 = squareRootOfN / 2.0;
        h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;
      } else {
        var squareRootOfM = Math.sqrt(m);
        g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;
        h2 = squareRootOfM / 2.0;
      }
      var G;
      var g;
      if (g1 === 0.0 && g2 === 0.0) {
        G = 0.0;
        g = 0.0;
      } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
        G = g1 + g2;
        g = y / G;
      } else {
        g = g1 - g2;
        G = y / g;
      }
      var H;
      var h;
      if (h1 === 0.0 && h2 === 0.0) {
        H = 0.0;
        h = 0.0;
      } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {
        H = h1 + h2;
        h = a0 / H;
      } else {
        h = h1 - h2;
        H = a0 / h;
      }
      var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);
      var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);
      if (roots1.length !== 0) {
        if (roots2.length !== 0) {
          if (roots1[1] <= roots2[0]) {
            return [roots1[0], roots1[1], roots2[0], roots2[1]];
          } else if (roots2[1] <= roots1[0]) {
            return [roots2[0], roots2[1], roots1[0], roots1[1]];
          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
            return [roots2[0], roots1[0], roots1[1], roots2[1]];
          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
            return [roots1[0], roots2[0], roots2[1], roots1[1]];
          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
            return [roots2[0], roots1[0], roots2[1], roots1[1]];
          } else {
            return [roots1[0], roots2[0], roots1[1], roots2[1]];
          }
        }
        return roots1;
      }
      if (roots2.length !== 0) {
        return roots2;
      }
    }
    return [];
  }
  QuarticRealPolynomial.computeRealRoots = function(a, b, c, d, e) {
    if (typeof a !== 'number') {
      throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
      throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
      throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
      throw new DeveloperError('d is a required number.');
    }
    if (typeof e !== 'number') {
      throw new DeveloperError('e is a required number.');
    }
    if (Math.abs(a) < CesiumMath.EPSILON15) {
      return CubicRealPolynomial.computeRealRoots(b, c, d, e);
    }
    var a3 = b / a;
    var a2 = c / a;
    var a1 = d / a;
    var a0 = e / a;
    var k = (a3 < 0.0) ? 1 : 0;
    k += (a2 < 0.0) ? k + 1 : k;
    k += (a1 < 0.0) ? k + 1 : k;
    k += (a0 < 0.0) ? k + 1 : k;
    switch (k) {
      case 0:
        return original(a3, a2, a1, a0);
      case 1:
        return neumark(a3, a2, a1, a0);
      case 2:
        return neumark(a3, a2, a1, a0);
      case 3:
        return original(a3, a2, a1, a0);
      case 4:
        return original(a3, a2, a1, a0);
      case 5:
        return neumark(a3, a2, a1, a0);
      case 6:
        return original(a3, a2, a1, a0);
      case 7:
        return original(a3, a2, a1, a0);
      case 8:
        return neumark(a3, a2, a1, a0);
      case 9:
        return original(a3, a2, a1, a0);
      case 10:
        return original(a3, a2, a1, a0);
      case 11:
        return neumark(a3, a2, a1, a0);
      case 12:
        return original(a3, a2, a1, a0);
      case 13:
        return original(a3, a2, a1, a0);
      case 14:
        return original(a3, a2, a1, a0);
      case 15:
        return original(a3, a2, a1, a0);
      default:
        return undefined;
    }
  };
  return QuarticRealPolynomial;
});

})();
(function() {
var define = $__System.amdDefine;
define("45", ["1f", "41", "15", "5", "7", "55", "d", "27", "58", "59", "5a"], function(Cartesian3, Cartographic, defaultValue, defined, DeveloperError, Interval, CesiumMath, Matrix3, QuadraticRealPolynomial, QuarticRealPolynomial, Ray) {
  'use strict';
  var IntersectionTests = {};
  IntersectionTests.rayPlane = function(ray, plane, result) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is required.');
    }
    if (!defined(plane)) {
      throw new DeveloperError('plane is required.');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var normal = plane.normal;
    var denominator = Cartesian3.dot(normal, direction);
    if (Math.abs(denominator) < CesiumMath.EPSILON15) {
      return undefined;
    }
    var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;
    if (t < 0) {
      return undefined;
    }
    result = Cartesian3.multiplyByScalar(direction, t, result);
    return Cartesian3.add(origin, result, result);
  };
  var scratchEdge0 = new Cartesian3();
  var scratchEdge1 = new Cartesian3();
  var scratchPVec = new Cartesian3();
  var scratchTVec = new Cartesian3();
  var scratchQVec = new Cartesian3();
  IntersectionTests.rayTriangleParametric = function(ray, p0, p1, p2, cullBackFaces) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is required.');
    }
    if (!defined(p0)) {
      throw new DeveloperError('p0 is required.');
    }
    if (!defined(p1)) {
      throw new DeveloperError('p1 is required.');
    }
    if (!defined(p2)) {
      throw new DeveloperError('p2 is required.');
    }
    cullBackFaces = defaultValue(cullBackFaces, false);
    var origin = ray.origin;
    var direction = ray.direction;
    var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);
    var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);
    var p = Cartesian3.cross(direction, edge1, scratchPVec);
    var det = Cartesian3.dot(edge0, p);
    var tvec;
    var q;
    var u;
    var v;
    var t;
    if (cullBackFaces) {
      if (det < CesiumMath.EPSILON6) {
        return undefined;
      }
      tvec = Cartesian3.subtract(origin, p0, scratchTVec);
      u = Cartesian3.dot(tvec, p);
      if (u < 0.0 || u > det) {
        return undefined;
      }
      q = Cartesian3.cross(tvec, edge0, scratchQVec);
      v = Cartesian3.dot(direction, q);
      if (v < 0.0 || u + v > det) {
        return undefined;
      }
      t = Cartesian3.dot(edge1, q) / det;
    } else {
      if (Math.abs(det) < CesiumMath.EPSILON6) {
        return undefined;
      }
      var invDet = 1.0 / det;
      tvec = Cartesian3.subtract(origin, p0, scratchTVec);
      u = Cartesian3.dot(tvec, p) * invDet;
      if (u < 0.0 || u > 1.0) {
        return undefined;
      }
      q = Cartesian3.cross(tvec, edge0, scratchQVec);
      v = Cartesian3.dot(direction, q) * invDet;
      if (v < 0.0 || u + v > 1.0) {
        return undefined;
      }
      t = Cartesian3.dot(edge1, q) * invDet;
    }
    return t;
  };
  IntersectionTests.rayTriangle = function(ray, p0, p1, p2, cullBackFaces, result) {
    var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);
    if (!defined(t) || t < 0.0) {
      return undefined;
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
  };
  var scratchLineSegmentTriangleRay = new Ray();
  IntersectionTests.lineSegmentTriangle = function(v0, v1, p0, p1, p2, cullBackFaces, result) {
    if (!defined(v0)) {
      throw new DeveloperError('v0 is required.');
    }
    if (!defined(v1)) {
      throw new DeveloperError('v1 is required.');
    }
    if (!defined(p0)) {
      throw new DeveloperError('p0 is required.');
    }
    if (!defined(p1)) {
      throw new DeveloperError('p1 is required.');
    }
    if (!defined(p2)) {
      throw new DeveloperError('p2 is required.');
    }
    var ray = scratchLineSegmentTriangleRay;
    Cartesian3.clone(v0, ray.origin);
    Cartesian3.subtract(v1, v0, ray.direction);
    Cartesian3.normalize(ray.direction, ray.direction);
    var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);
    if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {
      return undefined;
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
  };
  function solveQuadratic(a, b, c, result) {
    var det = b * b - 4.0 * a * c;
    if (det < 0.0) {
      return undefined;
    } else if (det > 0.0) {
      var denom = 1.0 / (2.0 * a);
      var disc = Math.sqrt(det);
      var root0 = (-b + disc) * denom;
      var root1 = (-b - disc) * denom;
      if (root0 < root1) {
        result.root0 = root0;
        result.root1 = root1;
      } else {
        result.root0 = root1;
        result.root1 = root0;
      }
      return result;
    }
    var root = -b / (2.0 * a);
    if (root === 0.0) {
      return undefined;
    }
    result.root0 = result.root1 = root;
    return result;
  }
  var raySphereRoots = {
    root0: 0.0,
    root1: 0.0
  };
  function raySphere(ray, sphere, result) {
    if (!defined(result)) {
      result = new Interval();
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var center = sphere.center;
    var radiusSquared = sphere.radius * sphere.radius;
    var diff = Cartesian3.subtract(origin, center, scratchPVec);
    var a = Cartesian3.dot(direction, direction);
    var b = 2.0 * Cartesian3.dot(direction, diff);
    var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;
    var roots = solveQuadratic(a, b, c, raySphereRoots);
    if (!defined(roots)) {
      return undefined;
    }
    result.start = roots.root0;
    result.stop = roots.root1;
    return result;
  }
  IntersectionTests.raySphere = function(ray, sphere, result) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is required.');
    }
    if (!defined(sphere)) {
      throw new DeveloperError('sphere is required.');
    }
    result = raySphere(ray, sphere, result);
    if (!defined(result) || result.stop < 0.0) {
      return undefined;
    }
    result.start = Math.max(result.start, 0.0);
    return result;
  };
  var scratchLineSegmentRay = new Ray();
  IntersectionTests.lineSegmentSphere = function(p0, p1, sphere, result) {
    if (!defined(p0)) {
      throw new DeveloperError('p0 is required.');
    }
    if (!defined(p1)) {
      throw new DeveloperError('p1 is required.');
    }
    if (!defined(sphere)) {
      throw new DeveloperError('sphere is required.');
    }
    var ray = scratchLineSegmentRay;
    Cartesian3.clone(p0, ray.origin);
    var direction = Cartesian3.subtract(p1, p0, ray.direction);
    var maxT = Cartesian3.magnitude(direction);
    Cartesian3.normalize(direction, direction);
    result = raySphere(ray, sphere, result);
    if (!defined(result) || result.stop < 0.0 || result.start > maxT) {
      return undefined;
    }
    result.start = Math.max(result.start, 0.0);
    result.stop = Math.min(result.stop, maxT);
    return result;
  };
  var scratchQ = new Cartesian3();
  var scratchW = new Cartesian3();
  IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is required.');
    }
    if (!defined(ellipsoid)) {
      throw new DeveloperError('ellipsoid is required.');
    }
    var inverseRadii = ellipsoid.oneOverRadii;
    var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);
    var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);
    var q2 = Cartesian3.magnitudeSquared(q);
    var qw = Cartesian3.dot(q, w);
    var difference,
        w2,
        product,
        discriminant,
        temp;
    if (q2 > 1.0) {
      if (qw >= 0.0) {
        return undefined;
      }
      var qw2 = qw * qw;
      difference = q2 - 1.0;
      w2 = Cartesian3.magnitudeSquared(w);
      product = w2 * difference;
      if (qw2 < product) {
        return undefined;
      } else if (qw2 > product) {
        discriminant = qw * qw - product;
        temp = -qw + Math.sqrt(discriminant);
        var root0 = temp / w2;
        var root1 = difference / temp;
        if (root0 < root1) {
          return new Interval(root0, root1);
        }
        return {
          start: root1,
          stop: root0
        };
      } else {
        var root = Math.sqrt(difference / w2);
        return new Interval(root, root);
      }
    } else if (q2 < 1.0) {
      difference = q2 - 1.0;
      w2 = Cartesian3.magnitudeSquared(w);
      product = w2 * difference;
      discriminant = qw * qw - product;
      temp = -qw + Math.sqrt(discriminant);
      return new Interval(0.0, temp / w2);
    } else {
      if (qw < 0.0) {
        w2 = Cartesian3.magnitudeSquared(w);
        return new Interval(0.0, -qw / w2);
      }
      return undefined;
    }
  };
  function addWithCancellationCheck(left, right, tolerance) {
    var difference = left + right;
    if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
      return 0.0;
    }
    return difference;
  }
  function quadraticVectorExpression(A, b, c, x, w) {
    var xSquared = x * x;
    var wSquared = w * w;
    var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
    var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);
    var l0 = (A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared) + x * b.x + c;
    var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);
    var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);
    var cosines;
    var solutions = [];
    if (r0 === 0.0 && r1 === 0.0) {
      cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);
      if (cosines.length === 0) {
        return solutions;
      }
      var cosine0 = cosines[0];
      var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));
      solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
      solutions.push(new Cartesian3(x, w * cosine0, w * sine0));
      if (cosines.length === 2) {
        var cosine1 = cosines[1];
        var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));
        solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
        solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
      }
      return solutions;
    }
    var r0Squared = r0 * r0;
    var r1Squared = r1 * r1;
    var l2Squared = l2 * l2;
    var r0r1 = r0 * r1;
    var c4 = l2Squared + r1Squared;
    var c3 = 2.0 * (l1 * l2 + r0r1);
    var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
    var c1 = 2.0 * (l0 * l1 - r0r1);
    var c0 = l0 * l0 - r0Squared;
    if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {
      return solutions;
    }
    cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);
    var length = cosines.length;
    if (length === 0) {
      return solutions;
    }
    for (var i = 0; i < length; ++i) {
      var cosine = cosines[i];
      var cosineSquared = cosine * cosine;
      var sineSquared = Math.max(1.0 - cosineSquared, 0.0);
      var sine = Math.sqrt(sineSquared);
      var left;
      if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
        left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);
      } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
        left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);
      } else {
        left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);
      }
      var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);
      var product = left * right;
      if (product < 0.0) {
        solutions.push(new Cartesian3(x, w * cosine, w * sine));
      } else if (product > 0.0) {
        solutions.push(new Cartesian3(x, w * cosine, w * -sine));
      } else if (sine !== 0.0) {
        solutions.push(new Cartesian3(x, w * cosine, w * -sine));
        solutions.push(new Cartesian3(x, w * cosine, w * sine));
        ++i;
      } else {
        solutions.push(new Cartesian3(x, w * cosine, w * sine));
      }
    }
    return solutions;
  }
  var firstAxisScratch = new Cartesian3();
  var secondAxisScratch = new Cartesian3();
  var thirdAxisScratch = new Cartesian3();
  var referenceScratch = new Cartesian3();
  var bCart = new Cartesian3();
  var bScratch = new Matrix3();
  var btScratch = new Matrix3();
  var diScratch = new Matrix3();
  var dScratch = new Matrix3();
  var cScratch = new Matrix3();
  var tempMatrix = new Matrix3();
  var aScratch = new Matrix3();
  var sScratch = new Cartesian3();
  var closestScratch = new Cartesian3();
  var surfPointScratch = new Cartographic();
  IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is required.');
    }
    if (!defined(ellipsoid)) {
      throw new DeveloperError('ellipsoid is required.');
    }
    var position = ray.origin;
    var direction = ray.direction;
    if (!Cartesian3.equals(position, Cartesian3.ZERO)) {
      var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
      if (Cartesian3.dot(direction, normal) >= 0.0) {
        return position;
      }
    }
    var intersects = defined(this.rayEllipsoid(ray, ellipsoid));
    var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);
    var firstAxis = Cartesian3.normalize(f, f);
    var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);
    var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);
    var thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);
    var B = bScratch;
    B[0] = firstAxis.x;
    B[1] = firstAxis.y;
    B[2] = firstAxis.z;
    B[3] = secondAxis.x;
    B[4] = secondAxis.y;
    B[5] = secondAxis.z;
    B[6] = thirdAxis.x;
    B[7] = thirdAxis.y;
    B[8] = thirdAxis.z;
    var B_T = Matrix3.transpose(B, btScratch);
    var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);
    var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);
    var C = cScratch;
    C[0] = 0.0;
    C[1] = -direction.z;
    C[2] = direction.y;
    C[3] = direction.z;
    C[4] = 0.0;
    C[5] = -direction.x;
    C[6] = -direction.y;
    C[7] = direction.x;
    C[8] = 0.0;
    var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);
    var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);
    var b = Matrix3.multiplyByVector(temp, position, bCart);
    var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);
    var s;
    var altitude;
    var length = solutions.length;
    if (length > 0) {
      var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);
      var maximumValue = Number.NEGATIVE_INFINITY;
      for (var i = 0; i < length; ++i) {
        s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);
        var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);
        var dotProduct = Cartesian3.dot(v, direction);
        if (dotProduct > maximumValue) {
          maximumValue = dotProduct;
          closest = Cartesian3.clone(s, closest);
        }
      }
      var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);
      maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);
      altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);
      altitude = intersects ? -altitude : altitude;
      surfacePoint.height = altitude;
      return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());
    }
    return undefined;
  };
  var lineSegmentPlaneDifference = new Cartesian3();
  IntersectionTests.lineSegmentPlane = function(endPoint0, endPoint1, plane, result) {
    if (!defined(endPoint0)) {
      throw new DeveloperError('endPoint0 is required.');
    }
    if (!defined(endPoint1)) {
      throw new DeveloperError('endPoint1 is required.');
    }
    if (!defined(plane)) {
      throw new DeveloperError('plane is required.');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);
    var normal = plane.normal;
    var nDotDiff = Cartesian3.dot(normal, difference);
    if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {
      return undefined;
    }
    var nDotP0 = Cartesian3.dot(normal, endPoint0);
    var t = -(plane.distance + nDotP0) / nDotDiff;
    if (t < 0.0 || t > 1.0) {
      return undefined;
    }
    Cartesian3.multiplyByScalar(difference, t, result);
    Cartesian3.add(endPoint0, result, result);
    return result;
  };
  IntersectionTests.trianglePlaneIntersection = function(p0, p1, p2, plane) {
    if ((!defined(p0)) || (!defined(p1)) || (!defined(p2)) || (!defined(plane))) {
      throw new DeveloperError('p0, p1, p2, and plane are required.');
    }
    var planeNormal = plane.normal;
    var planeD = plane.distance;
    var p0Behind = (Cartesian3.dot(planeNormal, p0) + planeD) < 0.0;
    var p1Behind = (Cartesian3.dot(planeNormal, p1) + planeD) < 0.0;
    var p2Behind = (Cartesian3.dot(planeNormal, p2) + planeD) < 0.0;
    var numBehind = 0;
    numBehind += p0Behind ? 1 : 0;
    numBehind += p1Behind ? 1 : 0;
    numBehind += p2Behind ? 1 : 0;
    var u1,
        u2;
    if (numBehind === 1 || numBehind === 2) {
      u1 = new Cartesian3();
      u2 = new Cartesian3();
    }
    if (numBehind === 1) {
      if (p0Behind) {
        IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);
        IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [0, 3, 4, 1, 2, 4, 1, 4, 3]
        };
      } else if (p1Behind) {
        IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);
        IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [1, 3, 4, 2, 0, 4, 2, 4, 3]
        };
      } else if (p2Behind) {
        IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);
        IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [2, 3, 4, 0, 1, 4, 0, 4, 3]
        };
      }
    } else if (numBehind === 2) {
      if (!p0Behind) {
        IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);
        IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [1, 2, 4, 1, 4, 3, 0, 3, 4]
        };
      } else if (!p1Behind) {
        IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);
        IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [2, 0, 4, 2, 4, 3, 1, 3, 4]
        };
      } else if (!p2Behind) {
        IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);
        IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);
        return {
          positions: [p0, p1, p2, u1, u2],
          indices: [0, 1, 4, 0, 4, 3, 2, 3, 4]
        };
      }
    }
    return undefined;
  };
  return IntersectionTests;
});

})();
(function() {
var define = $__System.amdDefine;
define("5a", ["1f", "15", "5", "7"], function(Cartesian3, defaultValue, defined, DeveloperError) {
  'use strict';
  function Ray(origin, direction) {
    direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
    if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {
      Cartesian3.normalize(direction, direction);
    }
    this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));
    this.direction = direction;
  }
  Ray.getPoint = function(ray, t, result) {
    if (!defined(ray)) {
      throw new DeveloperError('ray is requred');
    }
    if (typeof t !== 'number') {
      throw new DeveloperError('t is a required number');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    result = Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
  };
  return Ray;
});

})();
(function() {
var define = $__System.amdDefine;
define("5b", ["56", "a", "1f", "32", "15", "5", "6", "7", "42", "45", "28", "34", "5a", "2a"], function(AxisAlignedBoundingBox, Cartesian2, Cartesian3, Cartesian4, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, IntersectionTests, Matrix4, Plane, Ray, Transforms) {
  'use strict';
  var scratchCart4 = new Cartesian4();
  function EllipsoidTangentPlane(origin, ellipsoid) {
    if (!defined(origin)) {
      throw new DeveloperError('origin is required.');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    origin = ellipsoid.scaleToGeodeticSurface(origin);
    if (!defined(origin)) {
      throw new DeveloperError('origin must not be at the center of the ellipsoid.');
    }
    var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);
    this._ellipsoid = ellipsoid;
    this._origin = origin;
    this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));
    this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));
    var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));
    this._plane = Plane.fromPointNormal(origin, normal);
  }
  defineProperties(EllipsoidTangentPlane.prototype, {
    ellipsoid: {get: function() {
        return this._ellipsoid;
      }},
    origin: {get: function() {
        return this._origin;
      }},
    plane: {get: function() {
        return this._plane;
      }},
    xAxis: {get: function() {
        return this._xAxis;
      }},
    yAxis: {get: function() {
        return this._yAxis;
      }},
    zAxis: {get: function() {
        return this._plane.normal;
      }}
  });
  var tmp = new AxisAlignedBoundingBox();
  EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {
    if (!defined(cartesians)) {
      throw new DeveloperError('cartesians is required.');
    }
    var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);
    return new EllipsoidTangentPlane(box.center, ellipsoid);
  };
  var scratchProjectPointOntoPlaneRay = new Ray();
  var scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();
  EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required.');
    }
    var ray = scratchProjectPointOntoPlaneRay;
    ray.origin = cartesian;
    Cartesian3.normalize(cartesian, ray.direction);
    var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);
    if (!defined(intersectionPoint)) {
      Cartesian3.negate(ray.direction, ray.direction);
      intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);
    }
    if (defined(intersectionPoint)) {
      var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);
      var x = Cartesian3.dot(this._xAxis, v);
      var y = Cartesian3.dot(this._yAxis, v);
      if (!defined(result)) {
        return new Cartesian2(x, y);
      }
      result.x = x;
      result.y = y;
      return result;
    }
    return undefined;
  };
  EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {
    if (!defined(cartesians)) {
      throw new DeveloperError('cartesians is required.');
    }
    if (!defined(result)) {
      result = [];
    }
    var count = 0;
    var length = cartesians.length;
    for (var i = 0; i < length; i++) {
      var p = this.projectPointOntoPlane(cartesians[i], result[count]);
      if (defined(p)) {
        result[count] = p;
        count++;
      }
    }
    result.length = count;
    return result;
  };
  EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function(cartesian, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
      result = new Cartesian2();
    }
    var ray = scratchProjectPointOntoPlaneRay;
    ray.origin = cartesian;
    Cartesian3.clone(this._plane.normal, ray.direction);
    var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);
    if (!defined(intersectionPoint)) {
      Cartesian3.negate(ray.direction, ray.direction);
      intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);
    }
    var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);
    var x = Cartesian3.dot(this._xAxis, v);
    var y = Cartesian3.dot(this._yAxis, v);
    result.x = x;
    result.y = y;
    return result;
  };
  EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function(cartesians, result) {
    if (!defined(cartesians)) {
      throw new DeveloperError('cartesians is required.');
    }
    if (!defined(result)) {
      result = [];
    }
    var length = cartesians.length;
    result.length = length;
    for (var i = 0; i < length; i++) {
      result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);
    }
    return result;
  };
  var projectPointsOntoEllipsoidScratch = new Cartesian3();
  EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {
    if (!defined(cartesians)) {
      throw new DeveloperError('cartesians is required.');
    }
    var length = cartesians.length;
    if (!defined(result)) {
      result = new Array(length);
    } else {
      result.length = length;
    }
    var ellipsoid = this._ellipsoid;
    var origin = this._origin;
    var xAxis = this._xAxis;
    var yAxis = this._yAxis;
    var tmp = projectPointsOntoEllipsoidScratch;
    for (var i = 0; i < length; ++i) {
      var position = cartesians[i];
      Cartesian3.multiplyByScalar(xAxis, position.x, tmp);
      if (!defined(result[i])) {
        result[i] = new Cartesian3();
      }
      var point = Cartesian3.add(origin, tmp, result[i]);
      Cartesian3.multiplyByScalar(yAxis, position.y, tmp);
      Cartesian3.add(point, tmp, point);
      ellipsoid.scaleToGeocentricSurface(point, point);
    }
    return result;
  };
  return EllipsoidTangentPlane;
});

})();
(function() {
var define = $__System.amdDefine;
define("33", ["11"], function(freezeObject) {
  'use strict';
  var Intersect = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
  };
  return freezeObject(Intersect);
});

})();
(function() {
var define = $__System.amdDefine;
define("55", ["15"], function(defaultValue) {
  'use strict';
  function Interval(start, stop) {
    this.start = defaultValue(start, 0.0);
    this.stop = defaultValue(stop, 0.0);
  }
  return Interval;
});

})();
(function() {
var define = $__System.amdDefine;
define("34", ["1f", "5", "7", "11"], function(Cartesian3, defined, DeveloperError, freezeObject) {
  'use strict';
  function Plane(normal, distance) {
    if (!defined(normal)) {
      throw new DeveloperError('normal is required.');
    }
    if (!defined(distance)) {
      throw new DeveloperError('distance is required.');
    }
    this.normal = Cartesian3.clone(normal);
    this.distance = distance;
  }
  Plane.fromPointNormal = function(point, normal, result) {
    if (!defined(point)) {
      throw new DeveloperError('point is required.');
    }
    if (!defined(normal)) {
      throw new DeveloperError('normal is required.');
    }
    var distance = -Cartesian3.dot(normal, point);
    if (!defined(result)) {
      return new Plane(normal, distance);
    }
    Cartesian3.clone(normal, result.normal);
    result.distance = distance;
    return result;
  };
  var scratchNormal = new Cartesian3();
  Plane.fromCartesian4 = function(coefficients, result) {
    if (!defined(coefficients)) {
      throw new DeveloperError('coefficients is required.');
    }
    var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);
    var distance = coefficients.w;
    if (!defined(result)) {
      return new Plane(normal, distance);
    } else {
      Cartesian3.clone(normal, result.normal);
      result.distance = distance;
      return result;
    }
  };
  Plane.getPointDistance = function(plane, point) {
    if (!defined(plane)) {
      throw new DeveloperError('plane is required.');
    }
    if (!defined(point)) {
      throw new DeveloperError('point is required.');
    }
    return Cartesian3.dot(plane.normal, point) + plane.distance;
  };
  Plane.ORIGIN_XY_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Z, 0.0));
  Plane.ORIGIN_YZ_PLANE = freezeObject(new Plane(Cartesian3.UNIT_X, 0.0));
  Plane.ORIGIN_ZX_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Y, 0.0));
  return Plane;
});

})();
(function() {
var define = $__System.amdDefine;
define("5c", ["53", "a", "1f", "41", "15", "5", "7", "42", "5b", "33", "55", "d", "27", "34", "4d"], function(BoundingSphere, Cartesian2, Cartesian3, Cartographic, defaultValue, defined, DeveloperError, Ellipsoid, EllipsoidTangentPlane, Intersect, Interval, CesiumMath, Matrix3, Plane, Rectangle) {
  'use strict';
  function OrientedBoundingBox(center, halfAxes) {
    this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));
    this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));
  }
  var scratchCartesian1 = new Cartesian3();
  var scratchCartesian2 = new Cartesian3();
  var scratchCartesian3 = new Cartesian3();
  var scratchCartesian4 = new Cartesian3();
  var scratchCartesian5 = new Cartesian3();
  var scratchCartesian6 = new Cartesian3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  };
  OrientedBoundingBox.fromPoints = function(positions, result) {
    if (!defined(result)) {
      result = new OrientedBoundingBox();
    }
    if (!defined(positions) || positions.length === 0) {
      result.halfAxes = Matrix3.ZERO;
      result.center = Cartesian3.ZERO;
      return result;
    }
    var i;
    var length = positions.length;
    var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);
    for (i = 1; i < length; i++) {
      Cartesian3.add(meanPoint, positions[i], meanPoint);
    }
    var invLength = 1.0 / length;
    Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);
    var exx = 0.0;
    var exy = 0.0;
    var exz = 0.0;
    var eyy = 0.0;
    var eyz = 0.0;
    var ezz = 0.0;
    var p;
    for (i = 0; i < length; i++) {
      p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);
      exx += p.x * p.x;
      exy += p.x * p.y;
      exz += p.x * p.z;
      eyy += p.y * p.y;
      eyz += p.y * p.z;
      ezz += p.z * p.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    var covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    var eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
    var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);
    var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);
    var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);
    var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);
    var u1 = -Number.MAX_VALUE;
    var u2 = -Number.MAX_VALUE;
    var u3 = -Number.MAX_VALUE;
    var l1 = Number.MAX_VALUE;
    var l2 = Number.MAX_VALUE;
    var l3 = Number.MAX_VALUE;
    for (i = 0; i < length; i++) {
      p = positions[i];
      u1 = Math.max(Cartesian3.dot(v1, p), u1);
      u2 = Math.max(Cartesian3.dot(v2, p), u2);
      u3 = Math.max(Cartesian3.dot(v3, p), u3);
      l1 = Math.min(Cartesian3.dot(v1, p), l1);
      l2 = Math.min(Cartesian3.dot(v2, p), l2);
      l3 = Math.min(Cartesian3.dot(v3, p), l3);
    }
    v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);
    v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);
    v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);
    var center = Cartesian3.add(v1, v2, result.center);
    center = Cartesian3.add(center, v3, center);
    var scale = scratchCartesian3;
    scale.x = u1 - l1;
    scale.y = u2 - l2;
    scale.z = u3 - l3;
    Cartesian3.multiplyByScalar(scale, 0.5, scale);
    Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);
    return result;
  };
  var scratchOffset = new Cartesian3();
  var scratchScale = new Cartesian3();
  function fromTangentPlaneExtents(tangentPlane, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {
    if (!defined(minimumX) || !defined(maximumX) || !defined(minimumY) || !defined(maximumY) || !defined(minimumZ) || !defined(maximumZ)) {
      throw new DeveloperError('all extents (minimum/maximum X/Y/Z) are required.');
    }
    if (!defined(result)) {
      result = new OrientedBoundingBox();
    }
    var halfAxes = result.halfAxes;
    Matrix3.setColumn(halfAxes, 0, tangentPlane.xAxis, halfAxes);
    Matrix3.setColumn(halfAxes, 1, tangentPlane.yAxis, halfAxes);
    Matrix3.setColumn(halfAxes, 2, tangentPlane.zAxis, halfAxes);
    var centerOffset = scratchOffset;
    centerOffset.x = (minimumX + maximumX) / 2.0;
    centerOffset.y = (minimumY + maximumY) / 2.0;
    centerOffset.z = (minimumZ + maximumZ) / 2.0;
    var scale = scratchScale;
    scale.x = (maximumX - minimumX) / 2.0;
    scale.y = (maximumY - minimumY) / 2.0;
    scale.z = (maximumZ - minimumZ) / 2.0;
    var center = result.center;
    centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);
    Cartesian3.add(tangentPlane.origin, centerOffset, center);
    Matrix3.multiplyByScale(halfAxes, scale, halfAxes);
    return result;
  }
  var scratchRectangleCenterCartographic = new Cartographic();
  var scratchRectangleCenter = new Cartesian3();
  var perimeterCartographicScratch = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];
  var perimeterCartesianScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];
  var perimeterProjectedScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2()];
  OrientedBoundingBox.fromRectangle = function(rectangle, minimumHeight, maximumHeight, ellipsoid, result) {
    if (!defined(rectangle)) {
      throw new DeveloperError('rectangle is required');
    }
    if (rectangle.width < 0.0 || rectangle.width > CesiumMath.PI) {
      throw new DeveloperError('Rectangle width must be between 0 and pi');
    }
    if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {
      throw new DeveloperError('Rectangle height must be between 0 and pi');
    }
    if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {
      throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');
    }
    minimumHeight = defaultValue(minimumHeight, 0.0);
    maximumHeight = defaultValue(maximumHeight, 0.0);
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);
    var tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);
    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);
    var plane = tangentPlane.plane;
    var perimeterNW = perimeterCartographicScratch[0];
    var perimeterNC = perimeterCartographicScratch[1];
    var perimeterNE = perimeterCartographicScratch[2];
    var perimeterCE = perimeterCartographicScratch[3];
    var perimeterSE = perimeterCartographicScratch[4];
    var perimeterSC = perimeterCartographicScratch[5];
    var perimeterSW = perimeterCartographicScratch[6];
    var perimeterCW = perimeterCartographicScratch[7];
    var lonCenter = tangentPointCartographic.longitude;
    var latCenter = (rectangle.south < 0.0 && rectangle.north > 0.0) ? 0.0 : tangentPointCartographic.latitude;
    perimeterSW.latitude = perimeterSC.latitude = perimeterSE.latitude = rectangle.south;
    perimeterCW.latitude = perimeterCE.latitude = latCenter;
    perimeterNW.latitude = perimeterNC.latitude = perimeterNE.latitude = rectangle.north;
    perimeterSW.longitude = perimeterCW.longitude = perimeterNW.longitude = rectangle.west;
    perimeterSC.longitude = perimeterNC.longitude = lonCenter;
    perimeterSE.longitude = perimeterCE.longitude = perimeterNE.longitude = rectangle.east;
    perimeterNE.height = perimeterNC.height = perimeterNW.height = perimeterCW.height = perimeterSW.height = perimeterSC.height = perimeterSE.height = perimeterCE.height = maximumHeight;
    ellipsoid.cartographicArrayToCartesianArray(perimeterCartographicScratch, perimeterCartesianScratch);
    tangentPlane.projectPointsToNearestOnPlane(perimeterCartesianScratch, perimeterProjectedScratch);
    var minX = Math.min(perimeterProjectedScratch[6].x, perimeterProjectedScratch[7].x, perimeterProjectedScratch[0].x);
    var maxX = Math.max(perimeterProjectedScratch[2].x, perimeterProjectedScratch[3].x, perimeterProjectedScratch[4].x);
    var minY = Math.min(perimeterProjectedScratch[4].y, perimeterProjectedScratch[5].y, perimeterProjectedScratch[6].y);
    var maxY = Math.max(perimeterProjectedScratch[0].y, perimeterProjectedScratch[1].y, perimeterProjectedScratch[2].y);
    perimeterNE.height = perimeterNW.height = perimeterSE.height = perimeterSW.height = minimumHeight;
    ellipsoid.cartographicArrayToCartesianArray(perimeterCartographicScratch, perimeterCartesianScratch);
    var minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianScratch[0]), Plane.getPointDistance(plane, perimeterCartesianScratch[2]), Plane.getPointDistance(plane, perimeterCartesianScratch[4]), Plane.getPointDistance(plane, perimeterCartesianScratch[6]));
    var maxZ = maximumHeight;
    return fromTangentPlaneExtents(tangentPlane, minX, maxX, minY, maxY, minZ, maxZ, result);
  };
  OrientedBoundingBox.clone = function(box, result) {
    if (!defined(box)) {
      return undefined;
    }
    if (!defined(result)) {
      return new OrientedBoundingBox(box.center, box.halfAxes);
    }
    Cartesian3.clone(box.center, result.center);
    Matrix3.clone(box.halfAxes, result.halfAxes);
    return result;
  };
  OrientedBoundingBox.intersectPlane = function(box, plane) {
    if (!defined(box)) {
      throw new DeveloperError('box is required.');
    }
    if (!defined(plane)) {
      throw new DeveloperError('plane is required.');
    }
    var center = box.center;
    var normal = plane.normal;
    var halfAxes = box.halfAxes;
    var normalX = normal.x,
        normalY = normal.y,
        normalZ = normal.z;
    var radEffective = Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);
    var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;
    if (distanceToPlane <= -radEffective) {
      return Intersect.OUTSIDE;
    } else if (distanceToPlane >= radEffective) {
      return Intersect.INSIDE;
    }
    return Intersect.INTERSECTING;
  };
  var scratchCartesianU = new Cartesian3();
  var scratchCartesianV = new Cartesian3();
  var scratchCartesianW = new Cartesian3();
  var scratchPPrime = new Cartesian3();
  OrientedBoundingBox.distanceSquaredTo = function(box, cartesian) {
    if (!defined(box)) {
      throw new DeveloperError('box is required.');
    }
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required.');
    }
    var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);
    var halfAxes = box.halfAxes;
    var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);
    var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);
    var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);
    var uHalf = Cartesian3.magnitude(u);
    var vHalf = Cartesian3.magnitude(v);
    var wHalf = Cartesian3.magnitude(w);
    Cartesian3.normalize(u, u);
    Cartesian3.normalize(v, v);
    Cartesian3.normalize(w, w);
    var pPrime = scratchPPrime;
    pPrime.x = Cartesian3.dot(offset, u);
    pPrime.y = Cartesian3.dot(offset, v);
    pPrime.z = Cartesian3.dot(offset, w);
    var distanceSquared = 0.0;
    var d;
    if (pPrime.x < -uHalf) {
      d = pPrime.x + uHalf;
      distanceSquared += d * d;
    } else if (pPrime.x > uHalf) {
      d = pPrime.x - uHalf;
      distanceSquared += d * d;
    }
    if (pPrime.y < -vHalf) {
      d = pPrime.y + vHalf;
      distanceSquared += d * d;
    } else if (pPrime.y > vHalf) {
      d = pPrime.y - vHalf;
      distanceSquared += d * d;
    }
    if (pPrime.z < -wHalf) {
      d = pPrime.z + wHalf;
      distanceSquared += d * d;
    } else if (pPrime.z > wHalf) {
      d = pPrime.z - wHalf;
      distanceSquared += d * d;
    }
    return distanceSquared;
  };
  var scratchCorner = new Cartesian3();
  var scratchToCenter = new Cartesian3();
  OrientedBoundingBox.computePlaneDistances = function(box, position, direction, result) {
    if (!defined(box)) {
      throw new DeveloperError('box is required.');
    }
    if (!defined(position)) {
      throw new DeveloperError('position is required.');
    }
    if (!defined(direction)) {
      throw new DeveloperError('direction is required.');
    }
    if (!defined(result)) {
      result = new Interval();
    }
    var minDist = Number.POSITIVE_INFINITY;
    var maxDist = Number.NEGATIVE_INFINITY;
    var center = box.center;
    var halfAxes = box.halfAxes;
    var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);
    var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);
    var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);
    var corner = Cartesian3.add(u, v, scratchCorner);
    Cartesian3.add(corner, w, corner);
    Cartesian3.add(corner, center, corner);
    var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);
    var mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.add(center, u, corner);
    Cartesian3.add(corner, v, corner);
    Cartesian3.subtract(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.add(center, u, corner);
    Cartesian3.subtract(corner, v, corner);
    Cartesian3.add(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.add(center, u, corner);
    Cartesian3.subtract(corner, v, corner);
    Cartesian3.subtract(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.subtract(center, u, corner);
    Cartesian3.add(corner, v, corner);
    Cartesian3.add(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.subtract(center, u, corner);
    Cartesian3.add(corner, v, corner);
    Cartesian3.subtract(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.subtract(center, u, corner);
    Cartesian3.subtract(corner, v, corner);
    Cartesian3.add(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    Cartesian3.subtract(center, u, corner);
    Cartesian3.subtract(corner, v, corner);
    Cartesian3.subtract(corner, w, corner);
    Cartesian3.subtract(corner, position, toCenter);
    mag = Cartesian3.dot(direction, toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    result.start = minDist;
    result.stop = maxDist;
    return result;
  };
  var scratchBoundingSphere = new BoundingSphere();
  OrientedBoundingBox.isOccluded = function(box, occluder) {
    if (!defined(box)) {
      throw new DeveloperError('box is required.');
    }
    if (!defined(occluder)) {
      throw new DeveloperError('occluder is required.');
    }
    var sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);
    return !occluder.isBoundingSphereVisible(sphere);
  };
  OrientedBoundingBox.prototype.intersectPlane = function(plane) {
    return OrientedBoundingBox.intersectPlane(this, plane);
  };
  OrientedBoundingBox.prototype.distanceSquaredTo = function(cartesian) {
    return OrientedBoundingBox.distanceSquaredTo(this, cartesian);
  };
  OrientedBoundingBox.prototype.computePlaneDistances = function(position, direction, result) {
    return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);
  };
  OrientedBoundingBox.prototype.isOccluded = function(occluder) {
    return OrientedBoundingBox.isOccluded(this, occluder);
  };
  OrientedBoundingBox.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && Cartesian3.equals(left.center, right.center) && Matrix3.equals(left.halfAxes, right.halfAxes));
  };
  OrientedBoundingBox.prototype.clone = function(result) {
    return OrientedBoundingBox.clone(this, result);
  };
  OrientedBoundingBox.prototype.equals = function(right) {
    return OrientedBoundingBox.equals(this, right);
  };
  return OrientedBoundingBox;
});

})();
(function() {
var define = $__System.amdDefine;
define("5d", ["48", "3b", "15", "5", "5e", "11", "17", "5f", "60", "2c", "3e", "3f"], function(when, binarySearch, defaultValue, defined, EarthOrientationParametersSample, freezeObject, JulianDate, LeapSecond, loadJson, RuntimeError, TimeConstants, TimeStandard) {
  'use strict';
  function EarthOrientationParameters(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._dates = undefined;
    this._samples = undefined;
    this._dateColumn = -1;
    this._xPoleWanderRadiansColumn = -1;
    this._yPoleWanderRadiansColumn = -1;
    this._ut1MinusUtcSecondsColumn = -1;
    this._xCelestialPoleOffsetRadiansColumn = -1;
    this._yCelestialPoleOffsetRadiansColumn = -1;
    this._taiMinusUtcSecondsColumn = -1;
    this._columnCount = 0;
    this._lastIndex = -1;
    this._downloadPromise = undefined;
    this._dataError = undefined;
    this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);
    if (defined(options.data)) {
      onDataReady(this, options.data);
    } else if (defined(options.url)) {
      var that = this;
      this._downloadPromise = when(loadJson(options.url), function(eopData) {
        onDataReady(that, eopData);
      }, function() {
        that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';
      });
    } else {
      onDataReady(this, {
        'columnNames': ['dateIso8601', 'modifiedJulianDateUtc', 'xPoleWanderRadians', 'yPoleWanderRadians', 'ut1MinusUtcSeconds', 'lengthOfDayCorrectionSeconds', 'xCelestialPoleOffsetRadians', 'yCelestialPoleOffsetRadians', 'taiMinusUtcSeconds'],
        'samples': []
      });
    }
  }
  EarthOrientationParameters.NONE = freezeObject({
    getPromiseToLoad: function() {
      return when();
    },
    compute: function(date, result) {
      if (!defined(result)) {
        result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
      } else {
        result.xPoleWander = 0.0;
        result.yPoleWander = 0.0;
        result.xPoleOffset = 0.0;
        result.yPoleOffset = 0.0;
        result.ut1MinusUtc = 0.0;
      }
      return result;
    }
  });
  EarthOrientationParameters.prototype.getPromiseToLoad = function() {
    return when(this._downloadPromise);
  };
  EarthOrientationParameters.prototype.compute = function(date, result) {
    if (!defined(this._samples)) {
      if (defined(this._dataError)) {
        throw new RuntimeError(this._dataError);
      }
      return undefined;
    }
    if (!defined(result)) {
      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
    }
    if (this._samples.length === 0) {
      result.xPoleWander = 0.0;
      result.yPoleWander = 0.0;
      result.xPoleOffset = 0.0;
      result.yPoleOffset = 0.0;
      result.ut1MinusUtc = 0.0;
      return result;
    }
    var dates = this._dates;
    var lastIndex = this._lastIndex;
    var before = 0;
    var after = 0;
    if (defined(lastIndex)) {
      var previousIndexDate = dates[lastIndex];
      var nextIndexDate = dates[lastIndex + 1];
      var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);
      var isAfterLastSample = !defined(nextIndexDate);
      var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);
      if (isAfterPrevious && isBeforeNext) {
        before = lastIndex;
        if (!isAfterLastSample && nextIndexDate.equals(date)) {
          ++before;
        }
        after = before + 1;
        interpolate(this, dates, this._samples, date, before, after, result);
        return result;
      }
    }
    var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
    if (index >= 0) {
      if (index < dates.length - 1 && dates[index + 1].equals(date)) {
        ++index;
      }
      before = index;
      after = index;
    } else {
      after = ~index;
      before = after - 1;
      if (before < 0) {
        before = 0;
      }
    }
    this._lastIndex = before;
    interpolate(this, dates, this._samples, date, before, after, result);
    return result;
  };
  function compareLeapSecondDates(leapSecond, dateToFind) {
    return JulianDate.compare(leapSecond.julianDate, dateToFind);
  }
  function onDataReady(eop, eopData) {
    if (!defined(eopData.columnNames)) {
      eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';
      return;
    }
    if (!defined(eopData.samples)) {
      eop._dataError = 'Error in loaded EOP data: The samples property is required.';
      return;
    }
    var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');
    var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');
    var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');
    var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');
    var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');
    var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');
    var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');
    if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
      eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';
      return;
    }
    var samples = eop._samples = eopData.samples;
    var dates = eop._dates = [];
    eop._dateColumn = dateColumn;
    eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
    eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
    eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
    eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
    eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
    eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;
    eop._columnCount = eopData.columnNames.length;
    eop._lastIndex = undefined;
    var lastTaiMinusUtc;
    var addNewLeapSeconds = eop._addNewLeapSeconds;
    for (var i = 0,
        len = samples.length; i < len; i += eop._columnCount) {
      var mjd = samples[i + dateColumn];
      var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
      var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;
      var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);
      dates.push(date);
      if (addNewLeapSeconds) {
        if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
          var leapSeconds = JulianDate.leapSeconds;
          var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);
          if (leapSecondIndex < 0) {
            var leapSecond = new LeapSecond(date, taiMinusUtc);
            leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
          }
        }
        lastTaiMinusUtc = taiMinusUtc;
      }
    }
  }
  function fillResultFromIndex(eop, samples, index, columnCount, result) {
    var start = index * columnCount;
    result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
    result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
    result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
    result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
    result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
  }
  function linearInterp(dx, y1, y2) {
    return y1 + dx * (y2 - y1);
  }
  function interpolate(eop, dates, samples, date, before, after, result) {
    var columnCount = eop._columnCount;
    if (after > dates.length - 1) {
      result.xPoleWander = 0;
      result.yPoleWander = 0;
      result.xPoleOffset = 0;
      result.yPoleOffset = 0;
      result.ut1MinusUtc = 0;
      return result;
    }
    var beforeDate = dates[before];
    var afterDate = dates[after];
    if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
      fillResultFromIndex(eop, samples, before, columnCount, result);
      return result;
    } else if (date.equals(afterDate)) {
      fillResultFromIndex(eop, samples, after, columnCount, result);
      return result;
    }
    var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);
    var startBefore = before * columnCount;
    var startAfter = after * columnCount;
    var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
    var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];
    var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
    if (offsetDifference > 0.5 || offsetDifference < -0.5) {
      var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
      var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
      if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
        if (afterDate.equals(date)) {
          beforeUt1MinusUtc = afterUt1MinusUtc;
        } else {
          afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
        }
      }
    }
    result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);
    result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);
    result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);
    result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);
    result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);
    return result;
  }
  return EarthOrientationParameters;
});

})();
(function() {
var define = $__System.amdDefine;
define("5e", [], function() {
  'use strict';
  function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
    this.xPoleWander = xPoleWander;
    this.yPoleWander = yPoleWander;
    this.xPoleOffset = xPoleOffset;
    this.yPoleOffset = yPoleOffset;
    this.ut1MinusUtc = ut1MinusUtc;
  }
  return EarthOrientationParametersSample;
});

})();
(function() {
var define = $__System.amdDefine;
define("61", ["15"], function(defaultValue) {
  'use strict';
  function clone(object, deep) {
    if (object === null || typeof object !== 'object') {
      return object;
    }
    deep = defaultValue(deep, false);
    var result = new object.constructor();
    for (var propertyName in object) {
      if (object.hasOwnProperty(propertyName)) {
        var value = object[propertyName];
        if (deep) {
          value = clone(value, deep);
        }
        result[propertyName] = value;
      }
    }
    return result;
  }
  return clone;
});

})();
(function() {
var define = $__System.amdDefine;
define("62", [], function() {
  'use strict';
  function parseResponseHeaders(headerString) {
    var headers = {};
    if (!headerString) {
      return headers;
    }
    var headerPairs = headerString.split('\u000d\u000a');
    for (var i = 0; i < headerPairs.length; ++i) {
      var headerPair = headerPairs[i];
      var index = headerPair.indexOf('\u003a\u0020');
      if (index > 0) {
        var key = headerPair.substring(0, index);
        var val = headerPair.substring(index + 2);
        headers[key] = val;
      }
    }
    return headers;
  }
  return parseResponseHeaders;
});

})();
(function() {
var define = $__System.amdDefine;
define("63", ["5", "62"], function(defined, parseResponseHeaders) {
  'use strict';
  function RequestErrorEvent(statusCode, response, responseHeaders) {
    this.statusCode = statusCode;
    this.response = response;
    this.responseHeaders = responseHeaders;
    if (typeof this.responseHeaders === 'string') {
      this.responseHeaders = parseResponseHeaders(this.responseHeaders);
    }
  }
  RequestErrorEvent.prototype.toString = function() {
    var str = 'Request has failed.';
    if (defined(this.statusCode)) {
      str += ' Status Code: ' + this.statusCode;
    }
    return str;
  };
  return RequestErrorEvent;
});

})();
(function() {
var define = $__System.amdDefine;
define("4b", ["47", "5", "7"], function(Uri, defined, DeveloperError) {
  'use strict';
  var TrustedServers = {};
  var _servers = {};
  TrustedServers.add = function(host, port) {
    if (!defined(host)) {
      throw new DeveloperError('host is required.');
    }
    if (!defined(port) || port <= 0) {
      throw new DeveloperError('port is required to be greater than 0.');
    }
    var authority = host.toLowerCase() + ':' + port;
    if (!defined(_servers[authority])) {
      _servers[authority] = true;
    }
  };
  TrustedServers.remove = function(host, port) {
    if (!defined(host)) {
      throw new DeveloperError('host is required.');
    }
    if (!defined(port) || port <= 0) {
      throw new DeveloperError('port is required to be greater than 0.');
    }
    var authority = host.toLowerCase() + ':' + port;
    if (defined(_servers[authority])) {
      delete _servers[authority];
    }
  };
  function getAuthority(url) {
    var uri = new Uri(url);
    uri.normalize();
    var authority = uri.getAuthority();
    if (!defined(authority)) {
      return undefined;
    }
    if (authority.indexOf('@') !== -1) {
      var parts = authority.split('@');
      authority = parts[1];
    }
    if (authority.indexOf(':') === -1) {
      var scheme = uri.getScheme();
      if (!defined(scheme)) {
        scheme = window.location.protocol;
        scheme = scheme.substring(0, scheme.length - 1);
      }
      if (scheme === 'http') {
        authority += ':80';
      } else if (scheme === 'https') {
        authority += ':443';
      } else {
        return undefined;
      }
    }
    return authority;
  }
  TrustedServers.contains = function(url) {
    if (!defined(url)) {
      throw new DeveloperError('url is required.');
    }
    var authority = getAuthority(url);
    if (defined(authority) && defined(_servers[authority])) {
      return true;
    }
    return false;
  };
  TrustedServers.clear = function() {
    _servers = {};
  };
  return TrustedServers;
});

})();
(function() {
var define = $__System.amdDefine;
define("64", ["48", "15", "5", "7", "63", "2c", "4b"], function(when, defaultValue, defined, DeveloperError, RequestErrorEvent, RuntimeError, TrustedServers) {
  'use strict';
  function loadWithXhr(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.url)) {
      throw new DeveloperError('options.url is required.');
    }
    var responseType = options.responseType;
    var method = defaultValue(options.method, 'GET');
    var data = options.data;
    var headers = options.headers;
    var overrideMimeType = options.overrideMimeType;
    return when(options.url, function(url) {
      var deferred = when.defer();
      loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType);
      return deferred.promise;
    });
  }
  var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  function decodeDataUriText(isBase64, data) {
    var result = decodeURIComponent(data);
    if (isBase64) {
      return atob(result);
    }
    return result;
  }
  function decodeDataUriArrayBuffer(isBase64, data) {
    var byteString = decodeDataUriText(isBase64, data);
    var buffer = new ArrayBuffer(byteString.length);
    var view = new Uint8Array(buffer);
    for (var i = 0; i < byteString.length; i++) {
      view[i] = byteString.charCodeAt(i);
    }
    return buffer;
  }
  function decodeDataUri(dataUriRegexResult, responseType) {
    responseType = defaultValue(responseType, '');
    var mimeType = dataUriRegexResult[1];
    var isBase64 = !!dataUriRegexResult[2];
    var data = dataUriRegexResult[3];
    switch (responseType) {
      case '':
      case 'text':
        return decodeDataUriText(isBase64, data);
      case 'arraybuffer':
        return decodeDataUriArrayBuffer(isBase64, data);
      case 'blob':
        var buffer = decodeDataUriArrayBuffer(isBase64, data);
        return new Blob([buffer], {type: mimeType});
      case 'document':
        var parser = new DOMParser();
        return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
      case 'json':
        return JSON.parse(decodeDataUriText(isBase64, data));
      default:
        throw new DeveloperError('Unhandled responseType: ' + responseType);
    }
  }
  loadWithXhr.load = function(url, responseType, method, data, headers, deferred, overrideMimeType) {
    var dataUriRegexResult = dataUriRegex.exec(url);
    if (dataUriRegexResult !== null) {
      deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
      return;
    }
    var xhr = new XMLHttpRequest();
    if (TrustedServers.contains(url)) {
      xhr.withCredentials = true;
    }
    if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {
      xhr.overrideMimeType(overrideMimeType);
    }
    xhr.open(method, url, true);
    if (defined(headers)) {
      for (var key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    }
    if (defined(responseType)) {
      xhr.responseType = responseType;
    }
    xhr.onload = function() {
      if (xhr.status < 200 || xhr.status >= 300) {
        deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));
        return;
      }
      var response = xhr.response;
      var browserResponseType = xhr.responseType;
      if (defined(response) && (!defined(responseType) || (browserResponseType === responseType))) {
        deferred.resolve(response);
      } else if ((responseType === 'json') && typeof response === 'string') {
        try {
          deferred.resolve(JSON.parse(response));
        } catch (e) {
          deferred.reject(e);
        }
      } else if ((browserResponseType === '' || browserResponseType === 'document') && defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
        deferred.resolve(xhr.responseXML);
      } else if ((browserResponseType === '' || browserResponseType === 'text') && defined(xhr.responseText)) {
        deferred.resolve(xhr.responseText);
      } else {
        deferred.reject(new RuntimeError('Invalid XMLHttpRequest response type.'));
      }
    };
    xhr.onerror = function(e) {
      deferred.reject(new RequestErrorEvent());
    };
    xhr.send(data);
  };
  loadWithXhr.defaultLoad = loadWithXhr.load;
  return loadWithXhr;
});

})();
(function() {
var define = $__System.amdDefine;
define("65", ["64"], function(loadWithXhr) {
  'use strict';
  function loadText(url, headers) {
    return loadWithXhr({
      url: url,
      headers: headers
    });
  }
  return loadText;
});

})();
(function() {
var define = $__System.amdDefine;
define("60", ["61", "5", "7", "65"], function(clone, defined, DeveloperError, loadText) {
  'use strict';
  var defaultHeaders = {Accept: 'application/json,*/*;q=0.01'};
  function loadJson(url, headers) {
    if (!defined(url)) {
      throw new DeveloperError('url is required.');
    }
    if (!defined(headers)) {
      headers = defaultHeaders;
    } else if (!defined(headers.Accept)) {
      headers = clone(headers);
      headers.Accept = defaultHeaders.Accept;
    }
    return loadText(url, headers).then(function(value) {
      return JSON.parse(value);
    });
  }
  return loadJson;
});

})();
(function() {
var define = $__System.amdDefine;
define("66", ["48", "67", "15", "5", "68", "17", "60", "3f"], function(when, buildModuleUrl, defaultValue, defined, Iau2006XysSample, JulianDate, loadJson, TimeStandard) {
  'use strict';
  function Iau2006XysData(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._xysFileUrlTemplate = options.xysFileUrlTemplate;
    this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
    this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);
    this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0.0, TimeStandard.TAI);
    this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);
    this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
    this._totalSamples = defaultValue(options.totalSamples, 27426);
    this._samples = new Array(this._totalSamples * 3);
    this._chunkDownloadsInProgress = [];
    var order = this._interpolationOrder;
    var denom = this._denominators = new Array(order + 1);
    var xTable = this._xTable = new Array(order + 1);
    var stepN = Math.pow(this._stepSizeDays, order);
    for (var i = 0; i <= order; ++i) {
      denom[i] = stepN;
      xTable[i] = i * this._stepSizeDays;
      for (var j = 0; j <= order; ++j) {
        if (j !== i) {
          denom[i] *= (i - j);
        }
      }
      denom[i] = 1.0 / denom[i];
    }
    this._work = new Array(order + 1);
    this._coef = new Array(order + 1);
  }
  var julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);
  function getDaysSinceEpoch(xys, dayTT, secondTT) {
    var dateTT = julianDateScratch;
    dateTT.dayNumber = dayTT;
    dateTT.secondsOfDay = secondTT;
    return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
  }
  Iau2006XysData.prototype.preload = function(startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
    var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);
    var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);
    var startIndex = (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0;
    if (startIndex < 0) {
      startIndex = 0;
    }
    var stopIndex = (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0 + this._interpolationOrder;
    if (stopIndex >= this._totalSamples) {
      stopIndex = this._totalSamples - 1;
    }
    var startChunk = (startIndex / this._samplesPerXysFile) | 0;
    var stopChunk = (stopIndex / this._samplesPerXysFile) | 0;
    var promises = [];
    for (var i = startChunk; i <= stopChunk; ++i) {
      promises.push(requestXysChunk(this, i));
    }
    return when.all(promises);
  };
  Iau2006XysData.prototype.computeXysRadians = function(dayTT, secondTT, result) {
    var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
    if (daysSinceEpoch < 0.0) {
      return undefined;
    }
    var centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;
    if (centerIndex >= this._totalSamples) {
      return undefined;
    }
    var degree = this._interpolationOrder;
    var firstIndex = centerIndex - ((degree / 2) | 0);
    if (firstIndex < 0) {
      firstIndex = 0;
    }
    var lastIndex = firstIndex + degree;
    if (lastIndex >= this._totalSamples) {
      lastIndex = this._totalSamples - 1;
      firstIndex = lastIndex - degree;
      if (firstIndex < 0) {
        firstIndex = 0;
      }
    }
    var isDataMissing = false;
    var samples = this._samples;
    if (!defined(samples[firstIndex * 3])) {
      requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);
      isDataMissing = true;
    }
    if (!defined(samples[lastIndex * 3])) {
      requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);
      isDataMissing = true;
    }
    if (isDataMissing) {
      return undefined;
    }
    if (!defined(result)) {
      result = new Iau2006XysSample(0.0, 0.0, 0.0);
    } else {
      result.x = 0.0;
      result.y = 0.0;
      result.s = 0.0;
    }
    var x = daysSinceEpoch - firstIndex * this._stepSizeDays;
    var work = this._work;
    var denom = this._denominators;
    var coef = this._coef;
    var xTable = this._xTable;
    var i,
        j;
    for (i = 0; i <= degree; ++i) {
      work[i] = x - xTable[i];
    }
    for (i = 0; i <= degree; ++i) {
      coef[i] = 1.0;
      for (j = 0; j <= degree; ++j) {
        if (j !== i) {
          coef[i] *= work[j];
        }
      }
      coef[i] *= denom[i];
      var sampleIndex = (firstIndex + i) * 3;
      result.x += coef[i] * samples[sampleIndex++];
      result.y += coef[i] * samples[sampleIndex++];
      result.s += coef[i] * samples[sampleIndex];
    }
    return result;
  };
  function requestXysChunk(xysData, chunkIndex) {
    if (xysData._chunkDownloadsInProgress[chunkIndex]) {
      return xysData._chunkDownloadsInProgress[chunkIndex];
    }
    var deferred = when.defer();
    xysData._chunkDownloadsInProgress[chunkIndex] = deferred;
    var chunkUrl;
    var xysFileUrlTemplate = xysData._xysFileUrlTemplate;
    if (defined(xysFileUrlTemplate)) {
      chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);
    } else {
      chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');
    }
    when(loadJson(chunkUrl), function(chunk) {
      xysData._chunkDownloadsInProgress[chunkIndex] = false;
      var samples = xysData._samples;
      var newSamples = chunk.samples;
      var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;
      for (var i = 0,
          len = newSamples.length; i < len; ++i) {
        samples[startIndex + i] = newSamples[i];
      }
      deferred.resolve();
    });
    return deferred.promise;
  }
  return Iau2006XysData;
});

})();
(function() {
var define = $__System.amdDefine;
define("68", [], function() {
  'use strict';
  function Iau2006XysSample(x, y, s) {
    this.x = x;
    this.y = y;
    this.s = s;
  }
  return Iau2006XysSample;
});

})();
(function() {
var define = $__System.amdDefine;
define("69", [], function() {
  function sprintf() {
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
    var a = arguments,
        i = 0,
        format = a[i++];
    var pad = function(str, len, chr, leftJustify) {
      if (!chr) {
        chr = ' ';
      }
      var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
      return leftJustify ? str + padding : padding + str;
    };
    var justify = function(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
      var diff = minWidth - value.length;
      if (diff > 0) {
        if (leftJustify || !zeroPad) {
          value = pad(value, minWidth, customPadChar, leftJustify);
        } else {
          value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
        }
      }
      return value;
    };
    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
      var number = value >>> 0;
      prefix = prefix && number && {
        '2': '0b',
        '8': '0',
        '16': '0x'
      }[base] || '';
      value = prefix + pad(number.toString(base), precision || 0, '0', false);
      return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };
    var formatString = function(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
      if (precision != null) {
        value = value.slice(0, precision);
      }
      return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };
    var doFormat = function(substring, valueIndex, flags, minWidth, _, precision, type) {
      var number;
      var prefix;
      var method;
      var textTransform;
      var value;
      if (substring == '%%') {
        return '%';
      }
      var leftJustify = false,
          positivePrefix = '',
          zeroPad = false,
          prefixBaseX = false,
          customPadChar = ' ';
      var flagsl = flags.length;
      for (var j = 0; flags && j < flagsl; j++) {
        switch (flags.charAt(j)) {
          case ' ':
            positivePrefix = ' ';
            break;
          case '+':
            positivePrefix = '+';
            break;
          case '-':
            leftJustify = true;
            break;
          case "'":
            customPadChar = flags.charAt(j + 1);
            break;
          case '0':
            zeroPad = true;
            break;
          case '#':
            prefixBaseX = true;
            break;
        }
      }
      if (!minWidth) {
        minWidth = 0;
      } else if (minWidth == '*') {
        minWidth = +a[i++];
      } else if (minWidth.charAt(0) == '*') {
        minWidth = +a[minWidth.slice(1, -1)];
      } else {
        minWidth = +minWidth;
      }
      if (minWidth < 0) {
        minWidth = -minWidth;
        leftJustify = true;
      }
      if (!isFinite(minWidth)) {
        throw new Error('sprintf: (minimum-)width must be finite');
      }
      if (!precision) {
        precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
      } else if (precision == '*') {
        precision = +a[i++];
      } else if (precision.charAt(0) == '*') {
        precision = +a[precision.slice(1, -1)];
      } else {
        precision = +precision;
      }
      value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
      switch (type) {
        case 's':
          return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
        case 'c':
          return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
        case 'b':
          return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'o':
          return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'x':
          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'X':
          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
        case 'u':
          return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'i':
        case 'd':
          number = +value || 0;
          number = Math.round(number - number % 1);
          prefix = number < 0 ? '-' : positivePrefix;
          value = prefix + pad(String(Math.abs(number)), precision, '0', false);
          return justify(value, prefix, leftJustify, minWidth, zeroPad);
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G':
          number = +value;
          prefix = number < 0 ? '-' : positivePrefix;
          method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
          textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
          value = prefix + Math.abs(number)[method](precision);
          return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
        default:
          return substring;
      }
    };
    return format.replace(regex, doFormat);
  }
  return sprintf;
});

})();
(function() {
var define = $__System.amdDefine;
define("3b", ["5", "7"], function(defined, DeveloperError) {
  'use strict';
  function binarySearch(array, itemToFind, comparator) {
    if (!defined(array)) {
      throw new DeveloperError('array is required.');
    }
    if (!defined(itemToFind)) {
      throw new DeveloperError('itemToFind is required.');
    }
    if (!defined(comparator)) {
      throw new DeveloperError('comparator is required.');
    }
    var low = 0;
    var high = array.length - 1;
    var i;
    var comparison;
    while (low <= high) {
      i = ~~((low + high) / 2);
      comparison = comparator(array[i], itemToFind);
      if (comparison < 0) {
        low = i + 1;
        continue;
      }
      if (comparison > 0) {
        high = i - 1;
        continue;
      }
      return i;
    }
    return ~(high + 1);
  }
  return binarySearch;
});

})();
(function() {
var define = $__System.amdDefine;
define("6a", [], function() {
  'use strict';
  function GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond) {
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    this.isLeapSecond = isLeapSecond;
  }
  return GregorianDate;
});

})();
(function() {
var define = $__System.amdDefine;
define("6b", ["7"], function(DeveloperError) {
  'use strict';
  function isLeapYear(year) {
    if (year === null || isNaN(year)) {
      throw new DeveloperError('year is required and must be a number.');
    }
    return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
  }
  return isLeapYear;
});

})();
(function() {
var define = $__System.amdDefine;
define("5f", [], function() {
  'use strict';
  function LeapSecond(date, offset) {
    this.julianDate = date;
    this.offset = offset;
  }
  return LeapSecond;
});

})();
(function() {
var define = $__System.amdDefine;
define("3f", ["11"], function(freezeObject) {
  'use strict';
  var TimeStandard = {
    UTC: 0,
    TAI: 1
  };
  return freezeObject(TimeStandard);
});

})();
(function() {
var define = $__System.amdDefine;
define("17", ["69", "3b", "15", "5", "7", "6a", "6b", "5f", "3e", "3f"], function(sprintf, binarySearch, defaultValue, defined, DeveloperError, GregorianDate, isLeapYear, LeapSecond, TimeConstants, TimeStandard) {
  'use strict';
  var gregorianDateScratch = new GregorianDate();
  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var daysInLeapFeburary = 29;
  function compareLeapSecondDates(leapSecond, dateToFind) {
    return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
  }
  var binarySearchScratchLeapSecond = new LeapSecond();
  function convertUtcToTai(julianDate) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
      index = ~index;
    }
    if (index >= leapSeconds.length) {
      index = leapSeconds.length - 1;
    }
    var offset = leapSeconds[index].offset;
    if (index > 0) {
      var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
      if (difference > offset) {
        index--;
        offset = leapSeconds[index].offset;
      }
    }
    JulianDate.addSeconds(julianDate, offset, julianDate);
  }
  function convertTaiToUtc(julianDate, result) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
      index = ~index;
    }
    if (index === 0) {
      return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
    }
    if (index >= leapSeconds.length) {
      return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);
    }
    var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
    if (difference === 0) {
      return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);
    }
    if (difference <= 1.0) {
      return undefined;
    }
    return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);
  }
  function setComponents(wholeDays, secondsOfDay, julianDate) {
    var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
    wholeDays += extraDays;
    secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;
    if (secondsOfDay < 0) {
      wholeDays--;
      secondsOfDay += TimeConstants.SECONDS_PER_DAY;
    }
    julianDate.dayNumber = wholeDays;
    julianDate.secondsOfDay = secondsOfDay;
    return julianDate;
  }
  function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
    var a = ((month - 14) / 12) | 0;
    var b = year + 4800 + a;
    var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * (((b + 100) / 100) | 0)) / 4) | 0) + day - 32075;
    hour = hour - 12;
    if (hour < 0) {
      hour += 24;
    }
    var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));
    if (secondsOfDay >= 43200.0) {
      dayNumber -= 1;
    }
    return [dayNumber, secondsOfDay];
  }
  var matchCalendarYear = /^(\d{4})$/;
  var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
  var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
  var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
  var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
  var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
  var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
  var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
  var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
  var iso8601ErrorMessage = 'Invalid ISO 8601 date.';
  function JulianDate(julianDayNumber, secondsOfDay, timeStandard) {
    this.dayNumber = undefined;
    this.secondsOfDay = undefined;
    julianDayNumber = defaultValue(julianDayNumber, 0.0);
    secondsOfDay = defaultValue(secondsOfDay, 0.0);
    timeStandard = defaultValue(timeStandard, TimeStandard.UTC);
    var wholeDays = julianDayNumber | 0;
    secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;
    setComponents(wholeDays, secondsOfDay, this);
    if (timeStandard === TimeStandard.UTC) {
      convertUtcToTai(this);
    }
  }
  JulianDate.fromDate = function(date, result) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      throw new DeveloperError('date must be a valid JavaScript Date.');
    }
    var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    if (!defined(result)) {
      return new JulianDate(components[0], components[1], TimeStandard.UTC);
    }
    setComponents(components[0], components[1], result);
    convertUtcToTai(result);
    return result;
  };
  JulianDate.fromIso8601 = function(iso8601String, result) {
    if (typeof iso8601String !== 'string') {
      throw new DeveloperError(iso8601ErrorMessage);
    }
    iso8601String = iso8601String.replace(',', '.');
    var tokens = iso8601String.split('T');
    var year;
    var month = 1;
    var day = 1;
    var hour = 0;
    var minute = 0;
    var second = 0;
    var millisecond = 0;
    var date = tokens[0];
    var time = tokens[1];
    var tmp;
    var inLeapYear;
    if (!defined(date)) {
      throw new DeveloperError(iso8601ErrorMessage);
    }
    var dashCount;
    tokens = date.match(matchCalendarDate);
    if (tokens !== null) {
      dashCount = date.split('-').length - 1;
      if (dashCount > 0 && dashCount !== 2) {
        throw new DeveloperError(iso8601ErrorMessage);
      }
      year = +tokens[1];
      month = +tokens[2];
      day = +tokens[3];
    } else {
      tokens = date.match(matchCalendarMonth);
      if (tokens !== null) {
        year = +tokens[1];
        month = +tokens[2];
      } else {
        tokens = date.match(matchCalendarYear);
        if (tokens !== null) {
          year = +tokens[1];
        } else {
          var dayOfYear;
          tokens = date.match(matchOrdinalDate);
          if (tokens !== null) {
            year = +tokens[1];
            dayOfYear = +tokens[2];
            inLeapYear = isLeapYear(year);
            if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {
              throw new DeveloperError(iso8601ErrorMessage);
            }
          } else {
            tokens = date.match(matchWeekDate);
            if (tokens !== null) {
              year = +tokens[1];
              var weekNumber = +tokens[2];
              var dayOfWeek = +tokens[3] || 0;
              dashCount = date.split('-').length - 1;
              if (dashCount > 0 && ((!defined(tokens[3]) && dashCount !== 1) || (defined(tokens[3]) && dashCount !== 2))) {
                throw new DeveloperError(iso8601ErrorMessage);
              }
              var january4 = new Date(Date.UTC(year, 0, 4));
              dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;
            } else {
              throw new DeveloperError(iso8601ErrorMessage);
            }
          }
          tmp = new Date(Date.UTC(year, 0, 1));
          tmp.setUTCDate(dayOfYear);
          month = tmp.getUTCMonth() + 1;
          day = tmp.getUTCDate();
        }
      }
    }
    inLeapYear = isLeapYear(year);
    if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {
      throw new DeveloperError(iso8601ErrorMessage);
    }
    var offsetIndex;
    if (defined(time)) {
      tokens = time.match(matchHoursMinutesSeconds);
      if (tokens !== null) {
        dashCount = time.split(':').length - 1;
        if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
          throw new DeveloperError(iso8601ErrorMessage);
        }
        hour = +tokens[1];
        minute = +tokens[2];
        second = +tokens[3];
        millisecond = +(tokens[4] || 0) * 1000.0;
        offsetIndex = 5;
      } else {
        tokens = time.match(matchHoursMinutes);
        if (tokens !== null) {
          dashCount = time.split(':').length - 1;
          if (dashCount > 2) {
            throw new DeveloperError(iso8601ErrorMessage);
          }
          hour = +tokens[1];
          minute = +tokens[2];
          second = +(tokens[3] || 0) * 60.0;
          offsetIndex = 4;
        } else {
          tokens = time.match(matchHours);
          if (tokens !== null) {
            hour = +tokens[1];
            minute = +(tokens[2] || 0) * 60.0;
            offsetIndex = 3;
          } else {
            throw new DeveloperError(iso8601ErrorMessage);
          }
        }
      }
      if (minute >= 60 || second >= 61 || hour > 24 || (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))) {
        throw new DeveloperError(iso8601ErrorMessage);
      }
      var offset = tokens[offsetIndex];
      var offsetHours = +(tokens[offsetIndex + 1]);
      var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
      switch (offset) {
        case '+':
          hour = hour - offsetHours;
          minute = minute - offsetMinutes;
          break;
        case '-':
          hour = hour + offsetHours;
          minute = minute + offsetMinutes;
          break;
        case 'Z':
          break;
        default:
          minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();
          break;
      }
    } else {
      minute = minute + new Date(year, month - 1, day).getTimezoneOffset();
    }
    var isLeapSecond = second === 60;
    if (isLeapSecond) {
      second--;
    }
    while (minute >= 60) {
      minute -= 60;
      hour++;
    }
    while (hour >= 24) {
      hour -= 24;
      day++;
    }
    tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
    while (day > tmp) {
      day -= tmp;
      month++;
      if (month > 12) {
        month -= 12;
        year++;
      }
      tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
    }
    while (minute < 0) {
      minute += 60;
      hour--;
    }
    while (hour < 0) {
      hour += 24;
      day--;
    }
    while (day < 1) {
      month--;
      if (month < 1) {
        month += 12;
        year--;
      }
      tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
      day += tmp;
    }
    var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);
    if (!defined(result)) {
      result = new JulianDate(components[0], components[1], TimeStandard.UTC);
    } else {
      setComponents(components[0], components[1], result);
      convertUtcToTai(result);
    }
    if (isLeapSecond) {
      JulianDate.addSeconds(result, 1, result);
    }
    return result;
  };
  JulianDate.now = function(result) {
    return JulianDate.fromDate(new Date(), result);
  };
  var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
  JulianDate.toGregorianDate = function(julianDate, result) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    var isLeapSecond = false;
    var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
    if (!defined(thisUtc)) {
      JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
      thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
      isLeapSecond = true;
    }
    var julianDayNumber = thisUtc.dayNumber;
    var secondsOfDay = thisUtc.secondsOfDay;
    if (secondsOfDay >= 43200.0) {
      julianDayNumber += 1;
    }
    var L = (julianDayNumber + 68569) | 0;
    var N = (4 * L / 146097) | 0;
    L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
    var I = ((4000 * (L + 1)) / 1461001) | 0;
    L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
    var J = ((80 * L) / 2447) | 0;
    var day = (L - (((2447 * J) / 80) | 0)) | 0;
    L = (J / 11) | 0;
    var month = (J + 2 - 12 * L) | 0;
    var year = (100 * (N - 49) + I + L) | 0;
    var hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
    var remainingSeconds = secondsOfDay - (hour * TimeConstants.SECONDS_PER_HOUR);
    var minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
    remainingSeconds = remainingSeconds - (minute * TimeConstants.SECONDS_PER_MINUTE);
    var second = remainingSeconds | 0;
    var millisecond = ((remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND);
    hour += 12;
    if (hour > 23) {
      hour -= 24;
    }
    if (isLeapSecond) {
      second += 1;
    }
    if (!defined(result)) {
      return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);
    }
    result.year = year;
    result.month = month;
    result.day = day;
    result.hour = hour;
    result.minute = minute;
    result.second = second;
    result.millisecond = millisecond;
    result.isLeapSecond = isLeapSecond;
    return result;
  };
  JulianDate.toDate = function(julianDate) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
    var second = gDate.second;
    if (gDate.isLeapSecond) {
      second -= 1;
    }
    return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));
  };
  JulianDate.toIso8601 = function(julianDate, precision) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    var gDate = JulianDate.toGregorianDate(julianDate, gDate);
    var millisecondStr;
    if (!defined(precision) && gDate.millisecond !== 0) {
      millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');
      return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
    }
    if (!defined(precision) || precision === 0) {
      return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);
    }
    millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);
    return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
  };
  JulianDate.clone = function(julianDate, result) {
    if (!defined(julianDate)) {
      return undefined;
    }
    if (!defined(result)) {
      return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);
    }
    result.dayNumber = julianDate.dayNumber;
    result.secondsOfDay = julianDate.secondsOfDay;
    return result;
  };
  JulianDate.compare = function(left, right) {
    if (!defined(left)) {
      throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
      throw new DeveloperError('right is required.');
    }
    var julianDayNumberDifference = left.dayNumber - right.dayNumber;
    if (julianDayNumberDifference !== 0) {
      return julianDayNumberDifference;
    }
    return left.secondsOfDay - right.secondsOfDay;
  };
  JulianDate.equals = function(left, right) {
    return (left === right) || (defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay);
  };
  JulianDate.equalsEpsilon = function(left, right, epsilon) {
    if (!defined(epsilon)) {
      throw new DeveloperError('epsilon is required.');
    }
    return (left === right) || (defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon);
  };
  JulianDate.totalDays = function(julianDate) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    return julianDate.dayNumber + (julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY);
  };
  JulianDate.secondsDifference = function(left, right) {
    if (!defined(left)) {
      throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
      throw new DeveloperError('right is required.');
    }
    var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;
    return (dayDifference + (left.secondsOfDay - right.secondsOfDay));
  };
  JulianDate.daysDifference = function(left, right) {
    if (!defined(left)) {
      throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
      throw new DeveloperError('right is required.');
    }
    var dayDifference = (left.dayNumber - right.dayNumber);
    var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
    return dayDifference + secondDifference;
  };
  JulianDate.computeTaiMinusUtc = function(julianDate) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
      index = ~index;
      --index;
      if (index < 0) {
        index = 0;
      }
    }
    return leapSeconds[index].offset;
  };
  JulianDate.addSeconds = function(julianDate, seconds, result) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    if (!defined(seconds)) {
      throw new DeveloperError('seconds is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);
  };
  JulianDate.addMinutes = function(julianDate, minutes, result) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    if (!defined(minutes)) {
      throw new DeveloperError('minutes is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var newSecondsOfDay = julianDate.secondsOfDay + (minutes * TimeConstants.SECONDS_PER_MINUTE);
    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
  };
  JulianDate.addHours = function(julianDate, hours, result) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    if (!defined(hours)) {
      throw new DeveloperError('hours is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var newSecondsOfDay = julianDate.secondsOfDay + (hours * TimeConstants.SECONDS_PER_HOUR);
    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
  };
  JulianDate.addDays = function(julianDate, days, result) {
    if (!defined(julianDate)) {
      throw new DeveloperError('julianDate is required.');
    }
    if (!defined(days)) {
      throw new DeveloperError('days is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var newJulianDayNumber = julianDate.dayNumber + days;
    return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
  };
  JulianDate.lessThan = function(left, right) {
    return JulianDate.compare(left, right) < 0;
  };
  JulianDate.lessThanOrEquals = function(left, right) {
    return JulianDate.compare(left, right) <= 0;
  };
  JulianDate.greaterThan = function(left, right) {
    return JulianDate.compare(left, right) > 0;
  };
  JulianDate.greaterThanOrEquals = function(left, right) {
    return JulianDate.compare(left, right) >= 0;
  };
  JulianDate.prototype.clone = function(result) {
    return JulianDate.clone(this, result);
  };
  JulianDate.prototype.equals = function(right) {
    return JulianDate.equals(this, right);
  };
  JulianDate.prototype.equalsEpsilon = function(right, epsilon) {
    return JulianDate.equalsEpsilon(this, right, epsilon);
  };
  JulianDate.prototype.toString = function() {
    return JulianDate.toIso8601(this);
  };
  JulianDate.leapSeconds = [new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37)];
  return JulianDate;
});

})();
(function() {
var define = $__System.amdDefine;
define("6c", ["15", "5", "7"], function(defaultValue, defined, DeveloperError) {
  "use strict";
  var warnings = {};
  function oneTimeWarning(identifier, message) {
    if (!defined(identifier)) {
      throw new DeveloperError('identifier is required.');
    }
    if (!defined(warnings[identifier])) {
      warnings[identifier] = true;
      console.warn(defaultValue(message, identifier));
    }
  }
  oneTimeWarning.geometryOutlines = 'Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.';
  return oneTimeWarning;
});

})();
(function() {
var define = $__System.amdDefine;
define("6d", ["5", "7", "6c"], function(defined, DeveloperError, oneTimeWarning) {
  'use strict';
  function deprecationWarning(identifier, message) {
    if (!defined(identifier) || !defined(message)) {
      throw new DeveloperError('identifier and message are required.');
    }
    oneTimeWarning(identifier, message);
  }
  return deprecationWarning;
});

})();
(function() {
var define = $__System.amdDefine;
define("6e", ["15", "5", "7", "d"], function(defaultValue, defined, DeveloperError, CesiumMath) {
  "use strict";
  function HeadingPitchRoll(heading, pitch, roll) {
    this.heading = defaultValue(heading, 0.0);
    this.pitch = defaultValue(pitch, 0.0);
    this.roll = defaultValue(roll, 0.0);
  }
  HeadingPitchRoll.fromQuaternion = function(quaternion, result) {
    if (!defined(quaternion)) {
      throw new DeveloperError('quaternion is required');
    }
    if (!defined(result)) {
      result = new HeadingPitchRoll();
    }
    var test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);
    var denominatorRoll = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
    var numeratorRoll = 2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);
    var denominatorHeading = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
    var numeratorHeading = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);
    result.heading = -Math.atan2(numeratorHeading, denominatorHeading);
    result.roll = Math.atan2(numeratorRoll, denominatorRoll);
    result.pitch = -Math.asin(test);
    return result;
  };
  HeadingPitchRoll.fromDegrees = function(heading, pitch, roll, result) {
    if (!defined(heading)) {
      throw new DeveloperError('heading is required');
    }
    if (!defined(pitch)) {
      throw new DeveloperError('pitch is required');
    }
    if (!defined(roll)) {
      throw new DeveloperError('roll is required');
    }
    if (!defined(result)) {
      result = new HeadingPitchRoll();
    }
    result.heading = heading * CesiumMath.RADIANS_PER_DEGREE;
    result.pitch = pitch * CesiumMath.RADIANS_PER_DEGREE;
    result.roll = roll * CesiumMath.RADIANS_PER_DEGREE;
    return result;
  };
  HeadingPitchRoll.clone = function(headingPitchRoll, result) {
    if (!defined(headingPitchRoll)) {
      return undefined;
    }
    if (!defined(result)) {
      return new HeadingPitchRoll(headingPitchRoll.heading, headingPitchRoll.pitch, headingPitchRoll.roll);
    }
    result.heading = headingPitchRoll.heading;
    result.pitch = headingPitchRoll.pitch;
    result.roll = headingPitchRoll.roll;
    return result;
  };
  HeadingPitchRoll.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.heading === right.heading) && (left.pitch === right.pitch) && (left.roll === right.roll));
  };
  HeadingPitchRoll.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.heading, right.heading, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.pitch, right.pitch, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.roll, right.roll, relativeEpsilon, absoluteEpsilon));
  };
  HeadingPitchRoll.prototype.clone = function(result) {
    return HeadingPitchRoll.clone(this, result);
  };
  HeadingPitchRoll.prototype.equals = function(right) {
    return HeadingPitchRoll.equals(this, right);
  };
  HeadingPitchRoll.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
    return HeadingPitchRoll.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };
  HeadingPitchRoll.prototype.toString = function() {
    return '(' + this.heading + ', ' + this.pitch + ', ' + this.roll + ')';
  };
  return HeadingPitchRoll;
});

})();
(function() {
var define = $__System.amdDefine;
define("29", ["1f", "54", "15", "5", "6d", "3c", "11", "6e", "d", "27"], function(Cartesian3, Check, defaultValue, defined, deprecationWarning, FeatureDetection, freezeObject, HeadingPitchRoll, CesiumMath, Matrix3) {
  'use strict';
  function Quaternion(x, y, z, w) {
    this.x = defaultValue(x, 0.0);
    this.y = defaultValue(y, 0.0);
    this.z = defaultValue(z, 0.0);
    this.w = defaultValue(w, 0.0);
  }
  var fromAxisAngleScratch = new Cartesian3();
  Quaternion.fromAxisAngle = function(axis, angle, result) {
    Check.typeOf.object('axis', axis);
    Check.typeOf.number('angle', angle);
    var halfAngle = angle / 2.0;
    var s = Math.sin(halfAngle);
    fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);
    var x = fromAxisAngleScratch.x * s;
    var y = fromAxisAngleScratch.y * s;
    var z = fromAxisAngleScratch.z * s;
    var w = Math.cos(halfAngle);
    if (!defined(result)) {
      return new Quaternion(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  var fromRotationMatrixNext = [1, 2, 0];
  var fromRotationMatrixQuat = new Array(3);
  Quaternion.fromRotationMatrix = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    var root;
    var x;
    var y;
    var z;
    var w;
    var m00 = matrix[Matrix3.COLUMN0ROW0];
    var m11 = matrix[Matrix3.COLUMN1ROW1];
    var m22 = matrix[Matrix3.COLUMN2ROW2];
    var trace = m00 + m11 + m22;
    if (trace > 0.0) {
      root = Math.sqrt(trace + 1.0);
      w = 0.5 * root;
      root = 0.5 / root;
      x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
      y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
      z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
    } else {
      var next = fromRotationMatrixNext;
      var i = 0;
      if (m11 > m00) {
        i = 1;
      }
      if (m22 > m00 && m22 > m11) {
        i = 2;
      }
      var j = next[i];
      var k = next[j];
      root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);
      var quat = fromRotationMatrixQuat;
      quat[i] = 0.5 * root;
      root = 0.5 / root;
      w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
      quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
      quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;
      x = -quat[0];
      y = -quat[1];
      z = -quat[2];
    }
    if (!defined(result)) {
      return new Quaternion(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  var scratchHPRQuaternion = new Quaternion();
  var scratchHeadingQuaternion = new Quaternion();
  var scratchPitchQuaternion = new Quaternion();
  var scratchRollQuaternion = new Quaternion();
  Quaternion.fromHeadingPitchRoll = function(headingOrHeadingPitchRoll, pitchOrResult, roll, result) {
    if (headingOrHeadingPitchRoll instanceof HeadingPitchRoll) {
      Check.typeOf.object('headingPitchRoll', headingOrHeadingPitchRoll);
    } else {
      Check.typeOf.number('heading', headingOrHeadingPitchRoll);
      Check.typeOf.number('pitch', pitchOrResult);
      Check.typeOf.number('roll', roll);
    }
    var hpr;
    if (headingOrHeadingPitchRoll instanceof HeadingPitchRoll) {
      hpr = headingOrHeadingPitchRoll;
      result = pitchOrResult;
    } else {
      deprecationWarning('Quaternion.fromHeadingPitchRoll(heading, pitch, roll,result)', 'The method was deprecated in Cesium 1.32 and will be removed in version 1.33. ' + 'Use Quaternion.fromHeadingPitchRoll(hpr,result) where hpr is a HeadingPitchRoll');
      hpr = new HeadingPitchRoll(headingOrHeadingPitchRoll, pitchOrResult, roll);
    }
    scratchRollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, hpr.roll, scratchHPRQuaternion);
    scratchPitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -hpr.pitch, result);
    result = Quaternion.multiply(scratchPitchQuaternion, scratchRollQuaternion, scratchPitchQuaternion);
    scratchHeadingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -hpr.heading, scratchHPRQuaternion);
    return Quaternion.multiply(scratchHeadingQuaternion, result, result);
  };
  var sampledQuaternionAxis = new Cartesian3();
  var sampledQuaternionRotation = new Cartesian3();
  var sampledQuaternionTempQuaternion = new Quaternion();
  var sampledQuaternionQuaternion0 = new Quaternion();
  var sampledQuaternionQuaternion0Conjugate = new Quaternion();
  Quaternion.packedLength = 4;
  Quaternion.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex++] = value.z;
    array[startingIndex] = value.w;
    return array;
  };
  Quaternion.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Quaternion();
    }
    result.x = array[startingIndex];
    result.y = array[startingIndex + 1];
    result.z = array[startingIndex + 2];
    result.w = array[startingIndex + 3];
    return result;
  };
  Quaternion.packedInterpolationLength = 3;
  Quaternion.convertPackedArrayForInterpolation = function(packedArray, startingIndex, lastIndex, result) {
    Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);
    Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);
    for (var i = 0,
        len = lastIndex - startingIndex + 1; i < len; i++) {
      var offset = i * 3;
      Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);
      Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);
      if (sampledQuaternionTempQuaternion.w < 0) {
        Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);
      }
      Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);
      var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
      result[offset] = sampledQuaternionAxis.x * angle;
      result[offset + 1] = sampledQuaternionAxis.y * angle;
      result[offset + 2] = sampledQuaternionAxis.z * angle;
    }
  };
  Quaternion.unpackInterpolationResult = function(array, sourceArray, firstIndex, lastIndex, result) {
    if (!defined(result)) {
      result = new Quaternion();
    }
    Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
    var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);
    Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);
    if (magnitude === 0) {
      Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
    } else {
      Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);
    }
    return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);
  };
  Quaternion.clone = function(quaternion, result) {
    if (!defined(quaternion)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    }
    result.x = quaternion.x;
    result.y = quaternion.y;
    result.z = quaternion.z;
    result.w = quaternion.w;
    return result;
  };
  Quaternion.conjugate = function(quaternion, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.object('result', result);
    result.x = -quaternion.x;
    result.y = -quaternion.y;
    result.z = -quaternion.z;
    result.w = quaternion.w;
    return result;
  };
  Quaternion.magnitudeSquared = function(quaternion) {
    Check.typeOf.object('quaternion', quaternion);
    return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
  };
  Quaternion.magnitude = function(quaternion) {
    return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
  };
  Quaternion.normalize = function(quaternion, result) {
    Check.typeOf.object('result', result);
    var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
    var x = quaternion.x * inverseMagnitude;
    var y = quaternion.y * inverseMagnitude;
    var z = quaternion.z * inverseMagnitude;
    var w = quaternion.w * inverseMagnitude;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Quaternion.inverse = function(quaternion, result) {
    Check.typeOf.object('result', result);
    var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
    result = Quaternion.conjugate(quaternion, result);
    return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
  };
  Quaternion.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    result.w = left.w + right.w;
    return result;
  };
  Quaternion.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    result.w = left.w - right.w;
    return result;
  };
  Quaternion.negate = function(quaternion, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.object('result', result);
    result.x = -quaternion.x;
    result.y = -quaternion.y;
    result.z = -quaternion.z;
    result.w = -quaternion.w;
    return result;
  };
  Quaternion.dot = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Quaternion.multiply = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    var leftX = left.x;
    var leftY = left.y;
    var leftZ = left.z;
    var leftW = left.w;
    var rightX = right.x;
    var rightY = right.y;
    var rightZ = right.z;
    var rightW = right.w;
    var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
    var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
    var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
    var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Quaternion.multiplyByScalar = function(quaternion, scalar, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = quaternion.x * scalar;
    result.y = quaternion.y * scalar;
    result.z = quaternion.z * scalar;
    result.w = quaternion.w * scalar;
    return result;
  };
  Quaternion.divideByScalar = function(quaternion, scalar, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = quaternion.x / scalar;
    result.y = quaternion.y / scalar;
    result.z = quaternion.z / scalar;
    result.w = quaternion.w / scalar;
    return result;
  };
  Quaternion.computeAxis = function(quaternion, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.object('result', result);
    var w = quaternion.w;
    if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
      result.x = result.y = result.z = 0;
      return result;
    }
    var scalar = 1.0 / Math.sqrt(1.0 - (w * w));
    result.x = quaternion.x * scalar;
    result.y = quaternion.y * scalar;
    result.z = quaternion.z * scalar;
    return result;
  };
  Quaternion.computeAngle = function(quaternion) {
    Check.typeOf.object('quaternion', quaternion);
    if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
      return 0.0;
    }
    return 2.0 * Math.acos(quaternion.w);
  };
  var lerpScratch = new Quaternion();
  Quaternion.lerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
    result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
    return Quaternion.add(lerpScratch, result, result);
  };
  var slerpEndNegated = new Quaternion();
  var slerpScaledP = new Quaternion();
  var slerpScaledR = new Quaternion();
  Quaternion.slerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    var dot = Quaternion.dot(start, end);
    var r = end;
    if (dot < 0.0) {
      dot = -dot;
      r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
    }
    if (1.0 - dot < CesiumMath.EPSILON6) {
      return Quaternion.lerp(start, r, t, result);
    }
    var theta = Math.acos(dot);
    slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
    slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
    result = Quaternion.add(slerpScaledP, slerpScaledR, result);
    return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
  };
  Quaternion.log = function(quaternion, result) {
    Check.typeOf.object('quaternion', quaternion);
    Check.typeOf.object('result', result);
    var theta = CesiumMath.acosClamped(quaternion.w);
    var thetaOverSinTheta = 0.0;
    if (theta !== 0.0) {
      thetaOverSinTheta = theta / Math.sin(theta);
    }
    return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
  };
  Quaternion.exp = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var theta = Cartesian3.magnitude(cartesian);
    var sinThetaOverTheta = 0.0;
    if (theta !== 0.0) {
      sinThetaOverTheta = Math.sin(theta) / theta;
    }
    result.x = cartesian.x * sinThetaOverTheta;
    result.y = cartesian.y * sinThetaOverTheta;
    result.z = cartesian.z * sinThetaOverTheta;
    result.w = Math.cos(theta);
    return result;
  };
  var squadScratchCartesian0 = new Cartesian3();
  var squadScratchCartesian1 = new Cartesian3();
  var squadScratchQuaternion0 = new Quaternion();
  var squadScratchQuaternion1 = new Quaternion();
  Quaternion.computeInnerQuadrangle = function(q0, q1, q2, result) {
    Check.typeOf.object('q0', q0);
    Check.typeOf.object('q1', q1);
    Check.typeOf.object('q2', q2);
    Check.typeOf.object('result', result);
    var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
    Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
    var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);
    Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
    var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);
    Cartesian3.add(cart0, cart1, cart0);
    Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
    Cartesian3.negate(cart0, cart0);
    Quaternion.exp(cart0, squadScratchQuaternion0);
    return Quaternion.multiply(q1, squadScratchQuaternion0, result);
  };
  Quaternion.squad = function(q0, q1, s0, s1, t, result) {
    Check.typeOf.object('q0', q0);
    Check.typeOf.object('q1', q1);
    Check.typeOf.object('s0', s0);
    Check.typeOf.object('s1', s1);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
    var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
    return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
  };
  var fastSlerpScratchQuaternion = new Quaternion();
  var opmu = 1.90110745351730037;
  var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
  var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
  var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
  var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
  for (var i = 0; i < 7; ++i) {
    var s = i + 1.0;
    var t = 2.0 * s + 1.0;
    u[i] = 1.0 / (s * t);
    v[i] = s / t;
  }
  u[7] = opmu / (8.0 * 17.0);
  v[7] = opmu * 8.0 / 17.0;
  Quaternion.fastSlerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    var x = Quaternion.dot(start, end);
    var sign;
    if (x >= 0) {
      sign = 1.0;
    } else {
      sign = -1.0;
      x = -x;
    }
    var xm1 = x - 1.0;
    var d = 1.0 - t;
    var sqrT = t * t;
    var sqrD = d * d;
    for (var i = 7; i >= 0; --i) {
      bT[i] = (u[i] * sqrT - v[i]) * xm1;
      bD[i] = (u[i] * sqrD - v[i]) * xm1;
    }
    var cT = sign * t * (1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));
    var cD = d * (1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));
    var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);
    Quaternion.multiplyByScalar(end, cT, result);
    return Quaternion.add(temp, result, result);
  };
  Quaternion.fastSquad = function(q0, q1, s0, s1, t, result) {
    Check.typeOf.object('q0', q0);
    Check.typeOf.object('q1', q1);
    Check.typeOf.object('s0', s0);
    Check.typeOf.object('s1', s1);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
    var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
    return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
  };
  Quaternion.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z) && (left.w === right.w));
  };
  Quaternion.equalsEpsilon = function(left, right, epsilon) {
    Check.typeOf.number('epsilon', epsilon);
    return (left === right) || ((defined(left)) && (defined(right)) && (Math.abs(left.x - right.x) <= epsilon) && (Math.abs(left.y - right.y) <= epsilon) && (Math.abs(left.z - right.z) <= epsilon) && (Math.abs(left.w - right.w) <= epsilon));
  };
  Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));
  Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));
  Quaternion.prototype.clone = function(result) {
    return Quaternion.clone(this, result);
  };
  Quaternion.prototype.equals = function(right) {
    return Quaternion.equals(this, right);
  };
  Quaternion.prototype.equalsEpsilon = function(right, epsilon) {
    return Quaternion.equalsEpsilon(this, right, epsilon);
  };
  Quaternion.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
  };
  return Quaternion;
});

})();
(function() {
var define = $__System.amdDefine;
define("3e", ["11"], function(freezeObject) {
  'use strict';
  var TimeConstants = {
    SECONDS_PER_MILLISECOND: 0.001,
    SECONDS_PER_MINUTE: 60.0,
    MINUTES_PER_HOUR: 60.0,
    HOURS_PER_DAY: 24.0,
    SECONDS_PER_HOUR: 3600.0,
    MINUTES_PER_DAY: 1440.0,
    SECONDS_PER_DAY: 86400.0,
    DAYS_PER_JULIAN_CENTURY: 36525.0,
    PICOSECOND: 0.000000001,
    MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5
  };
  return freezeObject(TimeConstants);
});

})();
(function() {
var define = $__System.amdDefine;
define("2a", ["48", "a", "1f", "32", "41", "54", "15", "5", "6d", "7", "5d", "5e", "42", "66", "68", "17", "d", "27", "28", "29", "3e"], function(when, Cartesian2, Cartesian3, Cartesian4, Cartographic, Check, defaultValue, defined, deprecationWarning, DeveloperError, EarthOrientationParameters, EarthOrientationParametersSample, Ellipsoid, Iau2006XysData, Iau2006XysSample, JulianDate, CesiumMath, Matrix3, Matrix4, Quaternion, TimeConstants) {
  'use strict';
  var Transforms = {};
  var vectorProductLocalFrame = {
    up: {
      south: 'east',
      north: 'west',
      west: 'south',
      east: 'north'
    },
    down: {
      south: 'west',
      north: 'east',
      west: 'north',
      east: 'south'
    },
    south: {
      up: 'west',
      down: 'east',
      west: 'down',
      east: 'up'
    },
    north: {
      up: 'east',
      down: 'west',
      west: 'up',
      east: 'down'
    },
    west: {
      up: 'north',
      down: 'south',
      north: 'down',
      south: 'up'
    },
    east: {
      up: 'south',
      down: 'north',
      north: 'up',
      south: 'down'
    }
  };
  var degeneratePositionLocalFrame = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1]
  };
  var localFrameToFixedFrameCache = {};
  var scratchCalculateCartesian = {
    east: new Cartesian3(),
    north: new Cartesian3(),
    up: new Cartesian3(),
    west: new Cartesian3(),
    south: new Cartesian3(),
    down: new Cartesian3()
  };
  var scratchFirstCartesian = new Cartesian3();
  var scratchSecondCartesian = new Cartesian3();
  var scratchThirdCartesian = new Cartesian3();
  Transforms.localFrameToFixedFrameGenerator = function(firstAxis, secondAxis) {
    if (!vectorProductLocalFrame.hasOwnProperty(firstAxis) || !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)) {
      throw new DeveloperError('firstAxis and secondAxis must be east, north, up, west, south or down.');
    }
    var thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];
    var resultat;
    var hashAxis = firstAxis + secondAxis;
    if (defined(localFrameToFixedFrameCache[hashAxis])) {
      resultat = localFrameToFixedFrameCache[hashAxis];
    } else {
      resultat = function(origin, ellipsoid, result) {
        if (!defined(origin)) {
          throw new DeveloperError('origin is required.');
        }
        if (!defined(result)) {
          result = new Matrix4();
        }
        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
          var sign = CesiumMath.sign(origin.z);
          Cartesian3.unpack(degeneratePositionLocalFrame[firstAxis], 0, scratchFirstCartesian);
          if (firstAxis !== 'east' && firstAxis !== 'west') {
            Cartesian3.multiplyByScalar(scratchFirstCartesian, sign, scratchFirstCartesian);
          }
          Cartesian3.unpack(degeneratePositionLocalFrame[secondAxis], 0, scratchSecondCartesian);
          if (secondAxis !== 'east' && secondAxis !== 'west') {
            Cartesian3.multiplyByScalar(scratchSecondCartesian, sign, scratchSecondCartesian);
          }
          Cartesian3.unpack(degeneratePositionLocalFrame[thirdAxis], 0, scratchThirdCartesian);
          if (thirdAxis !== 'east' && thirdAxis !== 'west') {
            Cartesian3.multiplyByScalar(scratchThirdCartesian, sign, scratchThirdCartesian);
          }
        } else {
          ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
          ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);
          var up = scratchCalculateCartesian.up;
          var east = scratchCalculateCartesian.east;
          east.x = -origin.y;
          east.y = origin.x;
          east.z = 0.0;
          Cartesian3.normalize(east, scratchCalculateCartesian.east);
          Cartesian3.cross(up, east, scratchCalculateCartesian.north);
          Cartesian3.multiplyByScalar(scratchCalculateCartesian.up, -1, scratchCalculateCartesian.down);
          Cartesian3.multiplyByScalar(scratchCalculateCartesian.east, -1, scratchCalculateCartesian.west);
          Cartesian3.multiplyByScalar(scratchCalculateCartesian.north, -1, scratchCalculateCartesian.south);
          scratchFirstCartesian = scratchCalculateCartesian[firstAxis];
          scratchSecondCartesian = scratchCalculateCartesian[secondAxis];
          scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];
        }
        result[0] = scratchFirstCartesian.x;
        result[1] = scratchFirstCartesian.y;
        result[2] = scratchFirstCartesian.z;
        result[3] = 0.0;
        result[4] = scratchSecondCartesian.x;
        result[5] = scratchSecondCartesian.y;
        result[6] = scratchSecondCartesian.z;
        result[7] = 0.0;
        result[8] = scratchThirdCartesian.x;
        result[9] = scratchThirdCartesian.y;
        result[10] = scratchThirdCartesian.z;
        result[11] = 0.0;
        result[12] = origin.x;
        result[13] = origin.y;
        result[14] = origin.z;
        result[15] = 1.0;
        return result;
      };
      localFrameToFixedFrameCache[hashAxis] = resultat;
    }
    return resultat;
  };
  Transforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator('east', 'north');
  Transforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator('north', 'east');
  Transforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator('north', 'up');
  Transforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator('north', 'west');
  var scratchHPRQuaternion = new Quaternion();
  var scratchScale = new Cartesian3(1.0, 1.0, 1.0);
  var scratchHPRMatrix4 = new Matrix4();
  Transforms.headingPitchRollToFixedFrame = function(origin, headingPitchRoll, ellipsoid, fixedFrameTransformOrResult, result) {
    Check.typeOf.object('HeadingPitchRoll', headingPitchRoll);
    if (fixedFrameTransformOrResult instanceof Matrix4) {
      result = fixedFrameTransformOrResult;
      fixedFrameTransformOrResult = undefined;
      deprecationWarning('Transforms.headingPitchRollToFixedFrame(origin, headingPitchRoll, ellipsoid, result)', 'The method was deprecated in Cesium 1.31 and will be removed in version 1.33. Transforms.headingPitchRollToFixedFrame(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) where fixedFrameTransform is a a 4x4 transformation matrix (see Transforms.localFrameToFixedFrameGenerator)');
    }
    fixedFrameTransformOrResult = defaultValue(fixedFrameTransformOrResult, Transforms.eastNorthUpToFixedFrame);
    var hprQuaternion = Quaternion.fromHeadingPitchRoll(headingPitchRoll, scratchHPRQuaternion);
    var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);
    result = fixedFrameTransformOrResult(origin, ellipsoid, result);
    return Matrix4.multiply(result, hprMatrix, result);
  };
  var scratchENUMatrix4 = new Matrix4();
  var scratchHPRMatrix3 = new Matrix3();
  Transforms.headingPitchRollQuaternion = function(origin, headingPitchRoll, ellipsoid, fixedFrameTransformOrResult, result) {
    Check.typeOf.object('HeadingPitchRoll', headingPitchRoll);
    if (fixedFrameTransformOrResult instanceof Quaternion) {
      result = fixedFrameTransformOrResult;
      fixedFrameTransformOrResult = undefined;
      deprecationWarning('Transforms.headingPitchRollQuaternion(origin, headingPitchRoll, ellipsoid, result)', 'The method was deprecated in Cesium 1.31 and will be removed in version 1.33. Transforms.headingPitchRollQuaternion(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) where fixedFrameTransform is a a 4x4 transformation matrix (see Transforms.localFrameToFixedFrameGenerator)');
    }
    var transform = Transforms.headingPitchRollToFixedFrame(origin, headingPitchRoll, ellipsoid, fixedFrameTransformOrResult, scratchENUMatrix4);
    var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);
    return Quaternion.fromRotationMatrix(rotation, result);
  };
  var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
  var gmstConstant1 = 8640184.812866;
  var gmstConstant2 = 0.093104;
  var gmstConstant3 = -6.2E-6;
  var rateCoef = 1.1772758384668e-19;
  var wgs84WRPrecessing = 7.2921158553E-5;
  var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;
  var dateInUtc = new JulianDate();
  Transforms.computeTemeToPseudoFixedMatrix = function(date, result) {
    if (!defined(date)) {
      throw new DeveloperError('date is required.');
    }
    dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);
    var utcDayNumber = dateInUtc.dayNumber;
    var utcSecondsIntoDay = dateInUtc.secondsOfDay;
    var t;
    var diffDays = utcDayNumber - 2451545;
    if (utcSecondsIntoDay >= 43200.0) {
      t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    } else {
      t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    }
    var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
    var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
    var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
    var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
    var gha = angle + (ratio * secondsSinceMidnight);
    var cosGha = Math.cos(gha);
    var sinGha = Math.sin(gha);
    if (!defined(result)) {
      return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = cosGha;
    result[1] = -sinGha;
    result[2] = 0.0;
    result[3] = sinGha;
    result[4] = cosGha;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 1.0;
    return result;
  };
  Transforms.iau2006XysData = new Iau2006XysData();
  Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;
  var ttMinusTai = 32.184;
  var j2000ttDays = 2451545.0;
  Transforms.preloadIcrfFixed = function(timeInterval) {
    var startDayTT = timeInterval.start.dayNumber;
    var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
    var stopDayTT = timeInterval.stop.dayNumber;
    var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;
    var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);
    var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();
    return when.all([xysPromise, eopPromise]);
  };
  Transforms.computeIcrfToFixedMatrix = function(date, result) {
    if (!defined(date)) {
      throw new DeveloperError('date is required.');
    }
    if (!defined(result)) {
      result = new Matrix3();
    }
    var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
    if (!defined(fixedToIcrfMtx)) {
      return undefined;
    }
    return Matrix3.transpose(fixedToIcrfMtx, result);
  };
  var xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);
  var eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  var rotation1Scratch = new Matrix3();
  var rotation2Scratch = new Matrix3();
  Transforms.computeFixedToIcrfMatrix = function(date, result) {
    if (!defined(date)) {
      throw new DeveloperError('date is required.');
    }
    if (!defined(result)) {
      result = new Matrix3();
    }
    var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
    if (!defined(eop)) {
      return undefined;
    }
    var dayTT = date.dayNumber;
    var secondTT = date.secondsOfDay + ttMinusTai;
    var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);
    if (!defined(xys)) {
      return undefined;
    }
    var x = xys.x + eop.xPoleOffset;
    var y = xys.y + eop.yPoleOffset;
    var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));
    var rotation1 = rotation1Scratch;
    rotation1[0] = 1.0 - a * x * x;
    rotation1[3] = -a * x * y;
    rotation1[6] = x;
    rotation1[1] = -a * x * y;
    rotation1[4] = 1 - a * y * y;
    rotation1[7] = y;
    rotation1[2] = -x;
    rotation1[5] = -y;
    rotation1[8] = 1 - a * (x * x + y * y);
    var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
    var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);
    var dateUt1day = date.dayNumber;
    var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;
    var daysSinceJ2000 = dateUt1day - 2451545;
    var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;
    var era = 0.7790572732640 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
    era = (era % 1.0) * CesiumMath.TWO_PI;
    var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);
    var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);
    var cosxp = Math.cos(eop.xPoleWander);
    var cosyp = Math.cos(eop.yPoleWander);
    var sinxp = Math.sin(eop.xPoleWander);
    var sinyp = Math.sin(eop.yPoleWander);
    var ttt = (dayTT - j2000ttDays) + secondTT / TimeConstants.SECONDS_PER_DAY;
    ttt /= 36525.0;
    var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;
    var cossp = Math.cos(sp);
    var sinsp = Math.sin(sp);
    var fToPfMtx = rotation2Scratch;
    fToPfMtx[0] = cosxp * cossp;
    fToPfMtx[1] = cosxp * sinsp;
    fToPfMtx[2] = sinxp;
    fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
    fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
    fToPfMtx[5] = -sinyp * cosxp;
    fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
    fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
    fToPfMtx[8] = cosyp * cosxp;
    return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
  };
  var pointToWindowCoordinatesTemp = new Cartesian4();
  Transforms.pointToWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
    result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);
    result.y = 2.0 * viewportTransformation[5] - result.y;
    return result;
  };
  Transforms.pointToGLWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
    if (!defined(modelViewProjectionMatrix)) {
      throw new DeveloperError('modelViewProjectionMatrix is required.');
    }
    if (!defined(viewportTransformation)) {
      throw new DeveloperError('viewportTransformation is required.');
    }
    if (!defined(point)) {
      throw new DeveloperError('point is required.');
    }
    if (!defined(result)) {
      result = new Cartesian2();
    }
    var tmp = pointToWindowCoordinatesTemp;
    Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);
    Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
    Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
    return Cartesian2.fromCartesian4(tmp, result);
  };
  var normalScratch = new Cartesian3();
  var rightScratch = new Cartesian3();
  var upScratch = new Cartesian3();
  Transforms.rotationMatrixFromPositionVelocity = function(position, velocity, ellipsoid, result) {
    if (!defined(position)) {
      throw new DeveloperError('position is required.');
    }
    if (!defined(velocity)) {
      throw new DeveloperError('velocity is required.');
    }
    var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);
    var right = Cartesian3.cross(velocity, normal, rightScratch);
    if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
      right = Cartesian3.clone(Cartesian3.UNIT_X, right);
    }
    var up = Cartesian3.cross(right, velocity, upScratch);
    Cartesian3.cross(velocity, up, right);
    Cartesian3.negate(right, right);
    if (!defined(result)) {
      result = new Matrix3();
    }
    result[0] = velocity.x;
    result[1] = velocity.y;
    result[2] = velocity.z;
    result[3] = right.x;
    result[4] = right.y;
    result[5] = right.z;
    result[6] = up.x;
    result[7] = up.y;
    result[8] = up.z;
    return result;
  };
  var scratchCartographic = new Cartographic();
  var scratchCartesian3Projection = new Cartesian3();
  var scratchCartesian3 = new Cartesian3();
  var scratchCartesian4Origin = new Cartesian4();
  var scratchCartesian4NewOrigin = new Cartesian4();
  var scratchCartesian4NewXAxis = new Cartesian4();
  var scratchCartesian4NewYAxis = new Cartesian4();
  var scratchCartesian4NewZAxis = new Cartesian4();
  var scratchFromENU = new Matrix4();
  var scratchToENU = new Matrix4();
  Transforms.basisTo2D = function(projection, matrix, result) {
    if (!defined(projection)) {
      throw new DeveloperError('projection is required.');
    }
    if (!defined(matrix)) {
      throw new DeveloperError('matrix is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var ellipsoid = projection.ellipsoid;
    var origin = Matrix4.getColumn(matrix, 3, scratchCartesian4Origin);
    var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);
    var fromENU = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, scratchFromENU);
    var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);
    var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
    var newOrigin = scratchCartesian4NewOrigin;
    newOrigin.x = projectedPosition.z;
    newOrigin.y = projectedPosition.x;
    newOrigin.z = projectedPosition.y;
    newOrigin.w = 1.0;
    var xAxis = Matrix4.getColumn(matrix, 0, scratchCartesian3);
    var xScale = Cartesian3.magnitude(xAxis);
    var newXAxis = Matrix4.multiplyByVector(toENU, xAxis, scratchCartesian4NewXAxis);
    Cartesian4.fromElements(newXAxis.z, newXAxis.x, newXAxis.y, 0.0, newXAxis);
    var yAxis = Matrix4.getColumn(matrix, 1, scratchCartesian3);
    var yScale = Cartesian3.magnitude(yAxis);
    var newYAxis = Matrix4.multiplyByVector(toENU, yAxis, scratchCartesian4NewYAxis);
    Cartesian4.fromElements(newYAxis.z, newYAxis.x, newYAxis.y, 0.0, newYAxis);
    var zAxis = Matrix4.getColumn(matrix, 2, scratchCartesian3);
    var zScale = Cartesian3.magnitude(zAxis);
    var newZAxis = scratchCartesian4NewZAxis;
    Cartesian3.cross(newXAxis, newYAxis, newZAxis);
    Cartesian3.normalize(newZAxis, newZAxis);
    Cartesian3.cross(newYAxis, newZAxis, newXAxis);
    Cartesian3.normalize(newXAxis, newXAxis);
    Cartesian3.cross(newZAxis, newXAxis, newYAxis);
    Cartesian3.normalize(newYAxis, newYAxis);
    Cartesian3.multiplyByScalar(newXAxis, xScale, newXAxis);
    Cartesian3.multiplyByScalar(newYAxis, yScale, newYAxis);
    Cartesian3.multiplyByScalar(newZAxis, zScale, newZAxis);
    Matrix4.setColumn(result, 0, newXAxis, result);
    Matrix4.setColumn(result, 1, newYAxis, result);
    Matrix4.setColumn(result, 2, newZAxis, result);
    Matrix4.setColumn(result, 3, newOrigin, result);
    return result;
  };
  var swizzleMatrix = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
  Transforms.wgs84To2DModelMatrix = function(projection, center, result) {
    if (!defined(projection)) {
      throw new DeveloperError('projection is required.');
    }
    if (!defined(center)) {
      throw new DeveloperError('center is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var ellipsoid = projection.ellipsoid;
    var fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, scratchFromENU);
    var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);
    var cartographic = ellipsoid.cartesianToCartographic(center, scratchCartographic);
    var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
    var newOrigin = scratchCartesian4NewOrigin;
    newOrigin.x = projectedPosition.z;
    newOrigin.y = projectedPosition.x;
    newOrigin.z = projectedPosition.y;
    newOrigin.w = 1.0;
    var translation = Matrix4.fromTranslation(newOrigin, scratchFromENU);
    Matrix4.multiply(swizzleMatrix, toENU, result);
    Matrix4.multiply(translation, result, result);
    return result;
  };
  return Transforms;
});

})();
(function() {
var define = $__System.amdDefine;
define("4e", ["1f", "41", "15", "5", "6", "7", "42", "d"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, CesiumMath) {
  'use strict';
  function WebMercatorProjection(ellipsoid) {
    this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._semimajorAxis = this._ellipsoid.maximumRadius;
    this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
  }
  defineProperties(WebMercatorProjection.prototype, {ellipsoid: {get: function() {
        return this._ellipsoid;
      }}});
  WebMercatorProjection.mercatorAngleToGeodeticLatitude = function(mercatorAngle) {
    return CesiumMath.PI_OVER_TWO - (2.0 * Math.atan(Math.exp(-mercatorAngle)));
  };
  WebMercatorProjection.geodeticLatitudeToMercatorAngle = function(latitude) {
    if (latitude > WebMercatorProjection.MaximumLatitude) {
      latitude = WebMercatorProjection.MaximumLatitude;
    } else if (latitude < -WebMercatorProjection.MaximumLatitude) {
      latitude = -WebMercatorProjection.MaximumLatitude;
    }
    var sinLatitude = Math.sin(latitude);
    return 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));
  };
  WebMercatorProjection.MaximumLatitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI);
  WebMercatorProjection.prototype.project = function(cartographic, result) {
    var semimajorAxis = this._semimajorAxis;
    var x = cartographic.longitude * semimajorAxis;
    var y = WebMercatorProjection.geodeticLatitudeToMercatorAngle(cartographic.latitude) * semimajorAxis;
    var z = cartographic.height;
    if (!defined(result)) {
      return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  WebMercatorProjection.prototype.unproject = function(cartesian, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required');
    }
    var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
    var longitude = cartesian.x * oneOverEarthSemimajorAxis;
    var latitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(cartesian.y * oneOverEarthSemimajorAxis);
    var height = cartesian.z;
    if (!defined(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };
  return WebMercatorProjection;
});

})();
(function() {
var define = $__System.amdDefine;
define("6f", ["56", "53", "a", "1f", "15", "5", "7", "42", "52", "11", "d", "28", "5c", "4d", "70", "2a", "4e"], function(AxisAlignedBoundingBox, BoundingSphere, Cartesian2, Cartesian3, defaultValue, defined, DeveloperError, Ellipsoid, EllipsoidalOccluder, freezeObject, CesiumMath, Matrix4, OrientedBoundingBox, Rectangle, TerrainEncoding, Transforms, WebMercatorProjection) {
  'use strict';
  var HeightmapTessellator = {};
  HeightmapTessellator.DEFAULT_STRUCTURE = freezeObject({
    heightScale: 1.0,
    heightOffset: 0.0,
    elementsPerHeight: 1,
    stride: 1,
    elementMultiplier: 256.0,
    isBigEndian: false
  });
  var cartesian3Scratch = new Cartesian3();
  var matrix4Scratch = new Matrix4();
  var minimumScratch = new Cartesian3();
  var maximumScratch = new Cartesian3();
  HeightmapTessellator.computeVertices = function(options) {
    if (!defined(options) || !defined(options.heightmap)) {
      throw new DeveloperError('options.heightmap is required.');
    }
    if (!defined(options.width) || !defined(options.height)) {
      throw new DeveloperError('options.width and options.height are required.');
    }
    if (!defined(options.nativeRectangle)) {
      throw new DeveloperError('options.nativeRectangle is required.');
    }
    if (!defined(options.skirtHeight)) {
      throw new DeveloperError('options.skirtHeight is required.');
    }
    var cos = Math.cos;
    var sin = Math.sin;
    var sqrt = Math.sqrt;
    var atan = Math.atan;
    var exp = Math.exp;
    var piOverTwo = CesiumMath.PI_OVER_TWO;
    var toRadians = CesiumMath.toRadians;
    var heightmap = options.heightmap;
    var width = options.width;
    var height = options.height;
    var skirtHeight = options.skirtHeight;
    var isGeographic = defaultValue(options.isGeographic, true);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;
    var nativeRectangle = options.nativeRectangle;
    var geographicWest;
    var geographicSouth;
    var geographicEast;
    var geographicNorth;
    var rectangle = options.rectangle;
    if (!defined(rectangle)) {
      if (isGeographic) {
        geographicWest = toRadians(nativeRectangle.west);
        geographicSouth = toRadians(nativeRectangle.south);
        geographicEast = toRadians(nativeRectangle.east);
        geographicNorth = toRadians(nativeRectangle.north);
      } else {
        geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;
        geographicSouth = piOverTwo - (2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis)));
        geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;
        geographicNorth = piOverTwo - (2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis)));
      }
    } else {
      geographicWest = rectangle.west;
      geographicSouth = rectangle.south;
      geographicEast = rectangle.east;
      geographicNorth = rectangle.north;
    }
    var relativeToCenter = options.relativeToCenter;
    var hasRelativeToCenter = defined(relativeToCenter);
    relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;
    var exaggeration = defaultValue(options.exaggeration, 1.0);
    var includeWebMercatorT = defaultValue(options.includeWebMercatorT, false);
    var structure = defaultValue(options.structure, HeightmapTessellator.DEFAULT_STRUCTURE);
    var heightScale = defaultValue(structure.heightScale, HeightmapTessellator.DEFAULT_STRUCTURE.heightScale);
    var heightOffset = defaultValue(structure.heightOffset, HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset);
    var elementsPerHeight = defaultValue(structure.elementsPerHeight, HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight);
    var stride = defaultValue(structure.stride, HeightmapTessellator.DEFAULT_STRUCTURE.stride);
    var elementMultiplier = defaultValue(structure.elementMultiplier, HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier);
    var isBigEndian = defaultValue(structure.isBigEndian, HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian);
    var rectangleWidth = Rectangle.computeWidth(nativeRectangle);
    var rectangleHeight = Rectangle.computeHeight(nativeRectangle);
    var granularityX = rectangleWidth / (width - 1);
    var granularityY = rectangleHeight / (height - 1);
    var radiiSquared = ellipsoid.radiiSquared;
    var radiiSquaredX = radiiSquared.x;
    var radiiSquaredY = radiiSquared.y;
    var radiiSquaredZ = radiiSquared.z;
    var minimumHeight = 65536.0;
    var maximumHeight = -65536.0;
    var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);
    var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);
    var southMercatorY;
    var oneOverMercatorHeight;
    if (includeWebMercatorT) {
      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);
      oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) - southMercatorY);
    }
    var minimum = minimumScratch;
    minimum.x = Number.POSITIVE_INFINITY;
    minimum.y = Number.POSITIVE_INFINITY;
    minimum.z = Number.POSITIVE_INFINITY;
    var maximum = maximumScratch;
    maximum.x = Number.NEGATIVE_INFINITY;
    maximum.y = Number.NEGATIVE_INFINITY;
    maximum.z = Number.NEGATIVE_INFINITY;
    var hMin = Number.POSITIVE_INFINITY;
    var arrayWidth = width + (skirtHeight > 0.0 ? 2.0 : 0.0);
    var arrayHeight = height + (skirtHeight > 0.0 ? 2.0 : 0.0);
    var size = arrayWidth * arrayHeight;
    var positions = new Array(size);
    var heights = new Array(size);
    var uvs = new Array(size);
    var webMercatorTs = includeWebMercatorT ? new Array(size) : [];
    var startRow = 0;
    var endRow = height;
    var startCol = 0;
    var endCol = width;
    if (skirtHeight > 0) {
      --startRow;
      ++endRow;
      --startCol;
      ++endCol;
    }
    var index = 0;
    for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {
      var row = rowIndex;
      if (row < 0) {
        row = 0;
      }
      if (row >= height) {
        row = height - 1;
      }
      var latitude = nativeRectangle.north - granularityY * row;
      if (!isGeographic) {
        latitude = piOverTwo - (2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis)));
      } else {
        latitude = toRadians(latitude);
      }
      var cosLatitude = cos(latitude);
      var nZ = sin(latitude);
      var kZ = radiiSquaredZ * nZ;
      var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);
      v = CesiumMath.clamp(v, 0.0, 1.0);
      var webMercatorT;
      if (includeWebMercatorT) {
        webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;
      }
      for (var colIndex = startCol; colIndex < endCol; ++colIndex) {
        var col = colIndex;
        if (col < 0) {
          col = 0;
        }
        if (col >= width) {
          col = width - 1;
        }
        var longitude = nativeRectangle.west + granularityX * col;
        if (!isGeographic) {
          longitude = longitude * oneOverGlobeSemimajorAxis;
        } else {
          longitude = toRadians(longitude);
        }
        var terrainOffset = row * (width * stride) + col * stride;
        var heightSample;
        if (elementsPerHeight === 1) {
          heightSample = heightmap[terrainOffset];
        } else {
          heightSample = 0;
          var elementOffset;
          if (isBigEndian) {
            for (elementOffset = 0; elementOffset < elementsPerHeight; ++elementOffset) {
              heightSample = (heightSample * elementMultiplier) + heightmap[terrainOffset + elementOffset];
            }
          } else {
            for (elementOffset = elementsPerHeight - 1; elementOffset >= 0; --elementOffset) {
              heightSample = (heightSample * elementMultiplier) + heightmap[terrainOffset + elementOffset];
            }
          }
        }
        heightSample = (heightSample * heightScale + heightOffset) * exaggeration;
        var u = (longitude - geographicWest) / (geographicEast - geographicWest);
        u = CesiumMath.clamp(u, 0.0, 1.0);
        uvs[index] = new Cartesian2(u, v);
        maximumHeight = Math.max(maximumHeight, heightSample);
        minimumHeight = Math.min(minimumHeight, heightSample);
        if (colIndex !== col || rowIndex !== row) {
          var percentage = 0.00001;
          if (colIndex < 0) {
            longitude -= percentage * rectangleWidth;
          } else {
            longitude += percentage * rectangleWidth;
          }
          if (rowIndex < 0) {
            latitude += percentage * rectangleHeight;
          } else {
            latitude -= percentage * rectangleHeight;
          }
          cosLatitude = cos(latitude);
          nZ = sin(latitude);
          kZ = radiiSquaredZ * nZ;
          heightSample -= skirtHeight;
        }
        var nX = cosLatitude * cos(longitude);
        var nY = cosLatitude * sin(longitude);
        var kX = radiiSquaredX * nX;
        var kY = radiiSquaredY * nY;
        var gamma = sqrt((kX * nX) + (kY * nY) + (kZ * nZ));
        var oneOverGamma = 1.0 / gamma;
        var rSurfaceX = kX * oneOverGamma;
        var rSurfaceY = kY * oneOverGamma;
        var rSurfaceZ = kZ * oneOverGamma;
        var position = new Cartesian3();
        position.x = rSurfaceX + nX * heightSample;
        position.y = rSurfaceY + nY * heightSample;
        position.z = rSurfaceZ + nZ * heightSample;
        positions[index] = position;
        heights[index] = heightSample;
        if (includeWebMercatorT) {
          webMercatorTs[index] = webMercatorT;
        }
        index++;
        Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);
        Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);
        Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);
        hMin = Math.min(hMin, heightSample);
      }
    }
    var boundingSphere3D = BoundingSphere.fromPoints(positions);
    var orientedBoundingBox;
    if (defined(rectangle) && rectangle.width < CesiumMath.PI_OVER_TWO + CesiumMath.EPSILON5) {
      orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid);
    }
    var occludeePointInScaledSpace;
    if (hasRelativeToCenter) {
      var occluder = new EllipsoidalOccluder(ellipsoid);
      occludeePointInScaledSpace = occluder.computeHorizonCullingPoint(relativeToCenter, positions);
    }
    var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);
    var encoding = new TerrainEncoding(aaBox, hMin, maximumHeight, fromENU, false, includeWebMercatorT);
    var vertices = new Float32Array(size * encoding.getStride());
    var bufferIndex = 0;
    for (var j = 0; j < size; ++j) {
      bufferIndex = encoding.encode(vertices, bufferIndex, positions[j], uvs[j], heights[j], undefined, webMercatorTs[j]);
    }
    return {
      vertices: vertices,
      maximumHeight: maximumHeight,
      minimumHeight: minimumHeight,
      encoding: encoding,
      boundingSphere3D: boundingSphere3D,
      orientedBoundingBox: orientedBoundingBox,
      occludeePointInScaledSpace: occludeePointInScaledSpace
    };
  };
  return HeightmapTessellator;
});

})();
(function() {
var define = $__System.amdDefine;
define("41", ["1f", "15", "5", "7", "11", "d", "71"], function(Cartesian3, defaultValue, defined, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
  'use strict';
  function Cartographic(longitude, latitude, height) {
    this.longitude = defaultValue(longitude, 0.0);
    this.latitude = defaultValue(latitude, 0.0);
    this.height = defaultValue(height, 0.0);
  }
  Cartographic.fromRadians = function(longitude, latitude, height, result) {
    if (!defined(longitude)) {
      throw new DeveloperError('longitude is required.');
    }
    if (!defined(latitude)) {
      throw new DeveloperError('latitude is required.');
    }
    height = defaultValue(height, 0.0);
    if (!defined(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };
  Cartographic.fromDegrees = function(longitude, latitude, height, result) {
    if (!defined(longitude)) {
      throw new DeveloperError('longitude is required.');
    }
    if (!defined(latitude)) {
      throw new DeveloperError('latitude is required.');
    }
    longitude = CesiumMath.toRadians(longitude);
    latitude = CesiumMath.toRadians(latitude);
    return Cartographic.fromRadians(longitude, latitude, height, result);
  };
  var cartesianToCartographicN = new Cartesian3();
  var cartesianToCartographicP = new Cartesian3();
  var cartesianToCartographicH = new Cartesian3();
  var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);
  var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));
  var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;
  Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {
    var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;
    var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;
    var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;
    var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);
    if (!defined(p)) {
      return undefined;
    }
    var n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN);
    n = Cartesian3.normalize(n, n);
    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
    var longitude = Math.atan2(n.y, n.x);
    var latitude = Math.asin(n.z);
    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
    if (!defined(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };
  Cartographic.clone = function(cartographic, result) {
    if (!defined(cartographic)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
    }
    result.longitude = cartographic.longitude;
    result.latitude = cartographic.latitude;
    result.height = cartographic.height;
    return result;
  };
  Cartographic.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.longitude === right.longitude) && (left.latitude === right.latitude) && (left.height === right.height));
  };
  Cartographic.equalsEpsilon = function(left, right, epsilon) {
    if (typeof epsilon !== 'number') {
      throw new DeveloperError('epsilon is required and must be a number.');
    }
    return (left === right) || ((defined(left)) && (defined(right)) && (Math.abs(left.longitude - right.longitude) <= epsilon) && (Math.abs(left.latitude - right.latitude) <= epsilon) && (Math.abs(left.height - right.height) <= epsilon));
  };
  Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));
  Cartographic.prototype.clone = function(result) {
    return Cartographic.clone(this, result);
  };
  Cartographic.prototype.equals = function(right) {
    return Cartographic.equals(this, right);
  };
  Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
    return Cartographic.equalsEpsilon(this, right, epsilon);
  };
  Cartographic.prototype.toString = function() {
    return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';
  };
  return Cartographic;
});

})();
(function() {
var define = $__System.amdDefine;
define("71", ["1f", "5", "7", "d"], function(Cartesian3, defined, DeveloperError, CesiumMath) {
  'use strict';
  var scaleToGeodeticSurfaceIntersection = new Cartesian3();
  var scaleToGeodeticSurfaceGradient = new Cartesian3();
  function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required.');
    }
    if (!defined(oneOverRadii)) {
      throw new DeveloperError('oneOverRadii is required.');
    }
    if (!defined(oneOverRadiiSquared)) {
      throw new DeveloperError('oneOverRadiiSquared is required.');
    }
    if (!defined(centerToleranceSquared)) {
      throw new DeveloperError('centerToleranceSquared is required.');
    }
    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadiiX = oneOverRadii.x;
    var oneOverRadiiY = oneOverRadii.y;
    var oneOverRadiiZ = oneOverRadii.z;
    var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    var squaredNorm = x2 + y2 + z2;
    var ratio = Math.sqrt(1.0 / squaredNorm);
    var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);
    if (squaredNorm < centerToleranceSquared) {
      return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
    }
    var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    var gradient = scaleToGeodeticSurfaceGradient;
    gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
    gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
    gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;
    var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
    var correction = 0.0;
    var func;
    var denominator;
    var xMultiplier;
    var yMultiplier;
    var zMultiplier;
    var xMultiplier2;
    var yMultiplier2;
    var zMultiplier2;
    var xMultiplier3;
    var yMultiplier3;
    var zMultiplier3;
    do {
      lambda -= correction;
      xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);
      xMultiplier2 = xMultiplier * xMultiplier;
      yMultiplier2 = yMultiplier * yMultiplier;
      zMultiplier2 = zMultiplier * zMultiplier;
      xMultiplier3 = xMultiplier2 * xMultiplier;
      yMultiplier3 = yMultiplier2 * yMultiplier;
      zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;
      denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      var derivative = -2.0 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > CesiumMath.EPSILON12);
    if (!defined(result)) {
      return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
    }
    result.x = positionX * xMultiplier;
    result.y = positionY * yMultiplier;
    result.z = positionZ * zMultiplier;
    return result;
  }
  return scaleToGeodeticSurface;
});

})();
(function() {
var define = $__System.amdDefine;
define("42", ["1f", "41", "15", "5", "6", "7", "11", "d", "71"], function(Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
  'use strict';
  function initialize(ellipsoid, x, y, z) {
    x = defaultValue(x, 0.0);
    y = defaultValue(y, 0.0);
    z = defaultValue(z, 0.0);
    if (x < 0.0 || y < 0.0 || z < 0.0) {
      throw new DeveloperError('All radii components must be greater than or equal to zero.');
    }
    ellipsoid._radii = new Cartesian3(x, y, z);
    ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);
    ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);
    ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);
    ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));
    ellipsoid._minimumRadius = Math.min(x, y, z);
    ellipsoid._maximumRadius = Math.max(x, y, z);
    ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
    if (ellipsoid._radiiSquared.z !== 0) {
      ellipsoid._sqauredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;
    }
  }
  function Ellipsoid(x, y, z) {
    this._radii = undefined;
    this._radiiSquared = undefined;
    this._radiiToTheFourth = undefined;
    this._oneOverRadii = undefined;
    this._oneOverRadiiSquared = undefined;
    this._minimumRadius = undefined;
    this._maximumRadius = undefined;
    this._centerToleranceSquared = undefined;
    this._sqauredXOverSquaredZ = undefined;
    initialize(this, x, y, z);
  }
  defineProperties(Ellipsoid.prototype, {
    radii: {get: function() {
        return this._radii;
      }},
    radiiSquared: {get: function() {
        return this._radiiSquared;
      }},
    radiiToTheFourth: {get: function() {
        return this._radiiToTheFourth;
      }},
    oneOverRadii: {get: function() {
        return this._oneOverRadii;
      }},
    oneOverRadiiSquared: {get: function() {
        return this._oneOverRadiiSquared;
      }},
    minimumRadius: {get: function() {
        return this._minimumRadius;
      }},
    maximumRadius: {get: function() {
        return this._maximumRadius;
      }}
  });
  Ellipsoid.clone = function(ellipsoid, result) {
    if (!defined(ellipsoid)) {
      return undefined;
    }
    var radii = ellipsoid._radii;
    if (!defined(result)) {
      return new Ellipsoid(radii.x, radii.y, radii.z);
    }
    Cartesian3.clone(radii, result._radii);
    Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
    Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
    Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
    Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
    result._minimumRadius = ellipsoid._minimumRadius;
    result._maximumRadius = ellipsoid._maximumRadius;
    result._centerToleranceSquared = ellipsoid._centerToleranceSquared;
    return result;
  };
  Ellipsoid.fromCartesian3 = function(cartesian, result) {
    if (!defined(result)) {
      result = new Ellipsoid();
    }
    if (!defined(cartesian)) {
      return result;
    }
    initialize(result, cartesian.x, cartesian.y, cartesian.z);
    return result;
  };
  Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));
  Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));
  Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));
  Ellipsoid.prototype.clone = function(result) {
    return Ellipsoid.clone(this, result);
  };
  Ellipsoid.packedLength = Cartesian3.packedLength;
  Ellipsoid.pack = function(value, array, startingIndex) {
    if (!defined(value)) {
      throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
      throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._radii, array, startingIndex);
    return array;
  };
  Ellipsoid.unpack = function(array, startingIndex, result) {
    if (!defined(array)) {
      throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var radii = Cartesian3.unpack(array, startingIndex);
    return Ellipsoid.fromCartesian3(radii, result);
  };
  Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;
  Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {
    if (!defined(cartographic)) {
      throw new DeveloperError('cartographic is required.');
    }
    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var cosLatitude = Math.cos(latitude);
    var x = cosLatitude * Math.cos(longitude);
    var y = cosLatitude * Math.sin(longitude);
    var z = Math.sin(latitude);
    if (!defined(result)) {
      result = new Cartesian3();
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return Cartesian3.normalize(result, result);
  };
  Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {
    if (!defined(result)) {
      result = new Cartesian3();
    }
    result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
    return Cartesian3.normalize(result, result);
  };
  var cartographicToCartesianNormal = new Cartesian3();
  var cartographicToCartesianK = new Cartesian3();
  Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {
    var n = cartographicToCartesianNormal;
    var k = cartographicToCartesianK;
    this.geodeticSurfaceNormalCartographic(cartographic, n);
    Cartesian3.multiplyComponents(this._radiiSquared, n, k);
    var gamma = Math.sqrt(Cartesian3.dot(n, k));
    Cartesian3.divideByScalar(k, gamma, k);
    Cartesian3.multiplyByScalar(n, cartographic.height, n);
    if (!defined(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.add(k, n, result);
  };
  Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {
    if (!defined(cartographics)) {
      throw new DeveloperError('cartographics is required.');
    }
    var length = cartographics.length;
    if (!defined(result)) {
      result = new Array(length);
    } else {
      result.length = length;
    }
    for (var i = 0; i < length; i++) {
      result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
    }
    return result;
  };
  var cartesianToCartographicN = new Cartesian3();
  var cartesianToCartographicP = new Cartesian3();
  var cartesianToCartographicH = new Cartesian3();
  Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {
    var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);
    if (!defined(p)) {
      return undefined;
    }
    var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
    var longitude = Math.atan2(n.y, n.x);
    var latitude = Math.asin(n.z);
    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
    if (!defined(result)) {
      return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
  };
  Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {
    if (!defined(cartesians)) {
      throw new DeveloperError('cartesians is required.');
    }
    var length = cartesians.length;
    if (!defined(result)) {
      result = new Array(length);
    } else {
      result.length = length;
    }
    for (var i = 0; i < length; ++i) {
      result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
    }
    return result;
  };
  Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {
    return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);
  };
  Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {
    if (!defined(cartesian)) {
      throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
      result = new Cartesian3();
    }
    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadiiSquared = this._oneOverRadiiSquared;
    var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x + (positionY * positionY) * oneOverRadiiSquared.y + (positionZ * positionZ) * oneOverRadiiSquared.z);
    return Cartesian3.multiplyByScalar(cartesian, beta, result);
  };
  Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {
    if (!defined(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
  };
  Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {
    if (!defined(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._radii, result);
  };
  Ellipsoid.prototype.equals = function(right) {
    return (this === right) || (defined(right) && Cartesian3.equals(this._radii, right._radii));
  };
  Ellipsoid.prototype.toString = function() {
    return this._radii.toString();
  };
  Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function(position, buffer, result) {
    if (!defined(position)) {
      throw new DeveloperError('position is required.');
    }
    if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {
      throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');
    }
    if (this._radii.z === 0) {
      throw new DeveloperError('Ellipsoid.radii.z must be greater than 0');
    }
    buffer = defaultValue(buffer, 0.0);
    var sqauredXOverSquaredZ = this._sqauredXOverSquaredZ;
    if (!defined(result)) {
      result = new Cartesian3();
    }
    result.x = 0.0;
    result.y = 0.0;
    result.z = position.z * (1 - sqauredXOverSquaredZ);
    if (Math.abs(result.z) >= this._radii.z - buffer) {
      return undefined;
    }
    return result;
  };
  return Ellipsoid;
});

})();
(function() {
var define = $__System.amdDefine;
define("4d", ["41", "54", "15", "5", "6", "42", "11", "d"], function(Cartographic, Check, defaultValue, defined, defineProperties, Ellipsoid, freezeObject, CesiumMath) {
  'use strict';
  function Rectangle(west, south, east, north) {
    this.west = defaultValue(west, 0.0);
    this.south = defaultValue(south, 0.0);
    this.east = defaultValue(east, 0.0);
    this.north = defaultValue(north, 0.0);
  }
  defineProperties(Rectangle.prototype, {
    width: {get: function() {
        return Rectangle.computeWidth(this);
      }},
    height: {get: function() {
        return Rectangle.computeHeight(this);
      }}
  });
  Rectangle.packedLength = 4;
  Rectangle.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.west;
    array[startingIndex++] = value.south;
    array[startingIndex++] = value.east;
    array[startingIndex] = value.north;
    return array;
  };
  Rectangle.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Rectangle();
    }
    result.west = array[startingIndex++];
    result.south = array[startingIndex++];
    result.east = array[startingIndex++];
    result.north = array[startingIndex];
    return result;
  };
  Rectangle.computeWidth = function(rectangle) {
    Check.typeOf.object('rectangle', rectangle);
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
      east += CesiumMath.TWO_PI;
    }
    return east - west;
  };
  Rectangle.computeHeight = function(rectangle) {
    Check.typeOf.object('rectangle', rectangle);
    return rectangle.north - rectangle.south;
  };
  Rectangle.fromDegrees = function(west, south, east, north, result) {
    west = CesiumMath.toRadians(defaultValue(west, 0.0));
    south = CesiumMath.toRadians(defaultValue(south, 0.0));
    east = CesiumMath.toRadians(defaultValue(east, 0.0));
    north = CesiumMath.toRadians(defaultValue(north, 0.0));
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  Rectangle.fromRadians = function(west, south, east, north, result) {
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = defaultValue(west, 0.0);
    result.south = defaultValue(south, 0.0);
    result.east = defaultValue(east, 0.0);
    result.north = defaultValue(north, 0.0);
    return result;
  };
  Rectangle.fromCartographicArray = function(cartographics, result) {
    Check.defined('cartographics', cartographics);
    var west = Number.MAX_VALUE;
    var east = -Number.MAX_VALUE;
    var westOverIDL = Number.MAX_VALUE;
    var eastOverIDL = -Number.MAX_VALUE;
    var south = Number.MAX_VALUE;
    var north = -Number.MAX_VALUE;
    for (var i = 0,
        len = cartographics.length; i < len; i++) {
      var position = cartographics[i];
      west = Math.min(west, position.longitude);
      east = Math.max(east, position.longitude);
      south = Math.min(south, position.latitude);
      north = Math.max(north, position.latitude);
      var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;
      westOverIDL = Math.min(westOverIDL, lonAdjusted);
      eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
    }
    if (east - west > eastOverIDL - westOverIDL) {
      west = westOverIDL;
      east = eastOverIDL;
      if (east > CesiumMath.PI) {
        east = east - CesiumMath.TWO_PI;
      }
      if (west > CesiumMath.PI) {
        west = west - CesiumMath.TWO_PI;
      }
    }
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  Rectangle.fromCartesianArray = function(cartesians, ellipsoid, result) {
    Check.defined('cartesians', cartesians);
    var west = Number.MAX_VALUE;
    var east = -Number.MAX_VALUE;
    var westOverIDL = Number.MAX_VALUE;
    var eastOverIDL = -Number.MAX_VALUE;
    var south = Number.MAX_VALUE;
    var north = -Number.MAX_VALUE;
    for (var i = 0,
        len = cartesians.length; i < len; i++) {
      var position = ellipsoid.cartesianToCartographic(cartesians[i]);
      west = Math.min(west, position.longitude);
      east = Math.max(east, position.longitude);
      south = Math.min(south, position.latitude);
      north = Math.max(north, position.latitude);
      var lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;
      westOverIDL = Math.min(westOverIDL, lonAdjusted);
      eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
    }
    if (east - west > eastOverIDL - westOverIDL) {
      west = westOverIDL;
      east = eastOverIDL;
      if (east > CesiumMath.PI) {
        east = east - CesiumMath.TWO_PI;
      }
      if (west > CesiumMath.PI) {
        west = west - CesiumMath.TWO_PI;
      }
    }
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  Rectangle.clone = function(rectangle, result) {
    if (!defined(rectangle)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);
    }
    result.west = rectangle.west;
    result.south = rectangle.south;
    result.east = rectangle.east;
    result.north = rectangle.north;
    return result;
  };
  Rectangle.prototype.clone = function(result) {
    return Rectangle.clone(this, result);
  };
  Rectangle.prototype.equals = function(other) {
    return Rectangle.equals(this, other);
  };
  Rectangle.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.west === right.west) && (left.south === right.south) && (left.east === right.east) && (left.north === right.north));
  };
  Rectangle.prototype.equalsEpsilon = function(other, epsilon) {
    Check.typeOf.number('epsilon', epsilon);
    return defined(other) && (Math.abs(this.west - other.west) <= epsilon) && (Math.abs(this.south - other.south) <= epsilon) && (Math.abs(this.east - other.east) <= epsilon) && (Math.abs(this.north - other.north) <= epsilon);
  };
  Rectangle.validate = function(rectangle) {
    Check.typeOf.object('rectangle', rectangle);
    var north = rectangle.north;
    Check.typeOf.number.greaterThanOrEquals('north', north, -CesiumMath.PI_OVER_TWO);
    Check.typeOf.number.lessThanOrEquals('north', north, CesiumMath.PI_OVER_TWO);
    var south = rectangle.south;
    Check.typeOf.number.greaterThanOrEquals('south', south, -CesiumMath.PI_OVER_TWO);
    Check.typeOf.number.lessThanOrEquals('south', south, CesiumMath.PI_OVER_TWO);
    var west = rectangle.west;
    Check.typeOf.number.greaterThanOrEquals('west', west, -Math.PI);
    Check.typeOf.number.lessThanOrEquals('west', west, Math.PI);
    var east = rectangle.east;
    Check.typeOf.number.greaterThanOrEquals('east', east, -Math.PI);
    Check.typeOf.number.lessThanOrEquals('east', east, Math.PI);
  };
  Rectangle.southwest = function(rectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    if (!defined(result)) {
      return new Cartographic(rectangle.west, rectangle.south);
    }
    result.longitude = rectangle.west;
    result.latitude = rectangle.south;
    result.height = 0.0;
    return result;
  };
  Rectangle.northwest = function(rectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    if (!defined(result)) {
      return new Cartographic(rectangle.west, rectangle.north);
    }
    result.longitude = rectangle.west;
    result.latitude = rectangle.north;
    result.height = 0.0;
    return result;
  };
  Rectangle.northeast = function(rectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    if (!defined(result)) {
      return new Cartographic(rectangle.east, rectangle.north);
    }
    result.longitude = rectangle.east;
    result.latitude = rectangle.north;
    result.height = 0.0;
    return result;
  };
  Rectangle.southeast = function(rectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    if (!defined(result)) {
      return new Cartographic(rectangle.east, rectangle.south);
    }
    result.longitude = rectangle.east;
    result.latitude = rectangle.south;
    result.height = 0.0;
    return result;
  };
  Rectangle.center = function(rectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
      east += CesiumMath.TWO_PI;
    }
    var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);
    var latitude = (rectangle.south + rectangle.north) * 0.5;
    if (!defined(result)) {
      return new Cartographic(longitude, latitude);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = 0.0;
    return result;
  };
  Rectangle.intersection = function(rectangle, otherRectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    Check.typeOf.object('otherRectangle', otherRectangle);
    var rectangleEast = rectangle.east;
    var rectangleWest = rectangle.west;
    var otherRectangleEast = otherRectangle.east;
    var otherRectangleWest = otherRectangle.west;
    if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
      rectangleEast += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
      otherRectangleEast += CesiumMath.TWO_PI;
    }
    if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
      otherRectangleWest += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
      rectangleWest += CesiumMath.TWO_PI;
    }
    var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));
    var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));
    if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {
      return undefined;
    }
    var south = Math.max(rectangle.south, otherRectangle.south);
    var north = Math.min(rectangle.north, otherRectangle.north);
    if (south >= north) {
      return undefined;
    }
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  Rectangle.simpleIntersection = function(rectangle, otherRectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    Check.typeOf.object('otherRectangle', otherRectangle);
    var west = Math.max(rectangle.west, otherRectangle.west);
    var south = Math.max(rectangle.south, otherRectangle.south);
    var east = Math.min(rectangle.east, otherRectangle.east);
    var north = Math.min(rectangle.north, otherRectangle.north);
    if (south >= north || west >= east) {
      return undefined;
    }
    if (!defined(result)) {
      return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
  };
  Rectangle.union = function(rectangle, otherRectangle, result) {
    Check.typeOf.object('rectangle', rectangle);
    Check.typeOf.object('otherRectangle', otherRectangle);
    if (!defined(result)) {
      result = new Rectangle();
    }
    var rectangleEast = rectangle.east;
    var rectangleWest = rectangle.west;
    var otherRectangleEast = otherRectangle.east;
    var otherRectangleWest = otherRectangle.west;
    if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
      rectangleEast += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
      otherRectangleEast += CesiumMath.TWO_PI;
    }
    if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
      otherRectangleWest += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
      rectangleWest += CesiumMath.TWO_PI;
    }
    var west = CesiumMath.convertLongitudeRange(Math.min(rectangleWest, otherRectangleWest));
    var east = CesiumMath.convertLongitudeRange(Math.max(rectangleEast, otherRectangleEast));
    result.west = west;
    result.south = Math.min(rectangle.south, otherRectangle.south);
    result.east = east;
    result.north = Math.max(rectangle.north, otherRectangle.north);
    return result;
  };
  Rectangle.expand = function(rectangle, cartographic, result) {
    Check.typeOf.object('rectangle', rectangle);
    Check.typeOf.object('cartographic', cartographic);
    if (!defined(result)) {
      result = new Rectangle();
    }
    result.west = Math.min(rectangle.west, cartographic.longitude);
    result.south = Math.min(rectangle.south, cartographic.latitude);
    result.east = Math.max(rectangle.east, cartographic.longitude);
    result.north = Math.max(rectangle.north, cartographic.latitude);
    return result;
  };
  Rectangle.contains = function(rectangle, cartographic) {
    Check.typeOf.object('rectangle', rectangle);
    Check.typeOf.object('cartographic', cartographic);
    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var west = rectangle.west;
    var east = rectangle.east;
    if (east < west) {
      east += CesiumMath.TWO_PI;
      if (longitude < 0.0) {
        longitude += CesiumMath.TWO_PI;
      }
    }
    return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) && (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) && latitude >= rectangle.south && latitude <= rectangle.north;
  };
  var subsampleLlaScratch = new Cartographic();
  Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {
    Check.typeOf.object('rectangle', rectangle);
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    surfaceHeight = defaultValue(surfaceHeight, 0.0);
    if (!defined(result)) {
      result = [];
    }
    var length = 0;
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    var lla = subsampleLlaScratch;
    lla.height = surfaceHeight;
    lla.longitude = west;
    lla.latitude = north;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = east;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.latitude = south;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = west;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    if (north < 0.0) {
      lla.latitude = north;
    } else if (south > 0.0) {
      lla.latitude = south;
    } else {
      lla.latitude = 0.0;
    }
    for (var i = 1; i < 8; ++i) {
      lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;
      if (Rectangle.contains(rectangle, lla)) {
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;
      }
    }
    if (lla.latitude === 0.0) {
      lla.longitude = west;
      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
      length++;
      lla.longitude = east;
      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
      length++;
    }
    result.length = length;
    return result;
  };
  Rectangle.MAX_VALUE = freezeObject(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));
  return Rectangle;
});

})();
(function() {
var define = $__System.amdDefine;
define("72", ["47", "15", "5", "7"], function(Uri, defaultValue, defined, DeveloperError) {
  'use strict';
  function joinUrls(first, second, appendSlash) {
    if (!defined(first)) {
      throw new DeveloperError('first is required');
    }
    if (!defined(second)) {
      throw new DeveloperError('second is required');
    }
    appendSlash = defaultValue(appendSlash, true);
    if (!(first instanceof Uri)) {
      first = new Uri(first);
    }
    if (!(second instanceof Uri)) {
      second = new Uri(second);
    }
    if (defined(second.authority) && !defined(second.scheme)) {
      if (typeof document !== 'undefined' && defined(document.location) && defined(document.location.href)) {
        second.scheme = new Uri(document.location.href).scheme;
      } else {
        second.scheme = first.scheme;
      }
    }
    var baseUri = first;
    if (second.isAbsolute()) {
      baseUri = second;
    }
    var url = '';
    if (defined(baseUri.scheme)) {
      url += baseUri.scheme + ':';
    }
    if (defined(baseUri.authority)) {
      url += '//' + baseUri.authority;
      if (baseUri.path !== '' && baseUri.path !== '/') {
        url = url.replace(/\/?$/, '/');
        baseUri.path = baseUri.path.replace(/^\/?/g, '');
      }
    }
    if (baseUri === first) {
      if (appendSlash) {
        url += first.path.replace(/\/?$/, '/') + second.path.replace(/^\/?/g, '');
      } else {
        url += first.path + second.path;
      }
    } else {
      url += second.path;
    }
    var hasFirstQuery = defined(first.query);
    var hasSecondQuery = defined(second.query);
    if (hasFirstQuery && hasSecondQuery) {
      url += '?' + first.query + '&' + second.query;
    } else if (hasFirstQuery && !hasSecondQuery) {
      url += '?' + first.query;
    } else if (!hasFirstQuery && hasSecondQuery) {
      url += '?' + second.query;
    }
    var hasSecondFragment = defined(second.fragment);
    if (defined(first.fragment) && !hasSecondFragment) {
      url += '#' + first.fragment;
    } else if (hasSecondFragment) {
      url += '#' + second.fragment;
    }
    return url;
  }
  return joinUrls;
});

})();
(function() {
var define = $__System.amdDefine;
define("67", ["47", "5", "7", "73", "72", "require"], function(Uri, defined, DeveloperError, getAbsoluteUri, joinUrls, _dereq_) {
  'use strict';
  var cesiumScriptRegex = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;
  function getBaseUrlFromCesiumScript() {
    var scripts = document.getElementsByTagName('script');
    for (var i = 0,
        len = scripts.length; i < len; ++i) {
      var src = scripts[i].getAttribute('src');
      var result = cesiumScriptRegex.exec(src);
      if (result !== null) {
        return result[1];
      }
    }
    return undefined;
  }
  var baseUrl;
  function getCesiumBaseUrl() {
    if (defined(baseUrl)) {
      return baseUrl;
    }
    var baseUrlString;
    if (typeof CESIUM_BASE_URL !== 'undefined') {
      baseUrlString = CESIUM_BASE_URL;
    } else {
      baseUrlString = getBaseUrlFromCesiumScript();
    }
    if (!defined(baseUrlString)) {
      throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
    }
    baseUrl = new Uri(getAbsoluteUri(baseUrlString));
    return baseUrl;
  }
  function buildModuleUrlFromRequireToUrl(moduleID) {
    return _dereq_.toUrl('../' + moduleID);
  }
  function buildModuleUrlFromBaseUrl(moduleID) {
    return joinUrls(getCesiumBaseUrl(), moduleID);
  }
  var implementation;
  var a;
  function buildModuleUrl(moduleID) {
    if (!defined(implementation)) {
      if (defined(_dereq_.toUrl)) {
        implementation = buildModuleUrlFromRequireToUrl;
      } else {
        implementation = buildModuleUrlFromBaseUrl;
      }
    }
    if (!defined(a)) {
      a = document.createElement('a');
    }
    var url = implementation(moduleID);
    a.href = url;
    a.href = a.href;
    return a.href;
  }
  buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;
  buildModuleUrl.setBaseUrl = function(value) {
    baseUrl = new Uri(value).resolve(new Uri(document.location.href));
  };
  return buildModuleUrl;
});

})();
(function() {
var define = $__System.amdDefine;
define("b", ["15", "7"], function(defaultValue, DeveloperError) {
  'use strict';
  function returnTrue() {
    return true;
  }
  function destroyObject(object, message) {
    message = defaultValue(message, 'This object was destroyed, i.e., destroy() was called.');
    function throwOnDestroyed() {
      throw new DeveloperError(message);
    }
    for (var key in object) {
      if (typeof object[key] === 'function') {
        object[key] = throwOnDestroyed;
      }
    }
    object.isDestroyed = returnTrue;
    return undefined;
  }
  return destroyObject;
});

})();
(function() {
var define = $__System.amdDefine;
define("47", [], function() {
  function URI(uri) {
    if (uri instanceof URI) {
      this.scheme = uri.scheme;
      this.authority = uri.authority;
      this.path = uri.path;
      this.query = uri.query;
      this.fragment = uri.fragment;
    } else if (uri) {
      var c = parseRegex.exec(uri);
      this.scheme = c[1];
      this.authority = c[2];
      this.path = c[3];
      this.query = c[4];
      this.fragment = c[5];
    }
  }
  URI.prototype.scheme = null;
  URI.prototype.authority = null;
  URI.prototype.path = '';
  URI.prototype.query = null;
  URI.prototype.fragment = null;
  var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');
  URI.prototype.getScheme = function() {
    return this.scheme;
  };
  URI.prototype.getAuthority = function() {
    return this.authority;
  };
  URI.prototype.getPath = function() {
    return this.path;
  };
  URI.prototype.getQuery = function() {
    return this.query;
  };
  URI.prototype.getFragment = function() {
    return this.fragment;
  };
  URI.prototype.isAbsolute = function() {
    return !!this.scheme && !this.fragment;
  };
  URI.prototype.isSameDocumentAs = function(uri) {
    return uri.scheme == this.scheme && uri.authority == this.authority && uri.path == this.path && uri.query == this.query;
  };
  URI.prototype.equals = function(uri) {
    return this.isSameDocumentAs(uri) && uri.fragment == this.fragment;
  };
  URI.prototype.normalize = function() {
    this.removeDotSegments();
    if (this.scheme)
      this.scheme = this.scheme.toLowerCase();
    if (this.authority)
      this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
    if (this.path)
      this.path = this.path.replace(caseRegex, replaceCase);
    if (this.query)
      this.query = this.query.replace(caseRegex, replaceCase);
    if (this.fragment)
      this.fragment = this.fragment.replace(caseRegex, replaceCase);
  };
  var caseRegex = /%[0-9a-z]{2}/gi;
  var percentRegex = /[a-zA-Z0-9\-\._~]/;
  var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;
  function replaceCase(str) {
    var dec = unescape(str);
    return percentRegex.test(dec) ? dec : str.toUpperCase();
  }
  function replaceAuthority(str, p1, p2, p3) {
    return (p1 || '') + p2.toLowerCase() + (p3 || '');
  }
  URI.prototype.resolve = function(baseURI) {
    var uri = new URI();
    if (this.scheme) {
      uri.scheme = this.scheme;
      uri.authority = this.authority;
      uri.path = this.path;
      uri.query = this.query;
    } else {
      uri.scheme = baseURI.scheme;
      if (this.authority) {
        uri.authority = this.authority;
        uri.path = this.path;
        uri.query = this.query;
      } else {
        uri.authority = baseURI.authority;
        if (this.path == '') {
          uri.path = baseURI.path;
          uri.query = this.query || baseURI.query;
        } else {
          if (this.path.charAt(0) == '/') {
            uri.path = this.path;
            uri.removeDotSegments();
          } else {
            if (baseURI.authority && baseURI.path == '') {
              uri.path = '/' + this.path;
            } else {
              uri.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;
            }
            uri.removeDotSegments();
          }
          uri.query = this.query;
        }
      }
    }
    uri.fragment = this.fragment;
    return uri;
  };
  URI.prototype.removeDotSegments = function() {
    var input = this.path.split('/'),
        output = [],
        segment,
        absPath = input[0] == '';
    if (absPath)
      input.shift();
    var sFirst = input[0] == '' ? input.shift() : null;
    while (input.length) {
      segment = input.shift();
      if (segment == '..') {
        output.pop();
      } else if (segment != '.') {
        output.push(segment);
      }
    }
    if (segment == '.' || segment == '..')
      output.push('');
    if (absPath)
      output.unshift('');
    this.path = output.join('/');
  };
  URI.prototype.toString = function() {
    var result = '';
    if (this.scheme)
      result += this.scheme + ':';
    if (this.authority)
      result += '//' + this.authority;
    result += this.path;
    if (this.query)
      result += '?' + this.query;
    if (this.fragment)
      result += '#' + this.fragment;
    return result;
  };
  return URI;
});

})();
(function() {
var define = $__System.amdDefine;
define("73", ["47", "15", "5", "7"], function(Uri, defaultValue, defined, DeveloperError) {
  'use strict';
  function getAbsoluteUri(relative, base) {
    if (!defined(relative)) {
      throw new DeveloperError('relative uri is required.');
    }
    base = defaultValue(base, document.location.href);
    var baseUri = new Uri(base);
    var relativeUri = new Uri(relative);
    return relativeUri.resolve(baseUri).toString();
  }
  return getAbsoluteUri;
});

})();
(function() {
var define = $__System.amdDefine;
define("4a", ["5"], function(defined) {
  'use strict';
  var a;
  function isCrossOriginUrl(url) {
    if (!defined(a)) {
      a = document.createElement('a');
    }
    a.href = window.location.href;
    var host = a.host;
    var protocol = a.protocol;
    a.href = url;
    a.href = a.href;
    return protocol !== a.protocol || host !== a.host;
  }
  return isCrossOriginUrl;
});

})();
(function() {
var define = $__System.amdDefine;
define("74", ["48", "67", "15", "5", "b", "7", "73", "4a", "2c", "require"], function(when, buildModuleUrl, defaultValue, defined, destroyObject, DeveloperError, getAbsoluteUri, isCrossOriginUrl, RuntimeError, _dereq_) {
  'use strict';
  function canTransferArrayBuffer() {
    if (!defined(TaskProcessor._canTransferArrayBuffer)) {
      var worker = new Worker(getWorkerUrl('Workers/transferTypedArrayTest.js'));
      worker.postMessage = defaultValue(worker.webkitPostMessage, worker.postMessage);
      var value = 99;
      var array = new Int8Array([value]);
      try {
        worker.postMessage({array: array}, [array.buffer]);
      } catch (e) {
        TaskProcessor._canTransferArrayBuffer = false;
        return TaskProcessor._canTransferArrayBuffer;
      }
      var deferred = when.defer();
      worker.onmessage = function(event) {
        var array = event.data.array;
        var result = defined(array) && array[0] === value;
        deferred.resolve(result);
        worker.terminate();
        TaskProcessor._canTransferArrayBuffer = result;
      };
      TaskProcessor._canTransferArrayBuffer = deferred.promise;
    }
    return TaskProcessor._canTransferArrayBuffer;
  }
  function completeTask(processor, data) {
    --processor._activeTasks;
    var id = data.id;
    if (!defined(id)) {
      return;
    }
    var deferreds = processor._deferreds;
    var deferred = deferreds[id];
    if (defined(data.error)) {
      var error = data.error;
      if (error.name === 'RuntimeError') {
        error = new RuntimeError(data.error.message);
        error.stack = data.error.stack;
      } else if (error.name === 'DeveloperError') {
        error = new DeveloperError(data.error.message);
        error.stack = data.error.stack;
      }
      deferred.reject(error);
    } else {
      deferred.resolve(data.result);
    }
    delete deferreds[id];
  }
  function getWorkerUrl(moduleID) {
    var url = buildModuleUrl(moduleID);
    if (isCrossOriginUrl(url)) {
      var script = 'importScripts("' + url + '");';
      var blob;
      try {
        blob = new Blob([script], {type: 'application/javascript'});
      } catch (e) {
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        blob = blobBuilder.getBlob('application/javascript');
      }
      var URL = window.URL || window.webkitURL;
      url = URL.createObjectURL(blob);
    }
    return url;
  }
  var bootstrapperUrlResult;
  function getBootstrapperUrl() {
    if (!defined(bootstrapperUrlResult)) {
      bootstrapperUrlResult = getWorkerUrl('Workers/cesiumWorkerBootstrapper.js');
    }
    return bootstrapperUrlResult;
  }
  function createWorker(processor) {
    var worker = new Worker(getBootstrapperUrl());
    worker.postMessage = defaultValue(worker.webkitPostMessage, worker.postMessage);
    var bootstrapMessage = {
      loaderConfig: {},
      workerModule: TaskProcessor._workerModulePrefix + processor._workerName
    };
    if (defined(TaskProcessor._loaderConfig)) {
      bootstrapMessage.loaderConfig = TaskProcessor._loaderConfig;
    } else if (defined(_dereq_.toUrl)) {
      bootstrapMessage.loaderConfig.baseUrl = getAbsoluteUri('..', buildModuleUrl('Workers/cesiumWorkerBootstrapper.js'));
    } else {
      bootstrapMessage.loaderConfig.paths = {'Workers': buildModuleUrl('Workers')};
    }
    worker.postMessage(bootstrapMessage);
    worker.onmessage = function(event) {
      completeTask(processor, event.data);
    };
    return worker;
  }
  function TaskProcessor(workerName, maximumActiveTasks) {
    this._workerName = workerName;
    this._maximumActiveTasks = defaultValue(maximumActiveTasks, 5);
    this._activeTasks = 0;
    this._deferreds = {};
    this._nextID = 0;
  }
  var emptyTransferableObjectArray = [];
  TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
    if (!defined(this._worker)) {
      this._worker = createWorker(this);
    }
    if (this._activeTasks >= this._maximumActiveTasks) {
      return undefined;
    }
    ++this._activeTasks;
    var processor = this;
    return when(canTransferArrayBuffer(), function(canTransferArrayBuffer) {
      if (!defined(transferableObjects)) {
        transferableObjects = emptyTransferableObjectArray;
      } else if (!canTransferArrayBuffer) {
        transferableObjects.length = 0;
      }
      var id = processor._nextID++;
      var deferred = when.defer();
      processor._deferreds[id] = deferred;
      processor._worker.postMessage({
        id: id,
        parameters: parameters,
        canTransferArrayBuffer: canTransferArrayBuffer
      }, transferableObjects);
      return deferred.promise;
    });
  };
  TaskProcessor.prototype.isDestroyed = function() {
    return false;
  };
  TaskProcessor.prototype.destroy = function() {
    if (defined(this._worker)) {
      this._worker.terminate();
    }
    return destroyObject(this);
  };
  TaskProcessor._defaultWorkerModulePrefix = 'Workers/';
  TaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;
  TaskProcessor._loaderConfig = undefined;
  TaskProcessor._canTransferArrayBuffer = undefined;
  return TaskProcessor;
});

})();
(function() {
var define = $__System.amdDefine;
define("75", ["a", "1f", "5", "7", "d"], function(Cartesian2, Cartesian3, defined, DeveloperError, CesiumMath) {
  'use strict';
  var AttributeCompression = {};
  AttributeCompression.octEncodeInRange = function(vector, rangeMax, result) {
    if (!defined(vector)) {
      throw new DeveloperError('vector is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var magSquared = Cartesian3.magnitudeSquared(vector);
    if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {
      throw new DeveloperError('vector must be normalized.');
    }
    result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
    result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
    if (vector.z < 0) {
      var x = result.x;
      var y = result.y;
      result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);
      result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);
    }
    result.x = CesiumMath.toSNorm(result.x, rangeMax);
    result.y = CesiumMath.toSNorm(result.y, rangeMax);
    return result;
  };
  AttributeCompression.octEncode = function(vector, result) {
    return AttributeCompression.octEncodeInRange(vector, 255, result);
  };
  AttributeCompression.octDecodeInRange = function(x, y, rangeMax, result) {
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {
      throw new DeveloperError('x and y must be a signed normalized integer between 0 and ' + rangeMax);
    }
    result.x = CesiumMath.fromSNorm(x, rangeMax);
    result.y = CesiumMath.fromSNorm(y, rangeMax);
    result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0.0) {
      var oldVX = result.x;
      result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);
      result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);
    }
    return Cartesian3.normalize(result, result);
  };
  AttributeCompression.octDecode = function(x, y, result) {
    return AttributeCompression.octDecodeInRange(x, y, 255, result);
  };
  AttributeCompression.octPackFloat = function(encoded) {
    if (!defined(encoded)) {
      throw new DeveloperError('encoded is required.');
    }
    return 256.0 * encoded.x + encoded.y;
  };
  var scratchEncodeCart2 = new Cartesian2();
  AttributeCompression.octEncodeFloat = function(vector) {
    AttributeCompression.octEncode(vector, scratchEncodeCart2);
    return AttributeCompression.octPackFloat(scratchEncodeCart2);
  };
  AttributeCompression.octDecodeFloat = function(value, result) {
    if (!defined(value)) {
      throw new DeveloperError('value is required.');
    }
    var temp = value / 256.0;
    var x = Math.floor(temp);
    var y = (temp - x) * 256.0;
    return AttributeCompression.octDecode(x, y, result);
  };
  AttributeCompression.octPack = function(v1, v2, v3, result) {
    if (!defined(v1)) {
      throw new DeveloperError('v1 is required.');
    }
    if (!defined(v2)) {
      throw new DeveloperError('v2 is required.');
    }
    if (!defined(v3)) {
      throw new DeveloperError('v3 is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var encoded1 = AttributeCompression.octEncodeFloat(v1);
    var encoded2 = AttributeCompression.octEncodeFloat(v2);
    var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);
    result.x = 65536.0 * encoded3.x + encoded1;
    result.y = 65536.0 * encoded3.y + encoded2;
    return result;
  };
  AttributeCompression.octUnpack = function(packed, v1, v2, v3) {
    if (!defined(packed)) {
      throw new DeveloperError('packed is required.');
    }
    if (!defined(v1)) {
      throw new DeveloperError('v1 is required.');
    }
    if (!defined(v2)) {
      throw new DeveloperError('v2 is required.');
    }
    if (!defined(v3)) {
      throw new DeveloperError('v3 is required.');
    }
    var temp = packed.x / 65536.0;
    var x = Math.floor(temp);
    var encodedFloat1 = (temp - x) * 65536.0;
    temp = packed.y / 65536.0;
    var y = Math.floor(temp);
    var encodedFloat2 = (temp - y) * 65536.0;
    AttributeCompression.octDecodeFloat(encodedFloat1, v1);
    AttributeCompression.octDecodeFloat(encodedFloat2, v2);
    AttributeCompression.octDecode(x, y, v3);
  };
  AttributeCompression.compressTextureCoordinates = function(textureCoordinates) {
    if (!defined(textureCoordinates)) {
      throw new DeveloperError('textureCoordinates is required.');
    }
    var x = (textureCoordinates.x * 4095.0) | 0;
    var y = (textureCoordinates.y * 4095.0) | 0;
    return 4096.0 * x + y;
  };
  AttributeCompression.decompressTextureCoordinates = function(compressed, result) {
    if (!defined(compressed)) {
      throw new DeveloperError('compressed is required.');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required.');
    }
    var temp = compressed / 4096.0;
    var xZeroTo4095 = Math.floor(temp);
    result.x = xZeroTo4095 / 4095.0;
    result.y = (compressed - xZeroTo4095 * 4096) / 4095;
    return result;
  };
  return AttributeCompression;
});

})();
(function() {
var define = $__System.amdDefine;
define("a", ["54", "15", "5", "7", "11", "d"], function(Check, defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
  'use strict';
  function Cartesian2(x, y) {
    this.x = defaultValue(x, 0.0);
    this.y = defaultValue(y, 0.0);
  }
  Cartesian2.fromElements = function(x, y, result) {
    if (!defined(result)) {
      return new Cartesian2(x, y);
    }
    result.x = x;
    result.y = y;
    return result;
  };
  Cartesian2.clone = function(cartesian, result) {
    if (!defined(cartesian)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Cartesian2(cartesian.x, cartesian.y);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    return result;
  };
  Cartesian2.fromCartesian3 = Cartesian2.clone;
  Cartesian2.fromCartesian4 = Cartesian2.clone;
  Cartesian2.packedLength = 2;
  Cartesian2.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex] = value.y;
    return array;
  };
  Cartesian2.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Cartesian2();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex];
    return result;
  };
  Cartesian2.packArray = function(array, result) {
    Check.defined('array', array);
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length * 2);
    } else {
      result.length = length * 2;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian2.pack(array[i], result, i * 2);
    }
    return result;
  };
  Cartesian2.unpackArray = function(array, result) {
    Check.defined('array', array);
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var index = i / 2;
      result[index] = Cartesian2.unpack(array, i, result[index]);
    }
    return result;
  };
  Cartesian2.fromArray = Cartesian2.unpack;
  Cartesian2.maximumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.max(cartesian.x, cartesian.y);
  };
  Cartesian2.minimumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.min(cartesian.x, cartesian.y);
  };
  Cartesian2.minimumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    return result;
  };
  Cartesian2.maximumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    return result;
  };
  Cartesian2.magnitudeSquared = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
  };
  Cartesian2.magnitude = function(cartesian) {
    return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
  };
  var distanceScratch = new Cartesian2();
  Cartesian2.distance = function(left, right) {
    if (!defined(left) || !defined(right)) {
      throw new DeveloperError('left and right are required.');
    }
    Cartesian2.subtract(left, right, distanceScratch);
    return Cartesian2.magnitude(distanceScratch);
  };
  Cartesian2.distanceSquared = function(left, right) {
    if (!defined(left) || !defined(right)) {
      throw new DeveloperError('left and right are required.');
    }
    Cartesian2.subtract(left, right, distanceScratch);
    return Cartesian2.magnitudeSquared(distanceScratch);
  };
  Cartesian2.normalize = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var magnitude = Cartesian2.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    if (isNaN(result.x) || isNaN(result.y)) {
      throw new DeveloperError('normalized result is not a number');
    }
    return result;
  };
  Cartesian2.dot = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    return left.x * right.x + left.y * right.y;
  };
  Cartesian2.multiplyComponents = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    return result;
  };
  Cartesian2.divideComponents = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x / right.x;
    result.y = left.y / right.y;
    return result;
  };
  Cartesian2.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    return result;
  };
  Cartesian2.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    return result;
  };
  Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    return result;
  };
  Cartesian2.divideByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    return result;
  };
  Cartesian2.negate = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    return result;
  };
  Cartesian2.abs = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    return result;
  };
  var lerpScratch = new Cartesian2();
  Cartesian2.lerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    Cartesian2.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian2.add(lerpScratch, result, result);
  };
  var angleBetweenScratch = new Cartesian2();
  var angleBetweenScratch2 = new Cartesian2();
  Cartesian2.angleBetween = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian2.normalize(left, angleBetweenScratch);
    Cartesian2.normalize(right, angleBetweenScratch2);
    return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
  };
  var mostOrthogonalAxisScratch = new Cartesian2();
  Cartesian2.mostOrthogonalAxis = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian2.abs(f, f);
    if (f.x <= f.y) {
      result = Cartesian2.clone(Cartesian2.UNIT_X, result);
    } else {
      result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
    }
    return result;
  };
  Cartesian2.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y));
  };
  Cartesian2.equalsArray = function(cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
  };
  Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon));
  };
  Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));
  Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));
  Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));
  Cartesian2.prototype.clone = function(result) {
    return Cartesian2.clone(this, result);
  };
  Cartesian2.prototype.equals = function(right) {
    return Cartesian2.equals(this, right);
  };
  Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };
  Cartesian2.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
  };
  return Cartesian2;
});

})();
(function() {
var define = $__System.amdDefine;
define("76", ["5", "6"], function(defined, defineProperties) {
  'use strict';
  var _supportsFullscreen;
  var _names = {
    requestFullscreen: undefined,
    exitFullscreen: undefined,
    fullscreenEnabled: undefined,
    fullscreenElement: undefined,
    fullscreenchange: undefined,
    fullscreenerror: undefined
  };
  var Fullscreen = {};
  defineProperties(Fullscreen, {
    element: {get: function() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return document[_names.fullscreenElement];
      }},
    changeEventName: {get: function() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return _names.fullscreenchange;
      }},
    errorEventName: {get: function() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return _names.fullscreenerror;
      }},
    enabled: {get: function() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return document[_names.fullscreenEnabled];
      }},
    fullscreen: {get: function() {
        if (!Fullscreen.supportsFullscreen()) {
          return undefined;
        }
        return Fullscreen.element !== null;
      }}
  });
  Fullscreen.supportsFullscreen = function() {
    if (defined(_supportsFullscreen)) {
      return _supportsFullscreen;
    }
    _supportsFullscreen = false;
    var body = document.body;
    if (typeof body.requestFullscreen === 'function') {
      _names.requestFullscreen = 'requestFullscreen';
      _names.exitFullscreen = 'exitFullscreen';
      _names.fullscreenEnabled = 'fullscreenEnabled';
      _names.fullscreenElement = 'fullscreenElement';
      _names.fullscreenchange = 'fullscreenchange';
      _names.fullscreenerror = 'fullscreenerror';
      _supportsFullscreen = true;
      return _supportsFullscreen;
    }
    var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
    var name;
    for (var i = 0,
        len = prefixes.length; i < len; ++i) {
      var prefix = prefixes[i];
      name = prefix + 'RequestFullscreen';
      if (typeof body[name] === 'function') {
        _names.requestFullscreen = name;
        _supportsFullscreen = true;
      } else {
        name = prefix + 'RequestFullScreen';
        if (typeof body[name] === 'function') {
          _names.requestFullscreen = name;
          _supportsFullscreen = true;
        }
      }
      name = prefix + 'ExitFullscreen';
      if (typeof document[name] === 'function') {
        _names.exitFullscreen = name;
      } else {
        name = prefix + 'CancelFullScreen';
        if (typeof document[name] === 'function') {
          _names.exitFullscreen = name;
        }
      }
      name = prefix + 'FullscreenEnabled';
      if (document[name] !== undefined) {
        _names.fullscreenEnabled = name;
      } else {
        name = prefix + 'FullScreenEnabled';
        if (document[name] !== undefined) {
          _names.fullscreenEnabled = name;
        }
      }
      name = prefix + 'FullscreenElement';
      if (document[name] !== undefined) {
        _names.fullscreenElement = name;
      } else {
        name = prefix + 'FullScreenElement';
        if (document[name] !== undefined) {
          _names.fullscreenElement = name;
        }
      }
      name = prefix + 'fullscreenchange';
      if (document['on' + name] !== undefined) {
        if (prefix === 'ms') {
          name = 'MSFullscreenChange';
        }
        _names.fullscreenchange = name;
      }
      name = prefix + 'fullscreenerror';
      if (document['on' + name] !== undefined) {
        if (prefix === 'ms') {
          name = 'MSFullscreenError';
        }
        _names.fullscreenerror = name;
      }
    }
    return _supportsFullscreen;
  };
  Fullscreen.requestFullscreen = function(element, vrDevice) {
    if (!Fullscreen.supportsFullscreen()) {
      return;
    }
    element[_names.requestFullscreen]({vrDisplay: vrDevice});
  };
  Fullscreen.exitFullscreen = function() {
    if (!Fullscreen.supportsFullscreen()) {
      return;
    }
    document[_names.exitFullscreen]();
  };
  return Fullscreen;
});

})();
(function() {
var define = $__System.amdDefine;
define("3c", ["15", "5", "76"], function(defaultValue, defined, Fullscreen) {
  'use strict';
  var theNavigator;
  if (typeof navigator !== 'undefined') {
    theNavigator = navigator;
  } else {
    theNavigator = {};
  }
  function extractVersion(versionString) {
    var parts = versionString.split('.');
    for (var i = 0,
        len = parts.length; i < len; ++i) {
      parts[i] = parseInt(parts[i], 10);
    }
    return parts;
  }
  var isChromeResult;
  var chromeVersionResult;
  function isChrome() {
    if (!defined(isChromeResult)) {
      isChromeResult = false;
      if (!isEdge()) {
        var fields = (/ Chrome\/([\.0-9]+)/).exec(theNavigator.userAgent);
        if (fields !== null) {
          isChromeResult = true;
          chromeVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isChromeResult;
  }
  function chromeVersion() {
    return isChrome() && chromeVersionResult;
  }
  var isSafariResult;
  var safariVersionResult;
  function isSafari() {
    if (!defined(isSafariResult)) {
      isSafariResult = false;
      if (!isChrome() && !isEdge() && (/ Safari\/[\.0-9]+/).test(theNavigator.userAgent)) {
        var fields = (/ Version\/([\.0-9]+)/).exec(theNavigator.userAgent);
        if (fields !== null) {
          isSafariResult = true;
          safariVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isSafariResult;
  }
  function safariVersion() {
    return isSafari() && safariVersionResult;
  }
  var isWebkitResult;
  var webkitVersionResult;
  function isWebkit() {
    if (!defined(isWebkitResult)) {
      isWebkitResult = false;
      var fields = (/ AppleWebKit\/([\.0-9]+)(\+?)/).exec(theNavigator.userAgent);
      if (fields !== null) {
        isWebkitResult = true;
        webkitVersionResult = extractVersion(fields[1]);
        webkitVersionResult.isNightly = !!fields[2];
      }
    }
    return isWebkitResult;
  }
  function webkitVersion() {
    return isWebkit() && webkitVersionResult;
  }
  var isInternetExplorerResult;
  var internetExplorerVersionResult;
  function isInternetExplorer() {
    if (!defined(isInternetExplorerResult)) {
      isInternetExplorerResult = false;
      var fields;
      if (theNavigator.appName === 'Microsoft Internet Explorer') {
        fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isInternetExplorerResult = true;
          internetExplorerVersionResult = extractVersion(fields[1]);
        }
      } else if (theNavigator.appName === 'Netscape') {
        fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
        if (fields !== null) {
          isInternetExplorerResult = true;
          internetExplorerVersionResult = extractVersion(fields[1]);
        }
      }
    }
    return isInternetExplorerResult;
  }
  function internetExplorerVersion() {
    return isInternetExplorer() && internetExplorerVersionResult;
  }
  var isEdgeResult;
  var edgeVersionResult;
  function isEdge() {
    if (!defined(isEdgeResult)) {
      isEdgeResult = false;
      var fields = (/ Edge\/([\.0-9]+)/).exec(theNavigator.userAgent);
      if (fields !== null) {
        isEdgeResult = true;
        edgeVersionResult = extractVersion(fields[1]);
      }
    }
    return isEdgeResult;
  }
  function edgeVersion() {
    return isEdge() && edgeVersionResult;
  }
  var isFirefoxResult;
  var firefoxVersionResult;
  function isFirefox() {
    if (!defined(isFirefoxResult)) {
      isFirefoxResult = false;
      var fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
      if (fields !== null) {
        isFirefoxResult = true;
        firefoxVersionResult = extractVersion(fields[1]);
      }
    }
    return isFirefoxResult;
  }
  var isWindowsResult;
  function isWindows() {
    if (!defined(isWindowsResult)) {
      isWindowsResult = /Windows/i.test(theNavigator.appVersion);
    }
    return isWindowsResult;
  }
  function firefoxVersion() {
    return isFirefox() && firefoxVersionResult;
  }
  var hasPointerEvents;
  function supportsPointerEvents() {
    if (!defined(hasPointerEvents)) {
      hasPointerEvents = typeof PointerEvent !== 'undefined' && (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
    }
    return hasPointerEvents;
  }
  var imageRenderingValueResult;
  var supportsImageRenderingPixelatedResult;
  function supportsImageRenderingPixelated() {
    if (!defined(supportsImageRenderingPixelatedResult)) {
      var canvas = document.createElement('canvas');
      canvas.setAttribute('style', 'image-rendering: -moz-crisp-edges;' + 'image-rendering: pixelated;');
      var tmp = canvas.style.imageRendering;
      supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== '';
      if (supportsImageRenderingPixelatedResult) {
        imageRenderingValueResult = tmp;
      }
    }
    return supportsImageRenderingPixelatedResult;
  }
  function imageRenderingValue() {
    return supportsImageRenderingPixelated() ? imageRenderingValueResult : undefined;
  }
  var FeatureDetection = {
    isChrome: isChrome,
    chromeVersion: chromeVersion,
    isSafari: isSafari,
    safariVersion: safariVersion,
    isWebkit: isWebkit,
    webkitVersion: webkitVersion,
    isInternetExplorer: isInternetExplorer,
    internetExplorerVersion: internetExplorerVersion,
    isEdge: isEdge,
    edgeVersion: edgeVersion,
    isFirefox: isFirefox,
    firefoxVersion: firefoxVersion,
    isWindows: isWindows,
    hardwareConcurrency: defaultValue(theNavigator.hardwareConcurrency, 3),
    supportsPointerEvents: supportsPointerEvents,
    supportsImageRenderingPixelated: supportsImageRenderingPixelated,
    imageRenderingValue: imageRenderingValue
  };
  FeatureDetection.supportsFullscreen = function() {
    return Fullscreen.supportsFullscreen();
  };
  FeatureDetection.supportsTypedArrays = function() {
    return typeof ArrayBuffer !== 'undefined';
  };
  FeatureDetection.supportsWebWorkers = function() {
    return typeof Worker !== 'undefined';
  };
  return FeatureDetection;
});

})();
(function() {
var define = $__System.amdDefine;
define("77", ["11"], function(freezeObject) {
  'use strict';
  var WebGLConstants = {
    DEPTH_BUFFER_BIT: 0x00000100,
    STENCIL_BUFFER_BIT: 0x00000400,
    COLOR_BUFFER_BIT: 0x00004000,
    POINTS: 0x0000,
    LINES: 0x0001,
    LINE_LOOP: 0x0002,
    LINE_STRIP: 0x0003,
    TRIANGLES: 0x0004,
    TRIANGLE_STRIP: 0x0005,
    TRIANGLE_FAN: 0x0006,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 0x0300,
    ONE_MINUS_SRC_COLOR: 0x0301,
    SRC_ALPHA: 0x0302,
    ONE_MINUS_SRC_ALPHA: 0x0303,
    DST_ALPHA: 0x0304,
    ONE_MINUS_DST_ALPHA: 0x0305,
    DST_COLOR: 0x0306,
    ONE_MINUS_DST_COLOR: 0x0307,
    SRC_ALPHA_SATURATE: 0x0308,
    FUNC_ADD: 0x8006,
    BLEND_EQUATION: 0x8009,
    BLEND_EQUATION_RGB: 0x8009,
    BLEND_EQUATION_ALPHA: 0x883D,
    FUNC_SUBTRACT: 0x800A,
    FUNC_REVERSE_SUBTRACT: 0x800B,
    BLEND_DST_RGB: 0x80C8,
    BLEND_SRC_RGB: 0x80C9,
    BLEND_DST_ALPHA: 0x80CA,
    BLEND_SRC_ALPHA: 0x80CB,
    CONSTANT_COLOR: 0x8001,
    ONE_MINUS_CONSTANT_COLOR: 0x8002,
    CONSTANT_ALPHA: 0x8003,
    ONE_MINUS_CONSTANT_ALPHA: 0x8004,
    BLEND_COLOR: 0x8005,
    ARRAY_BUFFER: 0x8892,
    ELEMENT_ARRAY_BUFFER: 0x8893,
    ARRAY_BUFFER_BINDING: 0x8894,
    ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
    STREAM_DRAW: 0x88E0,
    STATIC_DRAW: 0x88E4,
    DYNAMIC_DRAW: 0x88E8,
    BUFFER_SIZE: 0x8764,
    BUFFER_USAGE: 0x8765,
    CURRENT_VERTEX_ATTRIB: 0x8626,
    FRONT: 0x0404,
    BACK: 0x0405,
    FRONT_AND_BACK: 0x0408,
    CULL_FACE: 0x0B44,
    BLEND: 0x0BE2,
    DITHER: 0x0BD0,
    STENCIL_TEST: 0x0B90,
    DEPTH_TEST: 0x0B71,
    SCISSOR_TEST: 0x0C11,
    POLYGON_OFFSET_FILL: 0x8037,
    SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
    SAMPLE_COVERAGE: 0x80A0,
    NO_ERROR: 0,
    INVALID_ENUM: 0x0500,
    INVALID_VALUE: 0x0501,
    INVALID_OPERATION: 0x0502,
    OUT_OF_MEMORY: 0x0505,
    CW: 0x0900,
    CCW: 0x0901,
    LINE_WIDTH: 0x0B21,
    ALIASED_POINT_SIZE_RANGE: 0x846D,
    ALIASED_LINE_WIDTH_RANGE: 0x846E,
    CULL_FACE_MODE: 0x0B45,
    FRONT_FACE: 0x0B46,
    DEPTH_RANGE: 0x0B70,
    DEPTH_WRITEMASK: 0x0B72,
    DEPTH_CLEAR_VALUE: 0x0B73,
    DEPTH_FUNC: 0x0B74,
    STENCIL_CLEAR_VALUE: 0x0B91,
    STENCIL_FUNC: 0x0B92,
    STENCIL_FAIL: 0x0B94,
    STENCIL_PASS_DEPTH_FAIL: 0x0B95,
    STENCIL_PASS_DEPTH_PASS: 0x0B96,
    STENCIL_REF: 0x0B97,
    STENCIL_VALUE_MASK: 0x0B93,
    STENCIL_WRITEMASK: 0x0B98,
    STENCIL_BACK_FUNC: 0x8800,
    STENCIL_BACK_FAIL: 0x8801,
    STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
    STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
    STENCIL_BACK_REF: 0x8CA3,
    STENCIL_BACK_VALUE_MASK: 0x8CA4,
    STENCIL_BACK_WRITEMASK: 0x8CA5,
    VIEWPORT: 0x0BA2,
    SCISSOR_BOX: 0x0C10,
    COLOR_CLEAR_VALUE: 0x0C22,
    COLOR_WRITEMASK: 0x0C23,
    UNPACK_ALIGNMENT: 0x0CF5,
    PACK_ALIGNMENT: 0x0D05,
    MAX_TEXTURE_SIZE: 0x0D33,
    MAX_VIEWPORT_DIMS: 0x0D3A,
    SUBPIXEL_BITS: 0x0D50,
    RED_BITS: 0x0D52,
    GREEN_BITS: 0x0D53,
    BLUE_BITS: 0x0D54,
    ALPHA_BITS: 0x0D55,
    DEPTH_BITS: 0x0D56,
    STENCIL_BITS: 0x0D57,
    POLYGON_OFFSET_UNITS: 0x2A00,
    POLYGON_OFFSET_FACTOR: 0x8038,
    TEXTURE_BINDING_2D: 0x8069,
    SAMPLE_BUFFERS: 0x80A8,
    SAMPLES: 0x80A9,
    SAMPLE_COVERAGE_VALUE: 0x80AA,
    SAMPLE_COVERAGE_INVERT: 0x80AB,
    COMPRESSED_TEXTURE_FORMATS: 0x86A3,
    DONT_CARE: 0x1100,
    FASTEST: 0x1101,
    NICEST: 0x1102,
    GENERATE_MIPMAP_HINT: 0x8192,
    BYTE: 0x1400,
    UNSIGNED_BYTE: 0x1401,
    SHORT: 0x1402,
    UNSIGNED_SHORT: 0x1403,
    INT: 0x1404,
    UNSIGNED_INT: 0x1405,
    FLOAT: 0x1406,
    DEPTH_COMPONENT: 0x1902,
    ALPHA: 0x1906,
    RGB: 0x1907,
    RGBA: 0x1908,
    LUMINANCE: 0x1909,
    LUMINANCE_ALPHA: 0x190A,
    UNSIGNED_SHORT_4_4_4_4: 0x8033,
    UNSIGNED_SHORT_5_5_5_1: 0x8034,
    UNSIGNED_SHORT_5_6_5: 0x8363,
    FRAGMENT_SHADER: 0x8B30,
    VERTEX_SHADER: 0x8B31,
    MAX_VERTEX_ATTRIBS: 0x8869,
    MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
    MAX_VARYING_VECTORS: 0x8DFC,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
    MAX_TEXTURE_IMAGE_UNITS: 0x8872,
    MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
    SHADER_TYPE: 0x8B4F,
    DELETE_STATUS: 0x8B80,
    LINK_STATUS: 0x8B82,
    VALIDATE_STATUS: 0x8B83,
    ATTACHED_SHADERS: 0x8B85,
    ACTIVE_UNIFORMS: 0x8B86,
    ACTIVE_ATTRIBUTES: 0x8B89,
    SHADING_LANGUAGE_VERSION: 0x8B8C,
    CURRENT_PROGRAM: 0x8B8D,
    NEVER: 0x0200,
    LESS: 0x0201,
    EQUAL: 0x0202,
    LEQUAL: 0x0203,
    GREATER: 0x0204,
    NOTEQUAL: 0x0205,
    GEQUAL: 0x0206,
    ALWAYS: 0x0207,
    KEEP: 0x1E00,
    REPLACE: 0x1E01,
    INCR: 0x1E02,
    DECR: 0x1E03,
    INVERT: 0x150A,
    INCR_WRAP: 0x8507,
    DECR_WRAP: 0x8508,
    VENDOR: 0x1F00,
    RENDERER: 0x1F01,
    VERSION: 0x1F02,
    NEAREST: 0x2600,
    LINEAR: 0x2601,
    NEAREST_MIPMAP_NEAREST: 0x2700,
    LINEAR_MIPMAP_NEAREST: 0x2701,
    NEAREST_MIPMAP_LINEAR: 0x2702,
    LINEAR_MIPMAP_LINEAR: 0x2703,
    TEXTURE_MAG_FILTER: 0x2800,
    TEXTURE_MIN_FILTER: 0x2801,
    TEXTURE_WRAP_S: 0x2802,
    TEXTURE_WRAP_T: 0x2803,
    TEXTURE_2D: 0x0DE1,
    TEXTURE: 0x1702,
    TEXTURE_CUBE_MAP: 0x8513,
    TEXTURE_BINDING_CUBE_MAP: 0x8514,
    TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
    MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
    TEXTURE0: 0x84C0,
    TEXTURE1: 0x84C1,
    TEXTURE2: 0x84C2,
    TEXTURE3: 0x84C3,
    TEXTURE4: 0x84C4,
    TEXTURE5: 0x84C5,
    TEXTURE6: 0x84C6,
    TEXTURE7: 0x84C7,
    TEXTURE8: 0x84C8,
    TEXTURE9: 0x84C9,
    TEXTURE10: 0x84CA,
    TEXTURE11: 0x84CB,
    TEXTURE12: 0x84CC,
    TEXTURE13: 0x84CD,
    TEXTURE14: 0x84CE,
    TEXTURE15: 0x84CF,
    TEXTURE16: 0x84D0,
    TEXTURE17: 0x84D1,
    TEXTURE18: 0x84D2,
    TEXTURE19: 0x84D3,
    TEXTURE20: 0x84D4,
    TEXTURE21: 0x84D5,
    TEXTURE22: 0x84D6,
    TEXTURE23: 0x84D7,
    TEXTURE24: 0x84D8,
    TEXTURE25: 0x84D9,
    TEXTURE26: 0x84DA,
    TEXTURE27: 0x84DB,
    TEXTURE28: 0x84DC,
    TEXTURE29: 0x84DD,
    TEXTURE30: 0x84DE,
    TEXTURE31: 0x84DF,
    ACTIVE_TEXTURE: 0x84E0,
    REPEAT: 0x2901,
    CLAMP_TO_EDGE: 0x812F,
    MIRRORED_REPEAT: 0x8370,
    FLOAT_VEC2: 0x8B50,
    FLOAT_VEC3: 0x8B51,
    FLOAT_VEC4: 0x8B52,
    INT_VEC2: 0x8B53,
    INT_VEC3: 0x8B54,
    INT_VEC4: 0x8B55,
    BOOL: 0x8B56,
    BOOL_VEC2: 0x8B57,
    BOOL_VEC3: 0x8B58,
    BOOL_VEC4: 0x8B59,
    FLOAT_MAT2: 0x8B5A,
    FLOAT_MAT3: 0x8B5B,
    FLOAT_MAT4: 0x8B5C,
    SAMPLER_2D: 0x8B5E,
    SAMPLER_CUBE: 0x8B60,
    VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
    VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
    VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
    VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
    VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,
    IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
    IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,
    COMPILE_STATUS: 0x8B81,
    LOW_FLOAT: 0x8DF0,
    MEDIUM_FLOAT: 0x8DF1,
    HIGH_FLOAT: 0x8DF2,
    LOW_INT: 0x8DF3,
    MEDIUM_INT: 0x8DF4,
    HIGH_INT: 0x8DF5,
    FRAMEBUFFER: 0x8D40,
    RENDERBUFFER: 0x8D41,
    RGBA4: 0x8056,
    RGB5_A1: 0x8057,
    RGB565: 0x8D62,
    DEPTH_COMPONENT16: 0x81A5,
    STENCIL_INDEX: 0x1901,
    STENCIL_INDEX8: 0x8D48,
    DEPTH_STENCIL: 0x84F9,
    RENDERBUFFER_WIDTH: 0x8D42,
    RENDERBUFFER_HEIGHT: 0x8D43,
    RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
    RENDERBUFFER_RED_SIZE: 0x8D50,
    RENDERBUFFER_GREEN_SIZE: 0x8D51,
    RENDERBUFFER_BLUE_SIZE: 0x8D52,
    RENDERBUFFER_ALPHA_SIZE: 0x8D53,
    RENDERBUFFER_DEPTH_SIZE: 0x8D54,
    RENDERBUFFER_STENCIL_SIZE: 0x8D55,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
    COLOR_ATTACHMENT0: 0x8CE0,
    DEPTH_ATTACHMENT: 0x8D00,
    STENCIL_ATTACHMENT: 0x8D20,
    DEPTH_STENCIL_ATTACHMENT: 0x821A,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 0x8CD5,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
    FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
    FRAMEBUFFER_BINDING: 0x8CA6,
    RENDERBUFFER_BINDING: 0x8CA7,
    MAX_RENDERBUFFER_SIZE: 0x84E8,
    INVALID_FRAMEBUFFER_OPERATION: 0x0506,
    UNPACK_FLIP_Y_WEBGL: 0x9240,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
    CONTEXT_LOST_WEBGL: 0x9242,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
    BROWSER_DEFAULT_WEBGL: 0x9244,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,
    COMPRESSED_RGB_ETC1_WEBGL: 0x8D64,
    DOUBLE: 0x140A,
    READ_BUFFER: 0x0C02,
    UNPACK_ROW_LENGTH: 0x0CF2,
    UNPACK_SKIP_ROWS: 0x0CF3,
    UNPACK_SKIP_PIXELS: 0x0CF4,
    PACK_ROW_LENGTH: 0x0D02,
    PACK_SKIP_ROWS: 0x0D03,
    PACK_SKIP_PIXELS: 0x0D04,
    COLOR: 0x1800,
    DEPTH: 0x1801,
    STENCIL: 0x1802,
    RED: 0x1903,
    RGB8: 0x8051,
    RGBA8: 0x8058,
    RGB10_A2: 0x8059,
    TEXTURE_BINDING_3D: 0x806A,
    UNPACK_SKIP_IMAGES: 0x806D,
    UNPACK_IMAGE_HEIGHT: 0x806E,
    TEXTURE_3D: 0x806F,
    TEXTURE_WRAP_R: 0x8072,
    MAX_3D_TEXTURE_SIZE: 0x8073,
    UNSIGNED_INT_2_10_10_10_REV: 0x8368,
    MAX_ELEMENTS_VERTICES: 0x80E8,
    MAX_ELEMENTS_INDICES: 0x80E9,
    TEXTURE_MIN_LOD: 0x813A,
    TEXTURE_MAX_LOD: 0x813B,
    TEXTURE_BASE_LEVEL: 0x813C,
    TEXTURE_MAX_LEVEL: 0x813D,
    MIN: 0x8007,
    MAX: 0x8008,
    DEPTH_COMPONENT24: 0x81A6,
    MAX_TEXTURE_LOD_BIAS: 0x84FD,
    TEXTURE_COMPARE_MODE: 0x884C,
    TEXTURE_COMPARE_FUNC: 0x884D,
    CURRENT_QUERY: 0x8865,
    QUERY_RESULT: 0x8866,
    QUERY_RESULT_AVAILABLE: 0x8867,
    STREAM_READ: 0x88E1,
    STREAM_COPY: 0x88E2,
    STATIC_READ: 0x88E5,
    STATIC_COPY: 0x88E6,
    DYNAMIC_READ: 0x88E9,
    DYNAMIC_COPY: 0x88EA,
    MAX_DRAW_BUFFERS: 0x8824,
    DRAW_BUFFER0: 0x8825,
    DRAW_BUFFER1: 0x8826,
    DRAW_BUFFER2: 0x8827,
    DRAW_BUFFER3: 0x8828,
    DRAW_BUFFER4: 0x8829,
    DRAW_BUFFER5: 0x882A,
    DRAW_BUFFER6: 0x882B,
    DRAW_BUFFER7: 0x882C,
    DRAW_BUFFER8: 0x882D,
    DRAW_BUFFER9: 0x882E,
    DRAW_BUFFER10: 0x882F,
    DRAW_BUFFER11: 0x8830,
    DRAW_BUFFER12: 0x8831,
    DRAW_BUFFER13: 0x8832,
    DRAW_BUFFER14: 0x8833,
    DRAW_BUFFER15: 0x8834,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49,
    MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A,
    SAMPLER_3D: 0x8B5F,
    SAMPLER_2D_SHADOW: 0x8B62,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
    PIXEL_PACK_BUFFER: 0x88EB,
    PIXEL_UNPACK_BUFFER: 0x88EC,
    PIXEL_PACK_BUFFER_BINDING: 0x88ED,
    PIXEL_UNPACK_BUFFER_BINDING: 0x88EF,
    FLOAT_MAT2x3: 0x8B65,
    FLOAT_MAT2x4: 0x8B66,
    FLOAT_MAT3x2: 0x8B67,
    FLOAT_MAT3x4: 0x8B68,
    FLOAT_MAT4x2: 0x8B69,
    FLOAT_MAT4x3: 0x8B6A,
    SRGB: 0x8C40,
    SRGB8: 0x8C41,
    SRGB8_ALPHA8: 0x8C43,
    COMPARE_REF_TO_TEXTURE: 0x884E,
    RGBA32F: 0x8814,
    RGB32F: 0x8815,
    RGBA16F: 0x881A,
    RGB16F: 0x881B,
    VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD,
    MAX_ARRAY_TEXTURE_LAYERS: 0x88FF,
    MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
    MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
    MAX_VARYING_COMPONENTS: 0x8B4B,
    TEXTURE_2D_ARRAY: 0x8C1A,
    TEXTURE_BINDING_2D_ARRAY: 0x8C1D,
    R11F_G11F_B10F: 0x8C3A,
    UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B,
    RGB9_E5: 0x8C3D,
    UNSIGNED_INT_5_9_9_9_REV: 0x8C3E,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80,
    TRANSFORM_FEEDBACK_VARYINGS: 0x8C83,
    TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
    RASTERIZER_DISCARD: 0x8C89,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,
    INTERLEAVED_ATTRIBS: 0x8C8C,
    SEPARATE_ATTRIBS: 0x8C8D,
    TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,
    RGBA32UI: 0x8D70,
    RGB32UI: 0x8D71,
    RGBA16UI: 0x8D76,
    RGB16UI: 0x8D77,
    RGBA8UI: 0x8D7C,
    RGB8UI: 0x8D7D,
    RGBA32I: 0x8D82,
    RGB32I: 0x8D83,
    RGBA16I: 0x8D88,
    RGB16I: 0x8D89,
    RGBA8I: 0x8D8E,
    RGB8I: 0x8D8F,
    RED_INTEGER: 0x8D94,
    RGB_INTEGER: 0x8D98,
    RGBA_INTEGER: 0x8D99,
    SAMPLER_2D_ARRAY: 0x8DC1,
    SAMPLER_2D_ARRAY_SHADOW: 0x8DC4,
    SAMPLER_CUBE_SHADOW: 0x8DC5,
    UNSIGNED_INT_VEC2: 0x8DC6,
    UNSIGNED_INT_VEC3: 0x8DC7,
    UNSIGNED_INT_VEC4: 0x8DC8,
    INT_SAMPLER_2D: 0x8DCA,
    INT_SAMPLER_3D: 0x8DCB,
    INT_SAMPLER_CUBE: 0x8DCC,
    INT_SAMPLER_2D_ARRAY: 0x8DCF,
    UNSIGNED_INT_SAMPLER_2D: 0x8DD2,
    UNSIGNED_INT_SAMPLER_3D: 0x8DD3,
    UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,
    DEPTH_COMPONENT32F: 0x8CAC,
    DEPTH32F_STENCIL8: 0x8CAD,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
    FRAMEBUFFER_DEFAULT: 0x8218,
    UNSIGNED_INT_24_8: 0x84FA,
    DEPTH24_STENCIL8: 0x88F0,
    UNSIGNED_NORMALIZED: 0x8C17,
    DRAW_FRAMEBUFFER_BINDING: 0x8CA6,
    READ_FRAMEBUFFER: 0x8CA8,
    DRAW_FRAMEBUFFER: 0x8CA9,
    READ_FRAMEBUFFER_BINDING: 0x8CAA,
    RENDERBUFFER_SAMPLES: 0x8CAB,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4,
    MAX_COLOR_ATTACHMENTS: 0x8CDF,
    COLOR_ATTACHMENT1: 0x8CE1,
    COLOR_ATTACHMENT2: 0x8CE2,
    COLOR_ATTACHMENT3: 0x8CE3,
    COLOR_ATTACHMENT4: 0x8CE4,
    COLOR_ATTACHMENT5: 0x8CE5,
    COLOR_ATTACHMENT6: 0x8CE6,
    COLOR_ATTACHMENT7: 0x8CE7,
    COLOR_ATTACHMENT8: 0x8CE8,
    COLOR_ATTACHMENT9: 0x8CE9,
    COLOR_ATTACHMENT10: 0x8CEA,
    COLOR_ATTACHMENT11: 0x8CEB,
    COLOR_ATTACHMENT12: 0x8CEC,
    COLOR_ATTACHMENT13: 0x8CED,
    COLOR_ATTACHMENT14: 0x8CEE,
    COLOR_ATTACHMENT15: 0x8CEF,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56,
    MAX_SAMPLES: 0x8D57,
    HALF_FLOAT: 0x140B,
    RG: 0x8227,
    RG_INTEGER: 0x8228,
    R8: 0x8229,
    RG8: 0x822B,
    R16F: 0x822D,
    R32F: 0x822E,
    RG16F: 0x822F,
    RG32F: 0x8230,
    R8I: 0x8231,
    R8UI: 0x8232,
    R16I: 0x8233,
    R16UI: 0x8234,
    R32I: 0x8235,
    R32UI: 0x8236,
    RG8I: 0x8237,
    RG8UI: 0x8238,
    RG16I: 0x8239,
    RG16UI: 0x823A,
    RG32I: 0x823B,
    RG32UI: 0x823C,
    VERTEX_ARRAY_BINDING: 0x85B5,
    R8_SNORM: 0x8F94,
    RG8_SNORM: 0x8F95,
    RGB8_SNORM: 0x8F96,
    RGBA8_SNORM: 0x8F97,
    SIGNED_NORMALIZED: 0x8F9C,
    COPY_READ_BUFFER: 0x8F36,
    COPY_WRITE_BUFFER: 0x8F37,
    COPY_READ_BUFFER_BINDING: 0x8F36,
    COPY_WRITE_BUFFER_BINDING: 0x8F37,
    UNIFORM_BUFFER: 0x8A11,
    UNIFORM_BUFFER_BINDING: 0x8A28,
    UNIFORM_BUFFER_START: 0x8A29,
    UNIFORM_BUFFER_SIZE: 0x8A2A,
    MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D,
    MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E,
    MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F,
    MAX_UNIFORM_BLOCK_SIZE: 0x8A30,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34,
    ACTIVE_UNIFORM_BLOCKS: 0x8A36,
    UNIFORM_TYPE: 0x8A37,
    UNIFORM_SIZE: 0x8A38,
    UNIFORM_BLOCK_INDEX: 0x8A3A,
    UNIFORM_OFFSET: 0x8A3B,
    UNIFORM_ARRAY_STRIDE: 0x8A3C,
    UNIFORM_MATRIX_STRIDE: 0x8A3D,
    UNIFORM_IS_ROW_MAJOR: 0x8A3E,
    UNIFORM_BLOCK_BINDING: 0x8A3F,
    UNIFORM_BLOCK_DATA_SIZE: 0x8A40,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,
    INVALID_INDEX: 0xFFFFFFFF,
    MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
    MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
    MAX_SERVER_WAIT_TIMEOUT: 0x9111,
    OBJECT_TYPE: 0x9112,
    SYNC_CONDITION: 0x9113,
    SYNC_STATUS: 0x9114,
    SYNC_FLAGS: 0x9115,
    SYNC_FENCE: 0x9116,
    SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
    UNSIGNALED: 0x9118,
    SIGNALED: 0x9119,
    ALREADY_SIGNALED: 0x911A,
    TIMEOUT_EXPIRED: 0x911B,
    CONDITION_SATISFIED: 0x911C,
    WAIT_FAILED: 0x911D,
    SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE,
    ANY_SAMPLES_PASSED: 0x8C2F,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A,
    SAMPLER_BINDING: 0x8919,
    RGB10_A2UI: 0x906F,
    INT_2_10_10_10_REV: 0x8D9F,
    TRANSFORM_FEEDBACK: 0x8E22,
    TRANSFORM_FEEDBACK_PAUSED: 0x8E23,
    TRANSFORM_FEEDBACK_ACTIVE: 0x8E24,
    TRANSFORM_FEEDBACK_BINDING: 0x8E25,
    COMPRESSED_R11_EAC: 0x9270,
    COMPRESSED_SIGNED_R11_EAC: 0x9271,
    COMPRESSED_RG11_EAC: 0x9272,
    COMPRESSED_SIGNED_RG11_EAC: 0x9273,
    COMPRESSED_RGB8_ETC2: 0x9274,
    COMPRESSED_SRGB8_ETC2: 0x9275,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,
    COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,
    TEXTURE_IMMUTABLE_FORMAT: 0x912F,
    MAX_ELEMENT_INDEX: 0x8D6B,
    TEXTURE_IMMUTABLE_LEVELS: 0x82DF,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF
  };
  return freezeObject(WebGLConstants);
});

})();
(function() {
var define = $__System.amdDefine;
define("78", ["15", "5", "7", "3c", "11", "77"], function(defaultValue, defined, DeveloperError, FeatureDetection, freezeObject, WebGLConstants) {
  'use strict';
  if (!FeatureDetection.supportsTypedArrays()) {
    return {};
  }
  var ComponentDatatype = {
    BYTE: WebGLConstants.BYTE,
    UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,
    SHORT: WebGLConstants.SHORT,
    UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,
    INT: WebGLConstants.INT,
    UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,
    FLOAT: WebGLConstants.FLOAT,
    DOUBLE: WebGLConstants.DOUBLE
  };
  ComponentDatatype.getSizeInBytes = function(componentDatatype) {
    if (!defined(componentDatatype)) {
      throw new DeveloperError('value is required.');
    }
    switch (componentDatatype) {
      case ComponentDatatype.BYTE:
        return Int8Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.SHORT:
        return Int16Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.INT:
        return Int32Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.FLOAT:
        return Float32Array.BYTES_PER_ELEMENT;
      case ComponentDatatype.DOUBLE:
        return Float64Array.BYTES_PER_ELEMENT;
      default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
  };
  ComponentDatatype.fromTypedArray = function(array) {
    if (array instanceof Int8Array) {
      return ComponentDatatype.BYTE;
    }
    if (array instanceof Uint8Array) {
      return ComponentDatatype.UNSIGNED_BYTE;
    }
    if (array instanceof Int16Array) {
      return ComponentDatatype.SHORT;
    }
    if (array instanceof Uint16Array) {
      return ComponentDatatype.UNSIGNED_SHORT;
    }
    if (array instanceof Int32Array) {
      return ComponentDatatype.INT;
    }
    if (array instanceof Uint32Array) {
      return ComponentDatatype.UNSIGNED_INT;
    }
    if (array instanceof Float32Array) {
      return ComponentDatatype.FLOAT;
    }
    if (array instanceof Float64Array) {
      return ComponentDatatype.DOUBLE;
    }
  };
  ComponentDatatype.validate = function(componentDatatype) {
    return defined(componentDatatype) && (componentDatatype === ComponentDatatype.BYTE || componentDatatype === ComponentDatatype.UNSIGNED_BYTE || componentDatatype === ComponentDatatype.SHORT || componentDatatype === ComponentDatatype.UNSIGNED_SHORT || componentDatatype === ComponentDatatype.INT || componentDatatype === ComponentDatatype.UNSIGNED_INT || componentDatatype === ComponentDatatype.FLOAT || componentDatatype === ComponentDatatype.DOUBLE);
  };
  ComponentDatatype.createTypedArray = function(componentDatatype, valuesOrLength) {
    if (!defined(componentDatatype)) {
      throw new DeveloperError('componentDatatype is required.');
    }
    if (!defined(valuesOrLength)) {
      throw new DeveloperError('valuesOrLength is required.');
    }
    switch (componentDatatype) {
      case ComponentDatatype.BYTE:
        return new Int8Array(valuesOrLength);
      case ComponentDatatype.UNSIGNED_BYTE:
        return new Uint8Array(valuesOrLength);
      case ComponentDatatype.SHORT:
        return new Int16Array(valuesOrLength);
      case ComponentDatatype.UNSIGNED_SHORT:
        return new Uint16Array(valuesOrLength);
      case ComponentDatatype.INT:
        return new Int32Array(valuesOrLength);
      case ComponentDatatype.UNSIGNED_INT:
        return new Uint32Array(valuesOrLength);
      case ComponentDatatype.FLOAT:
        return new Float32Array(valuesOrLength);
      case ComponentDatatype.DOUBLE:
        return new Float64Array(valuesOrLength);
      default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
  };
  ComponentDatatype.createArrayBufferView = function(componentDatatype, buffer, byteOffset, length) {
    if (!defined(componentDatatype)) {
      throw new DeveloperError('componentDatatype is required.');
    }
    if (!defined(buffer)) {
      throw new DeveloperError('buffer is required.');
    }
    byteOffset = defaultValue(byteOffset, 0);
    length = defaultValue(length, (buffer.byteLength - byteOffset) / ComponentDatatype.getSizeInBytes(componentDatatype));
    switch (componentDatatype) {
      case ComponentDatatype.BYTE:
        return new Int8Array(buffer, byteOffset, length);
      case ComponentDatatype.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, length);
      case ComponentDatatype.SHORT:
        return new Int16Array(buffer, byteOffset, length);
      case ComponentDatatype.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, length);
      case ComponentDatatype.INT:
        return new Int32Array(buffer, byteOffset, length);
      case ComponentDatatype.UNSIGNED_INT:
        return new Uint32Array(buffer, byteOffset, length);
      case ComponentDatatype.FLOAT:
        return new Float32Array(buffer, byteOffset, length);
      case ComponentDatatype.DOUBLE:
        return new Float64Array(buffer, byteOffset, length);
      default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
  };
  ComponentDatatype.fromName = function(name) {
    switch (name) {
      case 'BYTE':
        return ComponentDatatype.BYTE;
      case 'UNSIGNED_BYTE':
        return ComponentDatatype.UNSIGNED_BYTE;
      case 'SHORT':
        return ComponentDatatype.SHORT;
      case 'UNSIGNED_SHORT':
        return ComponentDatatype.UNSIGNED_SHORT;
      case 'INT':
        return ComponentDatatype.INT;
      case 'UNSIGNED_INT':
        return ComponentDatatype.UNSIGNED_INT;
      case 'FLOAT':
        return ComponentDatatype.FLOAT;
      case 'DOUBLE':
        return ComponentDatatype.DOUBLE;
      default:
        throw new DeveloperError('name is not a valid value.');
    }
  };
  return freezeObject(ComponentDatatype);
});

})();
(function() {
var define = $__System.amdDefine;
define("32", ["54", "15", "5", "7", "11", "d"], function(Check, defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
  'use strict';
  function Cartesian4(x, y, z, w) {
    this.x = defaultValue(x, 0.0);
    this.y = defaultValue(y, 0.0);
    this.z = defaultValue(z, 0.0);
    this.w = defaultValue(w, 0.0);
  }
  Cartesian4.fromElements = function(x, y, z, w, result) {
    if (!defined(result)) {
      return new Cartesian4(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Cartesian4.fromColor = function(color, result) {
    Check.typeOf.object('color', color);
    if (!defined(result)) {
      return new Cartesian4(color.red, color.green, color.blue, color.alpha);
    }
    result.x = color.red;
    result.y = color.green;
    result.z = color.blue;
    result.w = color.alpha;
    return result;
  };
  Cartesian4.clone = function(cartesian, result) {
    if (!defined(cartesian)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    result.w = cartesian.w;
    return result;
  };
  Cartesian4.packedLength = 4;
  Cartesian4.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex++] = value.z;
    array[startingIndex] = value.w;
    return array;
  };
  Cartesian4.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Cartesian4();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex++];
    result.w = array[startingIndex];
    return result;
  };
  Cartesian4.packArray = function(array, result) {
    Check.defined('array', array);
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length * 4);
    } else {
      result.length = length * 4;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian4.pack(array[i], result, i * 4);
    }
    return result;
  };
  Cartesian4.unpackArray = function(array, result) {
    Check.defined('array', array);
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length / 4);
    } else {
      result.length = length / 4;
    }
    for (var i = 0; i < length; i += 4) {
      var index = i / 4;
      result[index] = Cartesian4.unpack(array, i, result[index]);
    }
    return result;
  };
  Cartesian4.fromArray = Cartesian4.unpack;
  Cartesian4.maximumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  };
  Cartesian4.minimumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
  };
  Cartesian4.minimumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    result.w = Math.min(first.w, second.w);
    return result;
  };
  Cartesian4.maximumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    result.w = Math.max(first.w, second.w);
    return result;
  };
  Cartesian4.magnitudeSquared = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
  };
  Cartesian4.magnitude = function(cartesian) {
    return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
  };
  var distanceScratch = new Cartesian4();
  Cartesian4.distance = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitude(distanceScratch);
  };
  Cartesian4.distanceSquared = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitudeSquared(distanceScratch);
  };
  Cartesian4.normalize = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var magnitude = Cartesian4.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;
    result.w = cartesian.w / magnitude;
    if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {
      throw new DeveloperError('normalized result is not a number');
    }
    return result;
  };
  Cartesian4.dot = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Cartesian4.multiplyComponents = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    result.w = left.w * right.w;
    return result;
  };
  Cartesian4.divideComponents = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x / right.x;
    result.y = left.y / right.y;
    result.z = left.z / right.z;
    result.w = left.w / right.w;
    return result;
  };
  Cartesian4.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    result.w = left.w + right.w;
    return result;
  };
  Cartesian4.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    result.w = left.w - right.w;
    return result;
  };
  Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    result.w = cartesian.w * scalar;
    return result;
  };
  Cartesian4.divideByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    result.w = cartesian.w / scalar;
    return result;
  };
  Cartesian4.negate = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    result.w = -cartesian.w;
    return result;
  };
  Cartesian4.abs = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    result.w = Math.abs(cartesian.w);
    return result;
  };
  var lerpScratch = new Cartesian4();
  Cartesian4.lerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    Cartesian4.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian4.add(lerpScratch, result, result);
  };
  var mostOrthogonalAxisScratch = new Cartesian4();
  Cartesian4.mostOrthogonalAxis = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian4.abs(f, f);
    if (f.x <= f.y) {
      if (f.x <= f.z) {
        if (f.x <= f.w) {
          result = Cartesian4.clone(Cartesian4.UNIT_X, result);
        } else {
          result = Cartesian4.clone(Cartesian4.UNIT_W, result);
        }
      } else if (f.z <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
      } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
      }
    } else if (f.y <= f.z) {
      if (f.y <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
      } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
      }
    } else if (f.z <= f.w) {
      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
    } else {
      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
    }
    return result;
  };
  Cartesian4.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z) && (left.w === right.w));
  };
  Cartesian4.equalsArray = function(cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];
  };
  Cartesian4.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon));
  };
  Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));
  Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));
  Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));
  Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));
  Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));
  Cartesian4.prototype.clone = function(result) {
    return Cartesian4.clone(this, result);
  };
  Cartesian4.prototype.equals = function(right) {
    return Cartesian4.equals(this, right);
  };
  Cartesian4.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };
  Cartesian4.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
  };
  return Cartesian4;
});

})();
(function() {
var define = $__System.amdDefine;
define("1f", ["54", "15", "5", "7", "11", "d"], function(Check, defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
  'use strict';
  function Cartesian3(x, y, z) {
    this.x = defaultValue(x, 0.0);
    this.y = defaultValue(y, 0.0);
    this.z = defaultValue(z, 0.0);
  }
  Cartesian3.fromSpherical = function(spherical, result) {
    Check.typeOf.object('spherical', spherical);
    if (!defined(result)) {
      result = new Cartesian3();
    }
    var clock = spherical.clock;
    var cone = spherical.cone;
    var magnitude = defaultValue(spherical.magnitude, 1.0);
    var radial = magnitude * Math.sin(cone);
    result.x = radial * Math.cos(clock);
    result.y = radial * Math.sin(clock);
    result.z = magnitude * Math.cos(cone);
    return result;
  };
  Cartesian3.fromElements = function(x, y, z, result) {
    if (!defined(result)) {
      return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Cartesian3.clone = function(cartesian, result) {
    if (!defined(cartesian)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    return result;
  };
  Cartesian3.fromCartesian4 = Cartesian3.clone;
  Cartesian3.packedLength = 3;
  Cartesian3.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex] = value.z;
    return array;
  };
  Cartesian3.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Cartesian3();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex];
    return result;
  };
  Cartesian3.packArray = function(array, result) {
    Check.defined('array', array);
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length * 3);
    } else {
      result.length = length * 3;
    }
    for (var i = 0; i < length; ++i) {
      Cartesian3.pack(array[i], result, i * 3);
    }
    return result;
  };
  Cartesian3.unpackArray = function(array, result) {
    Check.defined('array', array);
    Check.typeOf.number.greaterThanOrEquals('array.length', array.length, 3);
    if (array.length % 3 !== 0) {
      throw new DeveloperError('array length must be a multiple of 3.');
    }
    var length = array.length;
    if (!defined(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var index = i / 3;
      result[index] = Cartesian3.unpack(array, i, result[index]);
    }
    return result;
  };
  Cartesian3.fromArray = Cartesian3.unpack;
  Cartesian3.maximumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.max(cartesian.x, cartesian.y, cartesian.z);
  };
  Cartesian3.minimumComponent = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return Math.min(cartesian.x, cartesian.y, cartesian.z);
  };
  Cartesian3.minimumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    return result;
  };
  Cartesian3.maximumByComponent = function(first, second, result) {
    Check.typeOf.object('first', first);
    Check.typeOf.object('second', second);
    Check.typeOf.object('result', result);
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    return result;
  };
  Cartesian3.magnitudeSquared = function(cartesian) {
    Check.typeOf.object('cartesian', cartesian);
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
  };
  Cartesian3.magnitude = function(cartesian) {
    return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
  };
  var distanceScratch = new Cartesian3();
  Cartesian3.distance = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian3.subtract(left, right, distanceScratch);
    return Cartesian3.magnitude(distanceScratch);
  };
  Cartesian3.distanceSquared = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian3.subtract(left, right, distanceScratch);
    return Cartesian3.magnitudeSquared(distanceScratch);
  };
  Cartesian3.normalize = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var magnitude = Cartesian3.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;
    if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {
      throw new DeveloperError('normalized result is not a number');
    }
    return result;
  };
  Cartesian3.dot = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    return left.x * right.x + left.y * right.y + left.z * right.z;
  };
  Cartesian3.multiplyComponents = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    return result;
  };
  Cartesian3.divideComponents = function(left, right, result) {
    if (!defined(left)) {
      throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
      throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
      throw new DeveloperError('result is required');
    }
    result.x = left.x / right.x;
    result.y = left.y / right.y;
    result.z = left.z / right.z;
    return result;
  };
  Cartesian3.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    return result;
  };
  Cartesian3.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    return result;
  };
  Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    return result;
  };
  Cartesian3.divideByScalar = function(cartesian, scalar, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    return result;
  };
  Cartesian3.negate = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    return result;
  };
  Cartesian3.abs = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    return result;
  };
  var lerpScratch = new Cartesian3();
  Cartesian3.lerp = function(start, end, t, result) {
    Check.typeOf.object('start', start);
    Check.typeOf.object('end', end);
    Check.typeOf.number('t', t);
    Check.typeOf.object('result', result);
    Cartesian3.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
    return Cartesian3.add(lerpScratch, result, result);
  };
  var angleBetweenScratch = new Cartesian3();
  var angleBetweenScratch2 = new Cartesian3();
  Cartesian3.angleBetween = function(left, right) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Cartesian3.normalize(left, angleBetweenScratch);
    Cartesian3.normalize(right, angleBetweenScratch2);
    var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
    var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
    return Math.atan2(sine, cosine);
  };
  var mostOrthogonalAxisScratch = new Cartesian3();
  Cartesian3.mostOrthogonalAxis = function(cartesian, result) {
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian3.abs(f, f);
    if (f.x <= f.y) {
      if (f.x <= f.z) {
        result = Cartesian3.clone(Cartesian3.UNIT_X, result);
      } else {
        result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
      }
    } else {
      if (f.y <= f.z) {
        result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
      } else {
        result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
      }
    }
    return result;
  };
  Cartesian3.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left.x === right.x) && (left.y === right.y) && (left.z === right.z));
  };
  Cartesian3.equalsArray = function(cartesian, array, offset) {
    return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];
  };
  Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
    return (left === right) || (defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon));
  };
  Cartesian3.cross = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    var leftX = left.x;
    var leftY = left.y;
    var leftZ = left.z;
    var rightX = right.x;
    var rightY = right.y;
    var rightZ = right.z;
    var x = leftY * rightZ - leftZ * rightY;
    var y = leftZ * rightX - leftX * rightZ;
    var z = leftX * rightY - leftY * rightX;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {
    Check.typeOf.number('longitude', longitude);
    Check.typeOf.number('latitude', latitude);
    longitude = CesiumMath.toRadians(longitude);
    latitude = CesiumMath.toRadians(latitude);
    return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);
  };
  var scratchN = new Cartesian3();
  var scratchK = new Cartesian3();
  var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);
  Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {
    Check.typeOf.number('longitude', longitude);
    Check.typeOf.number('latitude', latitude);
    height = defaultValue(height, 0.0);
    var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;
    var cosLatitude = Math.cos(latitude);
    scratchN.x = cosLatitude * Math.cos(longitude);
    scratchN.y = cosLatitude * Math.sin(longitude);
    scratchN.z = Math.sin(latitude);
    scratchN = Cartesian3.normalize(scratchN, scratchN);
    Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
    var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
    scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
    scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);
    if (!defined(result)) {
      result = new Cartesian3();
    }
    return Cartesian3.add(scratchK, scratchN, result);
  };
  Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
      throw new DeveloperError('the number of coordinates must be a multiple of 2 and at least 2');
    }
    var length = coordinates.length;
    if (!defined(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var index = i / 2;
      result[index] = Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);
    }
    return result;
  };
  Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
      throw new DeveloperError('the number of coordinates must be a multiple of 2 and at least 2');
    }
    var length = coordinates.length;
    if (!defined(result)) {
      result = new Array(length / 2);
    } else {
      result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var index = i / 2;
      result[index] = Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);
    }
    return result;
  };
  Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
      throw new DeveloperError('the number of coordinates must be a multiple of 3 and at least 3');
    }
    var length = coordinates.length;
    if (!defined(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var height = coordinates[i + 2];
      var index = i / 3;
      result[index] = Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);
    }
    return result;
  };
  Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {
    Check.defined('coordinates', coordinates);
    if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
      throw new DeveloperError('the number of coordinates must be a multiple of 3 and at least 3');
    }
    var length = coordinates.length;
    if (!defined(result)) {
      result = new Array(length / 3);
    } else {
      result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
      var longitude = coordinates[i];
      var latitude = coordinates[i + 1];
      var height = coordinates[i + 2];
      var index = i / 3;
      result[index] = Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);
    }
    return result;
  };
  Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));
  Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));
  Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));
  Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));
  Cartesian3.prototype.clone = function(result) {
    return Cartesian3.clone(this, result);
  };
  Cartesian3.prototype.equals = function(right) {
    return Cartesian3.equals(this, right);
  };
  Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
    return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
  };
  Cartesian3.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
  };
  return Cartesian3;
});

})();
(function() {
var define = $__System.amdDefine;
define("54", ["5", "7"], function(defined, DeveloperError) {
  'use strict';
  var Check = {};
  Check.typeOf = {};
  function getUndefinedErrorMessage(name) {
    return name + ' is required, actual value was undefined';
  }
  function getFailedTypeErrorMessage(actual, expected, name) {
    return 'Expected ' + name + ' to be typeof ' + expected + ', actual typeof was ' + actual;
  }
  Check.defined = function(name, test) {
    if (!defined(test)) {
      throw new DeveloperError(getUndefinedErrorMessage(name));
    }
  };
  Check.typeOf.func = function(name, test) {
    if (typeof test !== 'function') {
      throw new DeveloperError(getFailedTypeErrorMessage(typeof test, 'function', name));
    }
  };
  Check.typeOf.string = function(name, test) {
    if (typeof test !== 'string') {
      throw new DeveloperError(getFailedTypeErrorMessage(typeof test, 'string', name));
    }
  };
  Check.typeOf.number = function(name, test) {
    if (typeof test !== 'number') {
      throw new DeveloperError(getFailedTypeErrorMessage(typeof test, 'number', name));
    }
  };
  Check.typeOf.number.lessThan = function(name, test, limit) {
    Check.typeOf.number(name, test);
    if (test >= limit) {
      throw new DeveloperError('Expected ' + name + ' to be less than ' + limit + ', actual value was ' + test);
    }
  };
  Check.typeOf.number.lessThanOrEquals = function(name, test, limit) {
    Check.typeOf.number(name, test);
    if (test > limit) {
      throw new DeveloperError('Expected ' + name + ' to be less than or equal to ' + limit + ', actual value was ' + test);
    }
  };
  Check.typeOf.number.greaterThan = function(name, test, limit) {
    Check.typeOf.number(name, test);
    if (test <= limit) {
      throw new DeveloperError('Expected ' + name + ' to be greater than ' + limit + ', actual value was ' + test);
    }
  };
  Check.typeOf.number.greaterThanOrEquals = function(name, test, limit) {
    Check.typeOf.number(name, test);
    if (test < limit) {
      throw new DeveloperError('Expected ' + name + ' to be greater than or equal to' + limit + ', actual value was ' + test);
    }
  };
  Check.typeOf.object = function(name, test) {
    if (typeof test !== 'object') {
      throw new DeveloperError(getFailedTypeErrorMessage(typeof test, 'object', name));
    }
  };
  Check.typeOf.bool = function(name, test) {
    if (typeof test !== 'boolean') {
      throw new DeveloperError(getFailedTypeErrorMessage(typeof test, 'boolean', name));
    }
  };
  return Check;
});

})();
(function() {
var define = $__System.amdDefine;
define("27", ["1f", "54", "15", "5", "6", "7", "11", "d"], function(Cartesian3, Check, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath) {
  'use strict';
  function Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
    this[0] = defaultValue(column0Row0, 0.0);
    this[1] = defaultValue(column0Row1, 0.0);
    this[2] = defaultValue(column0Row2, 0.0);
    this[3] = defaultValue(column1Row0, 0.0);
    this[4] = defaultValue(column1Row1, 0.0);
    this[5] = defaultValue(column1Row2, 0.0);
    this[6] = defaultValue(column2Row0, 0.0);
    this[7] = defaultValue(column2Row1, 0.0);
    this[8] = defaultValue(column2Row2, 0.0);
  }
  Matrix3.packedLength = 9;
  Matrix3.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value[0];
    array[startingIndex++] = value[1];
    array[startingIndex++] = value[2];
    array[startingIndex++] = value[3];
    array[startingIndex++] = value[4];
    array[startingIndex++] = value[5];
    array[startingIndex++] = value[6];
    array[startingIndex++] = value[7];
    array[startingIndex++] = value[8];
    return array;
  };
  Matrix3.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Matrix3();
    }
    result[0] = array[startingIndex++];
    result[1] = array[startingIndex++];
    result[2] = array[startingIndex++];
    result[3] = array[startingIndex++];
    result[4] = array[startingIndex++];
    result[5] = array[startingIndex++];
    result[6] = array[startingIndex++];
    result[7] = array[startingIndex++];
    result[8] = array[startingIndex++];
    return result;
  };
  Matrix3.clone = function(matrix, result) {
    if (!defined(matrix)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Matrix3(matrix[0], matrix[3], matrix[6], matrix[1], matrix[4], matrix[7], matrix[2], matrix[5], matrix[8]);
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    return result;
  };
  Matrix3.fromArray = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Matrix3();
    }
    result[0] = array[startingIndex];
    result[1] = array[startingIndex + 1];
    result[2] = array[startingIndex + 2];
    result[3] = array[startingIndex + 3];
    result[4] = array[startingIndex + 4];
    result[5] = array[startingIndex + 5];
    result[6] = array[startingIndex + 6];
    result[7] = array[startingIndex + 7];
    result[8] = array[startingIndex + 8];
    return result;
  };
  Matrix3.fromColumnMajorArray = function(values, result) {
    Check.defined('values', values);
    return Matrix3.clone(values, result);
  };
  Matrix3.fromRowMajorArray = function(values, result) {
    Check.defined('values', values);
    if (!defined(result)) {
      return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);
    }
    result[0] = values[0];
    result[1] = values[3];
    result[2] = values[6];
    result[3] = values[1];
    result[4] = values[4];
    result[5] = values[7];
    result[6] = values[2];
    result[7] = values[5];
    result[8] = values[8];
    return result;
  };
  Matrix3.fromQuaternion = function(quaternion, result) {
    Check.typeOf.object('quaternion', quaternion);
    var x2 = quaternion.x * quaternion.x;
    var xy = quaternion.x * quaternion.y;
    var xz = quaternion.x * quaternion.z;
    var xw = quaternion.x * quaternion.w;
    var y2 = quaternion.y * quaternion.y;
    var yz = quaternion.y * quaternion.z;
    var yw = quaternion.y * quaternion.w;
    var z2 = quaternion.z * quaternion.z;
    var zw = quaternion.z * quaternion.w;
    var w2 = quaternion.w * quaternion.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2.0 * (xy - zw);
    var m02 = 2.0 * (xz + yw);
    var m10 = 2.0 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2.0 * (yz - xw);
    var m20 = 2.0 * (xz - yw);
    var m21 = 2.0 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    if (!defined(result)) {
      return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    result[0] = m00;
    result[1] = m10;
    result[2] = m20;
    result[3] = m01;
    result[4] = m11;
    result[5] = m21;
    result[6] = m02;
    result[7] = m12;
    result[8] = m22;
    return result;
  };
  Matrix3.fromHeadingPitchRoll = function(headingPitchRoll, result) {
    Check.typeOf.object('headingPitchRoll', headingPitchRoll);
    var cosTheta = Math.cos(-headingPitchRoll.pitch);
    var cosPsi = Math.cos(-headingPitchRoll.heading);
    var cosPhi = Math.cos(headingPitchRoll.roll);
    var sinTheta = Math.sin(-headingPitchRoll.pitch);
    var sinPsi = Math.sin(-headingPitchRoll.heading);
    var sinPhi = Math.sin(headingPitchRoll.roll);
    var m00 = cosTheta * cosPsi;
    var m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;
    var m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;
    var m10 = cosTheta * sinPsi;
    var m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;
    var m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;
    var m20 = -sinTheta;
    var m21 = sinPhi * cosTheta;
    var m22 = cosPhi * cosTheta;
    if (!defined(result)) {
      return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    result[0] = m00;
    result[1] = m10;
    result[2] = m20;
    result[3] = m01;
    result[4] = m11;
    result[5] = m21;
    result[6] = m02;
    result[7] = m12;
    result[8] = m22;
    return result;
  };
  Matrix3.fromScale = function(scale, result) {
    Check.typeOf.object('scale', scale);
    if (!defined(result)) {
      return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
    }
    result[0] = scale.x;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = scale.y;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = scale.z;
    return result;
  };
  Matrix3.fromUniformScale = function(scale, result) {
    Check.typeOf.number('scale', scale);
    if (!defined(result)) {
      return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);
    }
    result[0] = scale;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = scale;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = scale;
    return result;
  };
  Matrix3.fromCrossProduct = function(vector, result) {
    Check.typeOf.object('vector', vector);
    if (!defined(result)) {
      return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);
    }
    result[0] = 0.0;
    result[1] = vector.z;
    result[2] = -vector.y;
    result[3] = -vector.z;
    result[4] = 0.0;
    result[5] = vector.x;
    result[6] = vector.y;
    result[7] = -vector.x;
    result[8] = 0.0;
    return result;
  };
  Matrix3.fromRotationX = function(angle, result) {
    Check.typeOf.number('angle', angle);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
      return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);
    }
    result[0] = 1.0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = cosAngle;
    result[5] = sinAngle;
    result[6] = 0.0;
    result[7] = -sinAngle;
    result[8] = cosAngle;
    return result;
  };
  Matrix3.fromRotationY = function(angle, result) {
    Check.typeOf.number('angle', angle);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
      return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);
    }
    result[0] = cosAngle;
    result[1] = 0.0;
    result[2] = -sinAngle;
    result[3] = 0.0;
    result[4] = 1.0;
    result[5] = 0.0;
    result[6] = sinAngle;
    result[7] = 0.0;
    result[8] = cosAngle;
    return result;
  };
  Matrix3.fromRotationZ = function(angle, result) {
    Check.typeOf.number('angle', angle);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
      return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = cosAngle;
    result[1] = sinAngle;
    result[2] = 0.0;
    result[3] = -sinAngle;
    result[4] = cosAngle;
    result[5] = 0.0;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 1.0;
    return result;
  };
  Matrix3.toArray = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    if (!defined(result)) {
      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    return result;
  };
  Matrix3.getElementIndex = function(column, row) {
    Check.typeOf.number.greaterThanOrEquals('row', row, 0);
    Check.typeOf.number.lessThanOrEquals('row', row, 2);
    Check.typeOf.number.greaterThanOrEquals('column', column, 0);
    Check.typeOf.number.lessThanOrEquals('column', column, 2);
    return column * 3 + row;
  };
  Matrix3.getColumn = function(matrix, index, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 2);
    Check.typeOf.object('result', result);
    var startIndex = index * 3;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Matrix3.setColumn = function(matrix, index, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 2);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result = Matrix3.clone(matrix, result);
    var startIndex = index * 3;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    return result;
  };
  Matrix3.getRow = function(matrix, index, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 2);
    Check.typeOf.object('result', result);
    var x = matrix[index];
    var y = matrix[index + 3];
    var z = matrix[index + 6];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Matrix3.setRow = function(matrix, index, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 2);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result = Matrix3.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 3] = cartesian.y;
    result[index + 6] = cartesian.z;
    return result;
  };
  var scratchColumn = new Cartesian3();
  Matrix3.getScale = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));
    return result;
  };
  var scratchScale = new Cartesian3();
  Matrix3.getMaximumScale = function(matrix) {
    Matrix3.getScale(matrix, scratchScale);
    return Cartesian3.maximumComponent(scratchScale);
  };
  Matrix3.multiply = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
    var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
    var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
    var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
    var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
    var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
    var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
    var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
    var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
  };
  Matrix3.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    return result;
  };
  Matrix3.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    return result;
  };
  Matrix3.multiplyByVector = function(matrix, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
    var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
    var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Matrix3.multiplyByScalar = function(matrix, scalar, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    return result;
  };
  Matrix3.multiplyByScale = function(matrix, scale, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('scale', scale);
    Check.typeOf.object('result', result);
    result[0] = matrix[0] * scale.x;
    result[1] = matrix[1] * scale.x;
    result[2] = matrix[2] * scale.x;
    result[3] = matrix[3] * scale.y;
    result[4] = matrix[4] * scale.y;
    result[5] = matrix[5] * scale.y;
    result[6] = matrix[6] * scale.z;
    result[7] = matrix[7] * scale.z;
    result[8] = matrix[8] * scale.z;
    return result;
  };
  Matrix3.negate = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    return result;
  };
  Matrix3.transpose = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    var column0Row0 = matrix[0];
    var column0Row1 = matrix[3];
    var column0Row2 = matrix[6];
    var column1Row0 = matrix[1];
    var column1Row1 = matrix[4];
    var column1Row2 = matrix[7];
    var column2Row0 = matrix[2];
    var column2Row1 = matrix[5];
    var column2Row2 = matrix[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
  };
  function computeFrobeniusNorm(matrix) {
    var norm = 0.0;
    for (var i = 0; i < 9; ++i) {
      var temp = matrix[i];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  function offDiagonalFrobeniusNorm(matrix) {
    var norm = 0.0;
    for (var i = 0; i < 3; ++i) {
      var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
      norm += 2.0 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition(matrix, result) {
    var tolerance = CesiumMath.EPSILON15;
    var maxDiagonal = 0.0;
    var rotAxis = 1;
    for (var i = 0; i < 3; ++i) {
      var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
      if (temp > maxDiagonal) {
        rotAxis = i;
        maxDiagonal = temp;
      }
    }
    var c = 1.0;
    var s = 0.0;
    var p = rowVal[rotAxis];
    var q = colVal[rotAxis];
    if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
      var qq = matrix[Matrix3.getElementIndex(q, q)];
      var pp = matrix[Matrix3.getElementIndex(p, p)];
      var qp = matrix[Matrix3.getElementIndex(q, p)];
      var tau = (qq - pp) / 2.0 / qp;
      var t;
      if (tau < 0.0) {
        t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
      } else {
        t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
      }
      c = 1.0 / Math.sqrt(1.0 + t * t);
      s = t * c;
    }
    result = Matrix3.clone(Matrix3.IDENTITY, result);
    result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
    result[Matrix3.getElementIndex(q, p)] = s;
    result[Matrix3.getElementIndex(p, q)] = -s;
    return result;
  }
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();
  Matrix3.computeEigenDecomposition = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    var tolerance = CesiumMath.EPSILON20;
    var maxSweeps = 10;
    var count = 0;
    var sweep = 0;
    if (!defined(result)) {
      result = {};
    }
    var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
    var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);
    var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);
    while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
      shurDecomposition(diagMatrix, jMatrix);
      Matrix3.transpose(jMatrix, jMatrixTranspose);
      Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
      Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
      Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);
      if (++count > 2) {
        ++sweep;
        count = 0;
      }
    }
    return result;
  };
  Matrix3.abs = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    return result;
  };
  Matrix3.determinant = function(matrix) {
    Check.typeOf.object('matrix', matrix);
    var m11 = matrix[0];
    var m21 = matrix[3];
    var m31 = matrix[6];
    var m12 = matrix[1];
    var m22 = matrix[4];
    var m32 = matrix[7];
    var m13 = matrix[2];
    var m23 = matrix[5];
    var m33 = matrix[8];
    return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
  };
  Matrix3.inverse = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    var m11 = matrix[0];
    var m21 = matrix[1];
    var m31 = matrix[2];
    var m12 = matrix[3];
    var m22 = matrix[4];
    var m32 = matrix[5];
    var m13 = matrix[6];
    var m23 = matrix[7];
    var m33 = matrix[8];
    var determinant = Matrix3.determinant(matrix);
    if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
      throw new DeveloperError('matrix is not invertible');
    }
    result[0] = m22 * m33 - m23 * m32;
    result[1] = m23 * m31 - m21 * m33;
    result[2] = m21 * m32 - m22 * m31;
    result[3] = m13 * m32 - m12 * m33;
    result[4] = m11 * m33 - m13 * m31;
    result[5] = m12 * m31 - m11 * m32;
    result[6] = m12 * m23 - m13 * m22;
    result[7] = m13 * m21 - m11 * m23;
    result[8] = m11 * m22 - m12 * m21;
    var scale = 1.0 / determinant;
    return Matrix3.multiplyByScalar(result, scale, result);
  };
  Matrix3.equals = function(left, right) {
    return (left === right) || (defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8]);
  };
  Matrix3.equalsEpsilon = function(left, right, epsilon) {
    Check.typeOf.number('epsilon', epsilon);
    return (left === right) || (defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon);
  };
  Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));
  Matrix3.ZERO = freezeObject(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
  Matrix3.COLUMN0ROW0 = 0;
  Matrix3.COLUMN0ROW1 = 1;
  Matrix3.COLUMN0ROW2 = 2;
  Matrix3.COLUMN1ROW0 = 3;
  Matrix3.COLUMN1ROW1 = 4;
  Matrix3.COLUMN1ROW2 = 5;
  Matrix3.COLUMN2ROW0 = 6;
  Matrix3.COLUMN2ROW1 = 7;
  Matrix3.COLUMN2ROW2 = 8;
  defineProperties(Matrix3.prototype, {length: {get: function() {
        return Matrix3.packedLength;
      }}});
  Matrix3.prototype.clone = function(result) {
    return Matrix3.clone(this, result);
  };
  Matrix3.prototype.equals = function(right) {
    return Matrix3.equals(this, right);
  };
  Matrix3.equalsArray = function(matrix, array, offset) {
    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];
  };
  Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
    return Matrix3.equalsEpsilon(this, right, epsilon);
  };
  Matrix3.prototype.toString = function() {
    return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' + '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' + '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
  };
  return Matrix3;
});

})();
(function() {
var define = $__System.amdDefine;
define("2c", ["5"], function(defined) {
  'use strict';
  function RuntimeError(message) {
    this.name = 'RuntimeError';
    this.message = message;
    var stack;
    try {
      throw new Error();
    } catch (e) {
      stack = e.stack;
    }
    this.stack = stack;
  }
  if (defined(Object.create)) {
    RuntimeError.prototype = Object.create(Error.prototype);
    RuntimeError.prototype.constructor = RuntimeError;
  }
  RuntimeError.prototype.toString = function() {
    var str = this.name + ': ' + this.message;
    if (defined(this.stack)) {
      str += '\n' + this.stack.toString();
    }
    return str;
  };
  return RuntimeError;
});

})();
(function() {
var define = $__System.amdDefine;
define("28", ["1f", "32", "54", "15", "5", "6", "11", "d", "27", "2c"], function(Cartesian3, Cartesian4, Check, defaultValue, defined, defineProperties, freezeObject, CesiumMath, Matrix3, RuntimeError) {
  'use strict';
  function Matrix4(column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
    this[0] = defaultValue(column0Row0, 0.0);
    this[1] = defaultValue(column0Row1, 0.0);
    this[2] = defaultValue(column0Row2, 0.0);
    this[3] = defaultValue(column0Row3, 0.0);
    this[4] = defaultValue(column1Row0, 0.0);
    this[5] = defaultValue(column1Row1, 0.0);
    this[6] = defaultValue(column1Row2, 0.0);
    this[7] = defaultValue(column1Row3, 0.0);
    this[8] = defaultValue(column2Row0, 0.0);
    this[9] = defaultValue(column2Row1, 0.0);
    this[10] = defaultValue(column2Row2, 0.0);
    this[11] = defaultValue(column2Row3, 0.0);
    this[12] = defaultValue(column3Row0, 0.0);
    this[13] = defaultValue(column3Row1, 0.0);
    this[14] = defaultValue(column3Row2, 0.0);
    this[15] = defaultValue(column3Row3, 0.0);
  }
  Matrix4.packedLength = 16;
  Matrix4.pack = function(value, array, startingIndex) {
    Check.typeOf.object('value', value);
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value[0];
    array[startingIndex++] = value[1];
    array[startingIndex++] = value[2];
    array[startingIndex++] = value[3];
    array[startingIndex++] = value[4];
    array[startingIndex++] = value[5];
    array[startingIndex++] = value[6];
    array[startingIndex++] = value[7];
    array[startingIndex++] = value[8];
    array[startingIndex++] = value[9];
    array[startingIndex++] = value[10];
    array[startingIndex++] = value[11];
    array[startingIndex++] = value[12];
    array[startingIndex++] = value[13];
    array[startingIndex++] = value[14];
    array[startingIndex] = value[15];
    return array;
  };
  Matrix4.unpack = function(array, startingIndex, result) {
    Check.defined('array', array);
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
      result = new Matrix4();
    }
    result[0] = array[startingIndex++];
    result[1] = array[startingIndex++];
    result[2] = array[startingIndex++];
    result[3] = array[startingIndex++];
    result[4] = array[startingIndex++];
    result[5] = array[startingIndex++];
    result[6] = array[startingIndex++];
    result[7] = array[startingIndex++];
    result[8] = array[startingIndex++];
    result[9] = array[startingIndex++];
    result[10] = array[startingIndex++];
    result[11] = array[startingIndex++];
    result[12] = array[startingIndex++];
    result[13] = array[startingIndex++];
    result[14] = array[startingIndex++];
    result[15] = array[startingIndex];
    return result;
  };
  Matrix4.clone = function(matrix, result) {
    if (!defined(matrix)) {
      return undefined;
    }
    if (!defined(result)) {
      return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12], matrix[1], matrix[5], matrix[9], matrix[13], matrix[2], matrix[6], matrix[10], matrix[14], matrix[3], matrix[7], matrix[11], matrix[15]);
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  Matrix4.fromArray = Matrix4.unpack;
  Matrix4.fromColumnMajorArray = function(values, result) {
    Check.defined('values', values);
    return Matrix4.clone(values, result);
  };
  Matrix4.fromRowMajorArray = function(values, result) {
    Check.defined('values', values);
    if (!defined(result)) {
      return new Matrix4(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15]);
    }
    result[0] = values[0];
    result[1] = values[4];
    result[2] = values[8];
    result[3] = values[12];
    result[4] = values[1];
    result[5] = values[5];
    result[6] = values[9];
    result[7] = values[13];
    result[8] = values[2];
    result[9] = values[6];
    result[10] = values[10];
    result[11] = values[14];
    result[12] = values[3];
    result[13] = values[7];
    result[14] = values[11];
    result[15] = values[15];
    return result;
  };
  Matrix4.fromRotationTranslation = function(rotation, translation, result) {
    Check.typeOf.object('rotation', rotation);
    translation = defaultValue(translation, Cartesian3.ZERO);
    if (!defined(result)) {
      return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x, rotation[1], rotation[4], rotation[7], translation.y, rotation[2], rotation[5], rotation[8], translation.z, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = rotation[0];
    result[1] = rotation[1];
    result[2] = rotation[2];
    result[3] = 0.0;
    result[4] = rotation[3];
    result[5] = rotation[4];
    result[6] = rotation[5];
    result[7] = 0.0;
    result[8] = rotation[6];
    result[9] = rotation[7];
    result[10] = rotation[8];
    result[11] = 0.0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1.0;
    return result;
  };
  Matrix4.fromTranslationQuaternionRotationScale = function(translation, rotation, scale, result) {
    Check.typeOf.object('translation', translation);
    Check.typeOf.object('rotation', rotation);
    Check.typeOf.object('scale', scale);
    if (!defined(result)) {
      result = new Matrix4();
    }
    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;
    var x2 = rotation.x * rotation.x;
    var xy = rotation.x * rotation.y;
    var xz = rotation.x * rotation.z;
    var xw = rotation.x * rotation.w;
    var y2 = rotation.y * rotation.y;
    var yz = rotation.y * rotation.z;
    var yw = rotation.y * rotation.w;
    var z2 = rotation.z * rotation.z;
    var zw = rotation.z * rotation.w;
    var w2 = rotation.w * rotation.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2.0 * (xy - zw);
    var m02 = 2.0 * (xz + yw);
    var m10 = 2.0 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2.0 * (yz - xw);
    var m20 = 2.0 * (xz - yw);
    var m21 = 2.0 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    result[0] = m00 * scaleX;
    result[1] = m10 * scaleX;
    result[2] = m20 * scaleX;
    result[3] = 0.0;
    result[4] = m01 * scaleY;
    result[5] = m11 * scaleY;
    result[6] = m21 * scaleY;
    result[7] = 0.0;
    result[8] = m02 * scaleZ;
    result[9] = m12 * scaleZ;
    result[10] = m22 * scaleZ;
    result[11] = 0.0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1.0;
    return result;
  };
  Matrix4.fromTranslationRotationScale = function(translationRotationScale, result) {
    Check.typeOf.object('translationRotationScale', translationRotationScale);
    return Matrix4.fromTranslationQuaternionRotationScale(translationRotationScale.translation, translationRotationScale.rotation, translationRotationScale.scale, result);
  };
  Matrix4.fromTranslation = function(translation, result) {
    Check.typeOf.object('translation', translation);
    return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
  };
  Matrix4.fromScale = function(scale, result) {
    Check.typeOf.object('scale', scale);
    if (!defined(result)) {
      return new Matrix4(scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = scale.x;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = scale.y;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = scale.z;
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
  };
  Matrix4.fromUniformScale = function(scale, result) {
    Check.typeOf.number('scale', scale);
    if (!defined(result)) {
      return new Matrix4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = scale;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = scale;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = scale;
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
  };
  var fromCameraF = new Cartesian3();
  var fromCameraR = new Cartesian3();
  var fromCameraU = new Cartesian3();
  Matrix4.fromCamera = function(camera, result) {
    Check.typeOf.object('camera', camera);
    var position = camera.position;
    var direction = camera.direction;
    var up = camera.up;
    Check.typeOf.object('camera.position', position);
    Check.typeOf.object('camera.direction', direction);
    Check.typeOf.object('camera.up', up);
    Cartesian3.normalize(direction, fromCameraF);
    Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraR), fromCameraR);
    Cartesian3.normalize(Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU), fromCameraU);
    var sX = fromCameraR.x;
    var sY = fromCameraR.y;
    var sZ = fromCameraR.z;
    var fX = fromCameraF.x;
    var fY = fromCameraF.y;
    var fZ = fromCameraF.z;
    var uX = fromCameraU.x;
    var uY = fromCameraU.y;
    var uZ = fromCameraU.z;
    var positionX = position.x;
    var positionY = position.y;
    var positionZ = position.z;
    var t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
    var t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
    var t2 = fX * positionX + fY * positionY + fZ * positionZ;
    if (!defined(result)) {
      return new Matrix4(sX, sY, sZ, t0, uX, uY, uZ, t1, -fX, -fY, -fZ, t2, 0.0, 0.0, 0.0, 1.0);
    }
    result[0] = sX;
    result[1] = uX;
    result[2] = -fX;
    result[3] = 0.0;
    result[4] = sY;
    result[5] = uY;
    result[6] = -fY;
    result[7] = 0.0;
    result[8] = sZ;
    result[9] = uZ;
    result[10] = -fZ;
    result[11] = 0.0;
    result[12] = t0;
    result[13] = t1;
    result[14] = t2;
    result[15] = 1.0;
    return result;
  };
  Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
    Check.typeOf.number.greaterThan('fovY', fovY, 0.0);
    Check.typeOf.number.lessThan('fovY', fovY, Math.PI);
    Check.typeOf.number.greaterThan('near', near, 0.0);
    Check.typeOf.number.greaterThan('far', far, 0.0);
    Check.typeOf.object('result', result);
    var bottom = Math.tan(fovY * 0.5);
    var column1Row1 = 1.0 / bottom;
    var column0Row0 = column1Row1 / aspectRatio;
    var column2Row2 = (far + near) / (near - far);
    var column3Row2 = (2.0 * far * near) / (near - far);
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = column2Row2;
    result[11] = -1.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };
  Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
    Check.typeOf.number('left', left);
    Check.typeOf.number('right', right);
    Check.typeOf.number('bottom', bottom);
    Check.typeOf.number('top', top);
    Check.typeOf.number('near', near);
    Check.typeOf.number('far', far);
    Check.typeOf.object('result', result);
    var a = 1.0 / (right - left);
    var b = 1.0 / (top - bottom);
    var c = 1.0 / (far - near);
    var tx = -(right + left) * a;
    var ty = -(top + bottom) * b;
    var tz = -(far + near) * c;
    a *= 2.0;
    b *= 2.0;
    c *= -2.0;
    result[0] = a;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = b;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = c;
    result[11] = 0.0;
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = 1.0;
    return result;
  };
  Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
    Check.typeOf.number('left', left);
    Check.typeOf.number('right', right);
    Check.typeOf.number('bottom', bottom);
    Check.typeOf.number('top', top);
    Check.typeOf.number('near', near);
    Check.typeOf.number('far', far);
    Check.typeOf.object('result', result);
    var column0Row0 = 2.0 * near / (right - left);
    var column1Row1 = 2.0 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -(far + near) / (far - near);
    var column2Row3 = -1.0;
    var column3Row2 = -2.0 * far * near / (far - near);
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };
  Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
    Check.typeOf.number('left', left);
    Check.typeOf.number('right', right);
    Check.typeOf.number('bottom', bottom);
    Check.typeOf.number('top', top);
    Check.typeOf.number('near', near);
    Check.typeOf.object('result', result);
    var column0Row0 = 2.0 * near / (right - left);
    var column1Row1 = 2.0 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -1.0;
    var column2Row3 = -1.0;
    var column3Row2 = -2.0 * near;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  };
  Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
    Check.typeOf.object('result', result);
    viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
    var x = defaultValue(viewport.x, 0.0);
    var y = defaultValue(viewport.y, 0.0);
    var width = defaultValue(viewport.width, 0.0);
    var height = defaultValue(viewport.height, 0.0);
    nearDepthRange = defaultValue(nearDepthRange, 0.0);
    farDepthRange = defaultValue(farDepthRange, 1.0);
    var halfWidth = width * 0.5;
    var halfHeight = height * 0.5;
    var halfDepth = (farDepthRange - nearDepthRange) * 0.5;
    var column0Row0 = halfWidth;
    var column1Row1 = halfHeight;
    var column2Row2 = halfDepth;
    var column3Row0 = x + halfWidth;
    var column3Row1 = y + halfHeight;
    var column3Row2 = nearDepthRange + halfDepth;
    var column3Row3 = 1.0;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = 0.0;
    result[9] = 0.0;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
  };
  Matrix4.computeView = function(position, direction, up, right, result) {
    Check.typeOf.object('position', position);
    Check.typeOf.object('direction', direction);
    Check.typeOf.object('up', up);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result[0] = right.x;
    result[1] = up.x;
    result[2] = -direction.x;
    result[3] = 0.0;
    result[4] = right.y;
    result[5] = up.y;
    result[6] = -direction.y;
    result[7] = 0.0;
    result[8] = right.z;
    result[9] = up.z;
    result[10] = -direction.z;
    result[11] = 0.0;
    result[12] = -Cartesian3.dot(right, position);
    result[13] = -Cartesian3.dot(up, position);
    result[14] = Cartesian3.dot(direction, position);
    result[15] = 1.0;
    return result;
  };
  Matrix4.toArray = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    if (!defined(result)) {
      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8], matrix[9], matrix[10], matrix[11], matrix[12], matrix[13], matrix[14], matrix[15]];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  Matrix4.getElementIndex = function(column, row) {
    Check.typeOf.number.greaterThanOrEquals('row', row, 0);
    Check.typeOf.number.lessThanOrEquals('row', row, 3);
    Check.typeOf.number.greaterThanOrEquals('column', column, 0);
    Check.typeOf.number.lessThanOrEquals('column', column, 3);
    return column * 4 + row;
  };
  Matrix4.getColumn = function(matrix, index, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 3);
    Check.typeOf.object('result', result);
    var startIndex = index * 4;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    var w = matrix[startIndex + 3];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Matrix4.setColumn = function(matrix, index, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 3);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result = Matrix4.clone(matrix, result);
    var startIndex = index * 4;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    result[startIndex + 3] = cartesian.w;
    return result;
  };
  Matrix4.setTranslation = function(matrix, translation, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('translation', translation);
    Check.typeOf.object('result', result);
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = matrix[15];
    return result;
  };
  Matrix4.getRow = function(matrix, index, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 3);
    Check.typeOf.object('result', result);
    var x = matrix[index];
    var y = matrix[index + 4];
    var z = matrix[index + 8];
    var w = matrix[index + 12];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Matrix4.setRow = function(matrix, index, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number.greaterThanOrEquals('index', index, 0);
    Check.typeOf.number.lessThanOrEquals('index', index, 3);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    result = Matrix4.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 4] = cartesian.y;
    result[index + 8] = cartesian.z;
    result[index + 12] = cartesian.w;
    return result;
  };
  var scratchColumn = new Cartesian3();
  Matrix4.getScale = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
    return result;
  };
  var scratchScale = new Cartesian3();
  Matrix4.getMaximumScale = function(matrix) {
    Matrix4.getScale(matrix, scratchScale);
    return Cartesian3.maximumComponent(scratchScale);
  };
  Matrix4.multiply = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left3 = left[3];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left7 = left[7];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left11 = left[11];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var left15 = left[15];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right3 = right[3];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right7 = right[7];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right11 = right[11];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var right15 = right[15];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
    var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
    var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
    var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
    var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column0Row3;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = column1Row3;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
  };
  Matrix4.add = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    result[9] = left[9] + right[9];
    result[10] = left[10] + right[10];
    result[11] = left[11] + right[11];
    result[12] = left[12] + right[12];
    result[13] = left[13] + right[13];
    result[14] = left[14] + right[14];
    result[15] = left[15] + right[15];
    return result;
  };
  Matrix4.subtract = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    result[9] = left[9] - right[9];
    result[10] = left[10] - right[10];
    result[11] = left[11] - right[11];
    result[12] = left[12] - right[12];
    result[13] = left[13] - right[13];
    result[14] = left[14] - right[14];
    result[15] = left[15] - right[15];
    return result;
  };
  Matrix4.multiplyTransformation = function(left, right, result) {
    Check.typeOf.object('left', left);
    Check.typeOf.object('right', right);
    Check.typeOf.object('result', result);
    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0.0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = 1.0;
    return result;
  };
  Matrix4.multiplyByMatrix3 = function(matrix, rotation, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('rotation', rotation);
    Check.typeOf.object('result', result);
    var left0 = matrix[0];
    var left1 = matrix[1];
    var left2 = matrix[2];
    var left4 = matrix[4];
    var left5 = matrix[5];
    var left6 = matrix[6];
    var left8 = matrix[8];
    var left9 = matrix[9];
    var left10 = matrix[10];
    var right0 = rotation[0];
    var right1 = rotation[1];
    var right2 = rotation[2];
    var right4 = rotation[3];
    var right5 = rotation[4];
    var right6 = rotation[5];
    var right8 = rotation[6];
    var right9 = rotation[7];
    var right10 = rotation[8];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0.0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0.0;
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
  };
  Matrix4.multiplyByTranslation = function(matrix, translation, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('translation', translation);
    Check.typeOf.object('result', result);
    var x = translation.x;
    var y = translation.y;
    var z = translation.z;
    var tx = (x * matrix[0]) + (y * matrix[4]) + (z * matrix[8]) + matrix[12];
    var ty = (x * matrix[1]) + (y * matrix[5]) + (z * matrix[9]) + matrix[13];
    var tz = (x * matrix[2]) + (y * matrix[6]) + (z * matrix[10]) + matrix[14];
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = matrix[15];
    return result;
  };
  var uniformScaleScratch = new Cartesian3();
  Matrix4.multiplyByUniformScale = function(matrix, scale, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number('scale', scale);
    Check.typeOf.object('result', result);
    uniformScaleScratch.x = scale;
    uniformScaleScratch.y = scale;
    uniformScaleScratch.z = scale;
    return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);
  };
  Matrix4.multiplyByScale = function(matrix, scale, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('scale', scale);
    Check.typeOf.object('result', result);
    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;
    if ((scaleX === 1.0) && (scaleY === 1.0) && (scaleZ === 1.0)) {
      return Matrix4.clone(matrix, result);
    }
    result[0] = scaleX * matrix[0];
    result[1] = scaleX * matrix[1];
    result[2] = scaleX * matrix[2];
    result[3] = 0.0;
    result[4] = scaleY * matrix[4];
    result[5] = scaleY * matrix[5];
    result[6] = scaleY * matrix[6];
    result[7] = 0.0;
    result[8] = scaleZ * matrix[8];
    result[9] = scaleZ * matrix[9];
    result[10] = scaleZ * matrix[10];
    result[11] = 0.0;
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = 1.0;
    return result;
  };
  Matrix4.multiplyByVector = function(matrix, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var vW = cartesian.w;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
    var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  };
  Matrix4.multiplyByPointAsVector = function(matrix, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Matrix4.multiplyByPoint = function(matrix, cartesian, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('cartesian', cartesian);
    Check.typeOf.object('result', result);
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
  };
  Matrix4.multiplyByScalar = function(matrix, scalar, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.number('scalar', scalar);
    Check.typeOf.object('result', result);
    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    result[9] = matrix[9] * scalar;
    result[10] = matrix[10] * scalar;
    result[11] = matrix[11] * scalar;
    result[12] = matrix[12] * scalar;
    result[13] = matrix[13] * scalar;
    result[14] = matrix[14] * scalar;
    result[15] = matrix[15] * scalar;
    return result;
  };
  Matrix4.negate = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    result[9] = -matrix[9];
    result[10] = -matrix[10];
    result[11] = -matrix[11];
    result[12] = -matrix[12];
    result[13] = -matrix[13];
    result[14] = -matrix[14];
    result[15] = -matrix[15];
    return result;
  };
  Matrix4.transpose = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix3 = matrix[3];
    var matrix6 = matrix[6];
    var matrix7 = matrix[7];
    var matrix11 = matrix[11];
    result[0] = matrix[0];
    result[1] = matrix[4];
    result[2] = matrix[8];
    result[3] = matrix[12];
    result[4] = matrix1;
    result[5] = matrix[5];
    result[6] = matrix[9];
    result[7] = matrix[13];
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix[10];
    result[11] = matrix[14];
    result[12] = matrix3;
    result[13] = matrix7;
    result[14] = matrix11;
    result[15] = matrix[15];
    return result;
  };
  Matrix4.abs = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    result[9] = Math.abs(matrix[9]);
    result[10] = Math.abs(matrix[10]);
    result[11] = Math.abs(matrix[11]);
    result[12] = Math.abs(matrix[12]);
    result[13] = Math.abs(matrix[13]);
    result[14] = Math.abs(matrix[14]);
    result[15] = Math.abs(matrix[15]);
    return result;
  };
  Matrix4.equals = function(left, right) {
    return (left === right) || (defined(left) && defined(right) && left[12] === right[12] && left[13] === right[13] && left[14] === right[14] && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] && left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15]);
  };
  Matrix4.equalsEpsilon = function(left, right, epsilon) {
    Check.typeOf.number('epsilon', epsilon);
    return (left === right) || (defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon);
  };
  Matrix4.getTranslation = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result.x = matrix[12];
    result.y = matrix[13];
    result.z = matrix[14];
    return result;
  };
  Matrix4.getRotation = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[4];
    result[4] = matrix[5];
    result[5] = matrix[6];
    result[6] = matrix[8];
    result[7] = matrix[9];
    result[8] = matrix[10];
    return result;
  };
  var scratchInverseRotation = new Matrix3();
  var scratchMatrix3Zero = new Matrix3();
  var scratchBottomRow = new Cartesian4();
  var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);
  Matrix4.inverse = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) && Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {
      result[0] = 0.0;
      result[1] = 0.0;
      result[2] = 0.0;
      result[3] = 0.0;
      result[4] = 0.0;
      result[5] = 0.0;
      result[6] = 0.0;
      result[7] = 0.0;
      result[8] = 0.0;
      result[9] = 0.0;
      result[10] = 0.0;
      result[11] = 0.0;
      result[12] = -matrix[12];
      result[13] = -matrix[13];
      result[14] = -matrix[14];
      result[15] = 1.0;
      return result;
    }
    var src0 = matrix[0];
    var src1 = matrix[4];
    var src2 = matrix[8];
    var src3 = matrix[12];
    var src4 = matrix[1];
    var src5 = matrix[5];
    var src6 = matrix[9];
    var src7 = matrix[13];
    var src8 = matrix[2];
    var src9 = matrix[6];
    var src10 = matrix[10];
    var src11 = matrix[14];
    var src12 = matrix[3];
    var src13 = matrix[7];
    var src14 = matrix[11];
    var src15 = matrix[15];
    var tmp0 = src10 * src15;
    var tmp1 = src11 * src14;
    var tmp2 = src9 * src15;
    var tmp3 = src11 * src13;
    var tmp4 = src9 * src14;
    var tmp5 = src10 * src13;
    var tmp6 = src8 * src15;
    var tmp7 = src11 * src12;
    var tmp8 = src8 * src14;
    var tmp9 = src10 * src12;
    var tmp10 = src8 * src13;
    var tmp11 = src9 * src12;
    var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
    var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
    var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
    var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
    var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
    var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
    var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
    var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);
    tmp0 = src2 * src7;
    tmp1 = src3 * src6;
    tmp2 = src1 * src7;
    tmp3 = src3 * src5;
    tmp4 = src1 * src6;
    tmp5 = src2 * src5;
    tmp6 = src0 * src7;
    tmp7 = src3 * src4;
    tmp8 = src0 * src6;
    tmp9 = src2 * src4;
    tmp10 = src0 * src5;
    tmp11 = src1 * src4;
    var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
    var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
    var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
    var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
    var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
    var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
    var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
    var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);
    var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
    if (Math.abs(det) < CesiumMath.EPSILON20) {
      throw new RuntimeError('matrix is not invertible because its determinate is zero.');
    }
    det = 1.0 / det;
    result[0] = dst0 * det;
    result[1] = dst1 * det;
    result[2] = dst2 * det;
    result[3] = dst3 * det;
    result[4] = dst4 * det;
    result[5] = dst5 * det;
    result[6] = dst6 * det;
    result[7] = dst7 * det;
    result[8] = dst8 * det;
    result[9] = dst9 * det;
    result[10] = dst10 * det;
    result[11] = dst11 * det;
    result[12] = dst12 * det;
    result[13] = dst13 * det;
    result[14] = dst14 * det;
    result[15] = dst15 * det;
    return result;
  };
  Matrix4.inverseTransformation = function(matrix, result) {
    Check.typeOf.object('matrix', matrix);
    Check.typeOf.object('result', result);
    var matrix0 = matrix[0];
    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix4 = matrix[4];
    var matrix5 = matrix[5];
    var matrix6 = matrix[6];
    var matrix8 = matrix[8];
    var matrix9 = matrix[9];
    var matrix10 = matrix[10];
    var vX = matrix[12];
    var vY = matrix[13];
    var vZ = matrix[14];
    var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
    var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
    var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;
    result[0] = matrix0;
    result[1] = matrix4;
    result[2] = matrix8;
    result[3] = 0.0;
    result[4] = matrix1;
    result[5] = matrix5;
    result[6] = matrix9;
    result[7] = 0.0;
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix10;
    result[11] = 0.0;
    result[12] = x;
    result[13] = y;
    result[14] = z;
    result[15] = 1.0;
    return result;
  };
  Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0));
  Matrix4.ZERO = freezeObject(new Matrix4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
  Matrix4.COLUMN0ROW0 = 0;
  Matrix4.COLUMN0ROW1 = 1;
  Matrix4.COLUMN0ROW2 = 2;
  Matrix4.COLUMN0ROW3 = 3;
  Matrix4.COLUMN1ROW0 = 4;
  Matrix4.COLUMN1ROW1 = 5;
  Matrix4.COLUMN1ROW2 = 6;
  Matrix4.COLUMN1ROW3 = 7;
  Matrix4.COLUMN2ROW0 = 8;
  Matrix4.COLUMN2ROW1 = 9;
  Matrix4.COLUMN2ROW2 = 10;
  Matrix4.COLUMN2ROW3 = 11;
  Matrix4.COLUMN3ROW0 = 12;
  Matrix4.COLUMN3ROW1 = 13;
  Matrix4.COLUMN3ROW2 = 14;
  Matrix4.COLUMN3ROW3 = 15;
  defineProperties(Matrix4.prototype, {length: {get: function() {
        return Matrix4.packedLength;
      }}});
  Matrix4.prototype.clone = function(result) {
    return Matrix4.clone(this, result);
  };
  Matrix4.prototype.equals = function(right) {
    return Matrix4.equals(this, right);
  };
  Matrix4.equalsArray = function(matrix, array, offset) {
    return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8] && matrix[9] === array[offset + 9] && matrix[10] === array[offset + 10] && matrix[11] === array[offset + 11] && matrix[12] === array[offset + 12] && matrix[13] === array[offset + 13] && matrix[14] === array[offset + 14] && matrix[15] === array[offset + 15];
  };
  Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
    return Matrix4.equalsEpsilon(this, right, epsilon);
  };
  Matrix4.prototype.toString = function() {
    return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] + ')\n' + '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] + ')\n' + '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] + ')\n' + '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] + ')';
  };
  return Matrix4;
});

})();
(function() {
var define = $__System.amdDefine;
define("79", ["11"], function(freezeObject) {
  'use strict';
  var TerrainQuantization = {
    NONE: 0,
    BITS12: 1
  };
  return freezeObject(TerrainQuantization);
});

})();
(function() {
var define = $__System.amdDefine;
define("70", ["75", "a", "1f", "78", "15", "5", "d", "28", "79"], function(AttributeCompression, Cartesian2, Cartesian3, ComponentDatatype, defaultValue, defined, CesiumMath, Matrix4, TerrainQuantization) {
  'use strict';
  var cartesian3Scratch = new Cartesian3();
  var cartesian3DimScratch = new Cartesian3();
  var cartesian2Scratch = new Cartesian2();
  var matrix4Scratch = new Matrix4();
  var matrix4Scratch2 = new Matrix4();
  var SHIFT_LEFT_12 = Math.pow(2.0, 12.0);
  function TerrainEncoding(axisAlignedBoundingBox, minimumHeight, maximumHeight, fromENU, hasVertexNormals, hasWebMercatorT) {
    var quantization;
    var center;
    var toENU;
    var matrix;
    if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {
      var minimum = axisAlignedBoundingBox.minimum;
      var maximum = axisAlignedBoundingBox.maximum;
      var dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);
      var hDim = maximumHeight - minimumHeight;
      var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);
      if (maxDim < SHIFT_LEFT_12 - 1.0) {
        quantization = TerrainQuantization.BITS12;
      } else {
        quantization = TerrainQuantization.NONE;
      }
      center = axisAlignedBoundingBox.center;
      toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());
      var translation = Cartesian3.negate(minimum, cartesian3Scratch);
      Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);
      var scale = cartesian3Scratch;
      scale.x = 1.0 / dimensions.x;
      scale.y = 1.0 / dimensions.y;
      scale.z = 1.0 / dimensions.z;
      Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);
      matrix = Matrix4.clone(fromENU);
      Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);
      fromENU = Matrix4.clone(fromENU, new Matrix4());
      var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);
      var scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);
      var st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);
      Matrix4.multiply(fromENU, st, fromENU);
      Matrix4.multiply(matrix, st, matrix);
    }
    this.quantization = quantization;
    this.minimumHeight = minimumHeight;
    this.maximumHeight = maximumHeight;
    this.center = center;
    this.toScaledENU = toENU;
    this.fromScaledENU = fromENU;
    this.matrix = matrix;
    this.hasVertexNormals = hasVertexNormals;
    this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);
  }
  TerrainEncoding.prototype.encode = function(vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT) {
    var u = uv.x;
    var v = uv.y;
    if (this.quantization === TerrainQuantization.BITS12) {
      position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);
      position.x = CesiumMath.clamp(position.x, 0.0, 1.0);
      position.y = CesiumMath.clamp(position.y, 0.0, 1.0);
      position.z = CesiumMath.clamp(position.z, 0.0, 1.0);
      var hDim = this.maximumHeight - this.minimumHeight;
      var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);
      Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);
      var compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);
      Cartesian2.fromElements(position.z, h, cartesian2Scratch);
      var compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);
      Cartesian2.fromElements(u, v, cartesian2Scratch);
      var compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);
      vertexBuffer[bufferIndex++] = compressed0;
      vertexBuffer[bufferIndex++] = compressed1;
      vertexBuffer[bufferIndex++] = compressed2;
      if (this.hasWebMercatorT) {
        Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);
        var compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);
        vertexBuffer[bufferIndex++] = compressed3;
      }
    } else {
      Cartesian3.subtract(position, this.center, cartesian3Scratch);
      vertexBuffer[bufferIndex++] = cartesian3Scratch.x;
      vertexBuffer[bufferIndex++] = cartesian3Scratch.y;
      vertexBuffer[bufferIndex++] = cartesian3Scratch.z;
      vertexBuffer[bufferIndex++] = height;
      vertexBuffer[bufferIndex++] = u;
      vertexBuffer[bufferIndex++] = v;
      if (this.hasWebMercatorT) {
        vertexBuffer[bufferIndex++] = webMercatorT;
      }
    }
    if (this.hasVertexNormals) {
      vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);
    }
    return bufferIndex;
  };
  TerrainEncoding.prototype.decodePosition = function(buffer, index, result) {
    if (!defined(result)) {
      result = new Cartesian3();
    }
    index *= this.getStride();
    if (this.quantization === TerrainQuantization.BITS12) {
      var xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);
      result.x = xy.x;
      result.y = xy.y;
      var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);
      result.z = zh.x;
      return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);
    }
    result.x = buffer[index];
    result.y = buffer[index + 1];
    result.z = buffer[index + 2];
    return Cartesian3.add(result, this.center, result);
  };
  TerrainEncoding.prototype.decodeTextureCoordinates = function(buffer, index, result) {
    if (!defined(result)) {
      result = new Cartesian2();
    }
    index *= this.getStride();
    if (this.quantization === TerrainQuantization.BITS12) {
      return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);
    }
    return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);
  };
  TerrainEncoding.prototype.decodeHeight = function(buffer, index) {
    index *= this.getStride();
    if (this.quantization === TerrainQuantization.BITS12) {
      var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);
      return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;
    }
    return buffer[index + 3];
  };
  TerrainEncoding.prototype.getOctEncodedNormal = function(buffer, index, result) {
    var stride = this.getStride();
    index = (index + 1) * stride - 1;
    var temp = buffer[index] / 256.0;
    var x = Math.floor(temp);
    var y = (temp - x) * 256.0;
    return Cartesian2.fromElements(x, y, result);
  };
  TerrainEncoding.prototype.getStride = function() {
    var vertexStride;
    switch (this.quantization) {
      case TerrainQuantization.BITS12:
        vertexStride = 3;
        break;
      default:
        vertexStride = 6;
    }
    if (this.hasWebMercatorT) {
      ++vertexStride;
    }
    if (this.hasVertexNormals) {
      ++vertexStride;
    }
    return vertexStride;
  };
  var attributesNone = {
    position3DAndHeight: 0,
    textureCoordAndEncodedNormals: 1
  };
  var attributes = {
    compressed0: 0,
    compressed1: 1
  };
  TerrainEncoding.prototype.getAttributes = function(buffer) {
    var datatype = ComponentDatatype.FLOAT;
    var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);
    var stride;
    if (this.quantization === TerrainQuantization.NONE) {
      var position3DAndHeightLength = 4;
      var numTexCoordComponents = 2;
      if (this.hasWebMercatorT) {
        ++numTexCoordComponents;
      }
      if (this.hasVertexNormals) {
        ++numTexCoordComponents;
      }
      stride = (position3DAndHeightLength + numTexCoordComponents) * sizeInBytes;
      return [{
        index: attributesNone.position3DAndHeight,
        vertexBuffer: buffer,
        componentDatatype: datatype,
        componentsPerAttribute: position3DAndHeightLength,
        offsetInBytes: 0,
        strideInBytes: stride
      }, {
        index: attributesNone.textureCoordAndEncodedNormals,
        vertexBuffer: buffer,
        componentDatatype: datatype,
        componentsPerAttribute: numTexCoordComponents,
        offsetInBytes: position3DAndHeightLength * sizeInBytes,
        strideInBytes: stride
      }];
    }
    var numCompressed0 = 3;
    var numCompressed1 = 0;
    if (this.hasWebMercatorT || this.hasVertexNormals) {
      ++numCompressed0;
    }
    if (this.hasWebMercatorT && this.hasVertexNormals) {
      ++numCompressed1;
      stride = (numCompressed0 + numCompressed1) * sizeInBytes;
      return [{
        index: attributes.compressed0,
        vertexBuffer: buffer,
        componentDatatype: datatype,
        componentsPerAttribute: numCompressed0,
        offsetInBytes: 0,
        strideInBytes: stride
      }, {
        index: attributes.compressed1,
        vertexBuffer: buffer,
        componentDatatype: datatype,
        componentsPerAttribute: numCompressed1,
        offsetInBytes: numCompressed0 * sizeInBytes,
        strideInBytes: stride
      }];
    } else {
      return [{
        index: attributes.compressed0,
        vertexBuffer: buffer,
        componentDatatype: datatype,
        componentsPerAttribute: numCompressed0
      }];
    }
  };
  TerrainEncoding.prototype.getAttributeLocations = function() {
    if (this.quantization === TerrainQuantization.NONE) {
      return attributesNone;
    } else {
      return attributes;
    }
  };
  TerrainEncoding.clone = function(encoding, result) {
    if (!defined(result)) {
      result = new TerrainEncoding();
    }
    result.quantization = encoding.quantization;
    result.minimumHeight = encoding.minimumHeight;
    result.maximumHeight = encoding.maximumHeight;
    result.center = Cartesian3.clone(encoding.center);
    result.toScaledENU = Matrix4.clone(encoding.toScaledENU);
    result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);
    result.matrix = Matrix4.clone(encoding.matrix);
    result.hasVertexNormals = encoding.hasVertexNormals;
    result.hasWebMercatorT = encoding.hasWebMercatorT;
    return result;
  };
  return TerrainEncoding;
});

})();
(function() {
var define = $__System.amdDefine;
define("7a", ["15"], function(defaultValue) {
  'use strict';
  function TerrainMesh(center, vertices, indices, minimumHeight, maximumHeight, boundingSphere3D, occludeePointInScaledSpace, vertexStride, orientedBoundingBox, encoding, exaggeration) {
    this.center = center;
    this.vertices = vertices;
    this.stride = defaultValue(vertexStride, 6);
    this.indices = indices;
    this.minimumHeight = minimumHeight;
    this.maximumHeight = maximumHeight;
    this.boundingSphere3D = boundingSphere3D;
    this.occludeePointInScaledSpace = occludeePointInScaledSpace;
    this.orientedBoundingBox = orientedBoundingBox;
    this.encoding = encoding;
    this.exaggeration = exaggeration;
  }
  return TerrainMesh;
});

})();
(function() {
var define = $__System.amdDefine;
define("7b", [], function() {
  var MersenneTwister = function(seed) {
    if (seed == undefined) {
      seed = new Date().getTime();
    }
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 0x9908b0df;
    this.UPPER_MASK = 0x80000000;
    this.LOWER_MASK = 0x7fffffff;
    this.mt = new Array(this.N);
    this.mti = this.N + 1;
    this.init_genrand(seed);
  };
  MersenneTwister.prototype.init_genrand = function(s) {
    this.mt[0] = s >>> 0;
    for (this.mti = 1; this.mti < this.N; this.mti++) {
      var s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
      this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
      this.mt[this.mti] >>>= 0;
    }
  };
  MersenneTwister.prototype.genrand_int32 = function() {
    var y;
    var mag01 = new Array(0x0, this.MATRIX_A);
    if (this.mti >= this.N) {
      var kk;
      if (this.mti == this.N + 1)
        this.init_genrand(5489);
      for (kk = 0; kk < this.N - this.M; kk++) {
        y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
        this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
      }
      for (; kk < this.N - 1; kk++) {
        y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
        this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
      }
      y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
      this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];
      this.mti = 0;
    }
    y = this.mt[this.mti++];
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);
    return y >>> 0;
  };
  MersenneTwister.prototype.random = function() {
    return this.genrand_int32() * (1.0 / 4294967296.0);
  };
  return MersenneTwister;
});

})();
(function() {
var define = $__System.amdDefine;
define("11", ["5"], function(defined) {
  'use strict';
  var freezeObject = Object.freeze;
  if (!defined(freezeObject)) {
    freezeObject = function(o) {
      return o;
    };
  }
  return freezeObject;
});

})();
(function() {
var define = $__System.amdDefine;
define("15", ["11"], function(freezeObject) {
  'use strict';
  function defaultValue(a, b) {
    if (a !== undefined) {
      return a;
    }
    return b;
  }
  defaultValue.EMPTY_OBJECT = freezeObject({});
  return defaultValue;
});

})();
(function() {
var define = $__System.amdDefine;
define("d", ["7b", "15", "5", "7"], function(MersenneTwister, defaultValue, defined, DeveloperError) {
  'use strict';
  var CesiumMath = {};
  CesiumMath.EPSILON1 = 0.1;
  CesiumMath.EPSILON2 = 0.01;
  CesiumMath.EPSILON3 = 0.001;
  CesiumMath.EPSILON4 = 0.0001;
  CesiumMath.EPSILON5 = 0.00001;
  CesiumMath.EPSILON6 = 0.000001;
  CesiumMath.EPSILON7 = 0.0000001;
  CesiumMath.EPSILON8 = 0.00000001;
  CesiumMath.EPSILON9 = 0.000000001;
  CesiumMath.EPSILON10 = 0.0000000001;
  CesiumMath.EPSILON11 = 0.00000000001;
  CesiumMath.EPSILON12 = 0.000000000001;
  CesiumMath.EPSILON13 = 0.0000000000001;
  CesiumMath.EPSILON14 = 0.00000000000001;
  CesiumMath.EPSILON15 = 0.000000000000001;
  CesiumMath.EPSILON16 = 0.0000000000000001;
  CesiumMath.EPSILON17 = 0.00000000000000001;
  CesiumMath.EPSILON18 = 0.000000000000000001;
  CesiumMath.EPSILON19 = 0.0000000000000000001;
  CesiumMath.EPSILON20 = 0.00000000000000000001;
  CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;
  CesiumMath.SOLAR_RADIUS = 6.955e8;
  CesiumMath.LUNAR_RADIUS = 1737400.0;
  CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;
  CesiumMath.sign = function(value) {
    if (value > 0) {
      return 1;
    }
    if (value < 0) {
      return -1;
    }
    return 0;
  };
  CesiumMath.signNotZero = function(value) {
    return value < 0.0 ? -1.0 : 1.0;
  };
  CesiumMath.toSNorm = function(value, rangeMax) {
    rangeMax = defaultValue(rangeMax, 255);
    return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMax);
  };
  CesiumMath.fromSNorm = function(value, rangeMax) {
    rangeMax = defaultValue(rangeMax, 255);
    return CesiumMath.clamp(value, 0.0, rangeMax) / rangeMax * 2.0 - 1.0;
  };
  CesiumMath.sinh = function(value) {
    var part1 = Math.pow(Math.E, value);
    var part2 = Math.pow(Math.E, -1.0 * value);
    return (part1 - part2) * 0.5;
  };
  CesiumMath.cosh = function(value) {
    var part1 = Math.pow(Math.E, value);
    var part2 = Math.pow(Math.E, -1.0 * value);
    return (part1 + part2) * 0.5;
  };
  CesiumMath.lerp = function(p, q, time) {
    return ((1.0 - time) * p) + (time * q);
  };
  CesiumMath.PI = Math.PI;
  CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;
  CesiumMath.PI_OVER_TWO = Math.PI * 0.5;
  CesiumMath.PI_OVER_THREE = Math.PI / 3.0;
  CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;
  CesiumMath.PI_OVER_SIX = Math.PI / 6.0;
  CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;
  CesiumMath.TWO_PI = 2.0 * Math.PI;
  CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);
  CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;
  CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;
  CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;
  CesiumMath.toRadians = function(degrees) {
    if (!defined(degrees)) {
      throw new DeveloperError('degrees is required.');
    }
    return degrees * CesiumMath.RADIANS_PER_DEGREE;
  };
  CesiumMath.toDegrees = function(radians) {
    if (!defined(radians)) {
      throw new DeveloperError('radians is required.');
    }
    return radians * CesiumMath.DEGREES_PER_RADIAN;
  };
  CesiumMath.convertLongitudeRange = function(angle) {
    if (!defined(angle)) {
      throw new DeveloperError('angle is required.');
    }
    var twoPi = CesiumMath.TWO_PI;
    var simplified = angle - Math.floor(angle / twoPi) * twoPi;
    if (simplified < -Math.PI) {
      return simplified + twoPi;
    }
    if (simplified >= Math.PI) {
      return simplified - twoPi;
    }
    return simplified;
  };
  CesiumMath.clampToLatitudeRange = function(angle) {
    if (!defined(angle)) {
      throw new DeveloperError('angle is required.');
    }
    return CesiumMath.clamp(angle, -1 * CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);
  };
  CesiumMath.negativePiToPi = function(angle) {
    if (!defined(angle)) {
      throw new DeveloperError('angle is required.');
    }
    return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;
  };
  CesiumMath.zeroToTwoPi = function(angle) {
    if (!defined(angle)) {
      throw new DeveloperError('angle is required.');
    }
    var mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);
    if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(angle) > CesiumMath.EPSILON14) {
      return CesiumMath.TWO_PI;
    }
    return mod;
  };
  CesiumMath.mod = function(m, n) {
    if (!defined(m)) {
      throw new DeveloperError('m is required.');
    }
    if (!defined(n)) {
      throw new DeveloperError('n is required.');
    }
    return ((m % n) + n) % n;
  };
  CesiumMath.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
    if (!defined(left)) {
      throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
      throw new DeveloperError('right is required.');
    }
    if (!defined(relativeEpsilon)) {
      throw new DeveloperError('relativeEpsilon is required.');
    }
    absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
    var absDiff = Math.abs(left - right);
    return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
  };
  var factorials = [1];
  CesiumMath.factorial = function(n) {
    if (typeof n !== 'number' || n < 0) {
      throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    var length = factorials.length;
    if (n >= length) {
      var sum = factorials[length - 1];
      for (var i = length; i <= n; i++) {
        factorials.push(sum * i);
      }
    }
    return factorials[n];
  };
  CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {
    minimumValue = defaultValue(minimumValue, 0.0);
    if (!defined(n)) {
      throw new DeveloperError('n is required.');
    }
    if (maximumValue <= minimumValue) {
      throw new DeveloperError('maximumValue must be greater than minimumValue.');
    }
    ++n;
    if (n > maximumValue) {
      n = minimumValue;
    }
    return n;
  };
  CesiumMath.isPowerOfTwo = function(n) {
    if (typeof n !== 'number' || n < 0) {
      throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    return (n !== 0) && ((n & (n - 1)) === 0);
  };
  CesiumMath.nextPowerOfTwo = function(n) {
    if (typeof n !== 'number' || n < 0) {
      throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    --n;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    ++n;
    return n;
  };
  CesiumMath.clamp = function(value, min, max) {
    if (!defined(value)) {
      throw new DeveloperError('value is required');
    }
    if (!defined(min)) {
      throw new DeveloperError('min is required.');
    }
    if (!defined(max)) {
      throw new DeveloperError('max is required.');
    }
    return value < min ? min : value > max ? max : value;
  };
  var randomNumberGenerator = new MersenneTwister();
  CesiumMath.setRandomNumberSeed = function(seed) {
    if (!defined(seed)) {
      throw new DeveloperError('seed is required.');
    }
    randomNumberGenerator = new MersenneTwister(seed);
  };
  CesiumMath.nextRandomNumber = function() {
    return randomNumberGenerator.random();
  };
  CesiumMath.acosClamped = function(value) {
    if (!defined(value)) {
      throw new DeveloperError('value is required.');
    }
    return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
  };
  CesiumMath.asinClamped = function(value) {
    if (!defined(value)) {
      throw new DeveloperError('value is required.');
    }
    return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
  };
  CesiumMath.chordLength = function(angle, radius) {
    if (!defined(angle)) {
      throw new DeveloperError('angle is required.');
    }
    if (!defined(radius)) {
      throw new DeveloperError('radius is required.');
    }
    return 2.0 * radius * Math.sin(angle * 0.5);
  };
  CesiumMath.logBase = function(number, base) {
    if (!defined(number)) {
      throw new DeveloperError('number is required.');
    }
    if (!defined(base)) {
      throw new DeveloperError('base is required.');
    }
    return Math.log(number) / Math.log(base);
  };
  CesiumMath.fog = function(distanceToCamera, density) {
    var scalar = distanceToCamera * density;
    return 1.0 - Math.exp(-(scalar * scalar));
  };
  return CesiumMath;
});

})();
(function() {
var define = $__System.amdDefine;
define("7c", ["5", "6", "7", "d"], function(defined, defineProperties, DeveloperError, CesiumMath) {
  'use strict';
  function TerrainProvider() {
    DeveloperError.throwInstantiationError();
  }
  defineProperties(TerrainProvider.prototype, {
    errorEvent: {get: DeveloperError.throwInstantiationError},
    credit: {get: DeveloperError.throwInstantiationError},
    tilingScheme: {get: DeveloperError.throwInstantiationError},
    ready: {get: DeveloperError.throwInstantiationError},
    readyPromise: {get: DeveloperError.throwInstantiationError},
    hasWaterMask: {get: DeveloperError.throwInstantiationError},
    hasVertexNormals: {get: DeveloperError.throwInstantiationError},
    availability: {get: DeveloperError.throwInstantiationError}
  });
  var regularGridIndexArrays = [];
  TerrainProvider.getRegularGridIndices = function(width, height) {
    if (width * height >= CesiumMath.SIXTY_FOUR_KILOBYTES) {
      throw new DeveloperError('The total number of vertices (width * height) must be less than 65536.');
    }
    var byWidth = regularGridIndexArrays[width];
    if (!defined(byWidth)) {
      regularGridIndexArrays[width] = byWidth = [];
    }
    var indices = byWidth[height];
    if (!defined(indices)) {
      indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);
      var index = 0;
      var indicesIndex = 0;
      for (var j = 0; j < height - 1; ++j) {
        for (var i = 0; i < width - 1; ++i) {
          var upperLeft = index;
          var lowerLeft = upperLeft + width;
          var lowerRight = lowerLeft + 1;
          var upperRight = upperLeft + 1;
          indices[indicesIndex++] = upperLeft;
          indices[indicesIndex++] = lowerLeft;
          indices[indicesIndex++] = upperRight;
          indices[indicesIndex++] = upperRight;
          indices[indicesIndex++] = lowerLeft;
          indices[indicesIndex++] = lowerRight;
          ++index;
        }
        ++index;
      }
    }
    return indices;
  };
  TerrainProvider.heightmapTerrainQuality = 0.25;
  TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {
    return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);
  };
  TerrainProvider.prototype.requestTileGeometry = DeveloperError.throwInstantiationError;
  TerrainProvider.prototype.getLevelMaximumGeometricError = DeveloperError.throwInstantiationError;
  TerrainProvider.prototype.getTileDataAvailable = DeveloperError.throwInstantiationError;
  return TerrainProvider;
});

})();
(function() {
var define = $__System.amdDefine;
define("7d", ["48", "15", "5", "6", "7", "50", "6f", "d", "4d", "74", "70", "7a", "7c"], function(when, defaultValue, defined, defineProperties, DeveloperError, GeographicTilingScheme, HeightmapTessellator, CesiumMath, Rectangle, TaskProcessor, TerrainEncoding, TerrainMesh, TerrainProvider) {
  'use strict';
  function HeightmapTerrainData(options) {
    if (!defined(options) || !defined(options.buffer)) {
      throw new DeveloperError('options.buffer is required.');
    }
    if (!defined(options.width)) {
      throw new DeveloperError('options.width is required.');
    }
    if (!defined(options.height)) {
      throw new DeveloperError('options.height is required.');
    }
    this._buffer = options.buffer;
    this._width = options.width;
    this._height = options.height;
    this._childTileMask = defaultValue(options.childTileMask, 15);
    var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;
    var structure = options.structure;
    if (!defined(structure)) {
      structure = defaultStructure;
    } else if (structure !== defaultStructure) {
      structure.heightScale = defaultValue(structure.heightScale, defaultStructure.heightScale);
      structure.heightOffset = defaultValue(structure.heightOffset, defaultStructure.heightOffset);
      structure.elementsPerHeight = defaultValue(structure.elementsPerHeight, defaultStructure.elementsPerHeight);
      structure.stride = defaultValue(structure.stride, defaultStructure.stride);
      structure.elementMultiplier = defaultValue(structure.elementMultiplier, defaultStructure.elementMultiplier);
      structure.isBigEndian = defaultValue(structure.isBigEndian, defaultStructure.isBigEndian);
    }
    this._structure = structure;
    this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);
    this._waterMask = options.waterMask;
    this._skirtHeight = undefined;
    this._bufferType = this._buffer.constructor;
    this._mesh = undefined;
  }
  defineProperties(HeightmapTerrainData.prototype, {waterMask: {get: function() {
        return this._waterMask;
      }}});
  var taskProcessor = new TaskProcessor('createVerticesFromHeightmap');
  HeightmapTerrainData.prototype.createMesh = function(tilingScheme, x, y, level, exaggeration) {
    if (!defined(tilingScheme)) {
      throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(x)) {
      throw new DeveloperError('x is required.');
    }
    if (!defined(y)) {
      throw new DeveloperError('y is required.');
    }
    if (!defined(level)) {
      throw new DeveloperError('level is required.');
    }
    var ellipsoid = tilingScheme.ellipsoid;
    var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
    var rectangle = tilingScheme.tileXYToRectangle(x, y, level);
    exaggeration = defaultValue(exaggeration, 1.0);
    var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));
    var structure = this._structure;
    var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));
    var thisLevelMaxError = levelZeroMaxError / (1 << level);
    this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);
    var verticesPromise = taskProcessor.scheduleTask({
      heightmap: this._buffer,
      structure: structure,
      includeWebMercatorT: true,
      width: this._width,
      height: this._height,
      nativeRectangle: nativeRectangle,
      rectangle: rectangle,
      relativeToCenter: center,
      ellipsoid: ellipsoid,
      skirtHeight: this._skirtHeight,
      isGeographic: tilingScheme instanceof GeographicTilingScheme,
      exaggeration: exaggeration
    });
    if (!defined(verticesPromise)) {
      return undefined;
    }
    var that = this;
    return when(verticesPromise, function(result) {
      that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), TerrainProvider.getRegularGridIndices(result.gridWidth, result.gridHeight), result.minimumHeight, result.maximumHeight, result.boundingSphere3D, result.occludeePointInScaledSpace, result.numberOfAttributes, result.orientedBoundingBox, TerrainEncoding.clone(result.encoding), exaggeration);
      that._buffer = undefined;
      return that._mesh;
    });
  };
  HeightmapTerrainData.prototype.interpolateHeight = function(rectangle, longitude, latitude) {
    var width = this._width;
    var height = this._height;
    var structure = this._structure;
    var stride = structure.stride;
    var elementsPerHeight = structure.elementsPerHeight;
    var elementMultiplier = structure.elementMultiplier;
    var isBigEndian = structure.isBigEndian;
    var heightOffset = structure.heightOffset;
    var heightScale = structure.heightScale;
    var heightSample;
    if (defined(this._mesh)) {
      var buffer = this._mesh.vertices;
      var encoding = this._mesh.encoding;
      var skirtHeight = this._skirtHeight;
      var exaggeration = this._mesh.exaggeration;
      heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, skirtHeight, rectangle, width, height, longitude, latitude, exaggeration);
    } else {
      heightSample = interpolateHeight(this._buffer, elementsPerHeight, elementMultiplier, stride, isBigEndian, rectangle, width, height, longitude, latitude);
      heightSample = heightSample * heightScale + heightOffset;
    }
    return heightSample;
  };
  HeightmapTerrainData.prototype.upsample = function(tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
    if (!defined(tilingScheme)) {
      throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(thisX)) {
      throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
      throw new DeveloperError('thisY is required.');
    }
    if (!defined(thisLevel)) {
      throw new DeveloperError('thisLevel is required.');
    }
    if (!defined(descendantX)) {
      throw new DeveloperError('descendantX is required.');
    }
    if (!defined(descendantY)) {
      throw new DeveloperError('descendantY is required.');
    }
    if (!defined(descendantLevel)) {
      throw new DeveloperError('descendantLevel is required.');
    }
    var levelDifference = descendantLevel - thisLevel;
    if (levelDifference > 1) {
      throw new DeveloperError('Upsampling through more than one level at a time is not currently supported.');
    }
    var width = this._width;
    var height = this._height;
    var structure = this._structure;
    var skirtHeight = this._skirtHeight;
    var stride = structure.stride;
    var heights = new this._bufferType(width * height * stride);
    var meshData = this._mesh;
    if (!defined(meshData)) {
      return undefined;
    }
    var buffer = meshData.vertices;
    var encoding = meshData.encoding;
    var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);
    var destinationRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);
    var heightOffset = structure.heightOffset;
    var heightScale = structure.heightScale;
    var exaggeration = meshData.exaggeration;
    var elementsPerHeight = structure.elementsPerHeight;
    var elementMultiplier = structure.elementMultiplier;
    var isBigEndian = structure.isBigEndian;
    var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);
    for (var j = 0; j < height; ++j) {
      var latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));
      for (var i = 0; i < width; ++i) {
        var longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));
        var heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, skirtHeight, sourceRectangle, width, height, longitude, latitude, exaggeration);
        heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;
        heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;
        setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, j * width + i, heightSample);
      }
    }
    return new HeightmapTerrainData({
      buffer: heights,
      width: width,
      height: height,
      childTileMask: 0,
      structure: this._structure,
      createdByUpsampling: true
    });
  };
  HeightmapTerrainData.prototype.isChildAvailable = function(thisX, thisY, childX, childY) {
    if (!defined(thisX)) {
      throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
      throw new DeveloperError('thisY is required.');
    }
    if (!defined(childX)) {
      throw new DeveloperError('childX is required.');
    }
    if (!defined(childY)) {
      throw new DeveloperError('childY is required.');
    }
    var bitNumber = 2;
    if (childX !== thisX * 2) {
      ++bitNumber;
    }
    if (childY !== thisY * 2) {
      bitNumber -= 2;
    }
    return (this._childTileMask & (1 << bitNumber)) !== 0;
  };
  HeightmapTerrainData.prototype.wasCreatedByUpsampling = function() {
    return this._createdByUpsampling;
  };
  function interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {
    var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
    var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
    var westInteger = fromWest | 0;
    var eastInteger = westInteger + 1;
    if (eastInteger >= width) {
      eastInteger = width - 1;
      westInteger = width - 2;
    }
    var southInteger = fromSouth | 0;
    var northInteger = southInteger + 1;
    if (northInteger >= height) {
      northInteger = height - 1;
      southInteger = height - 2;
    }
    var dx = fromWest - westInteger;
    var dy = fromSouth - southInteger;
    southInteger = height - 1 - southInteger;
    northInteger = height - 1 - northInteger;
    var southwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + westInteger);
    var southeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + eastInteger);
    var northwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + westInteger);
    var northeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + eastInteger);
    return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);
  }
  function interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, skirtHeight, sourceRectangle, width, height, longitude, latitude, exaggeration) {
    var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
    var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
    if (skirtHeight > 0) {
      fromWest += 1.0;
      fromSouth += 1.0;
      width += 2;
      height += 2;
    }
    var widthEdge = (skirtHeight > 0) ? width - 1 : width;
    var westInteger = fromWest | 0;
    var eastInteger = westInteger + 1;
    if (eastInteger >= widthEdge) {
      eastInteger = width - 1;
      westInteger = width - 2;
    }
    var heightEdge = (skirtHeight > 0) ? height - 1 : height;
    var southInteger = fromSouth | 0;
    var northInteger = southInteger + 1;
    if (northInteger >= heightEdge) {
      northInteger = height - 1;
      southInteger = height - 2;
    }
    var dx = fromWest - westInteger;
    var dy = fromSouth - southInteger;
    southInteger = height - 1 - southInteger;
    northInteger = height - 1 - northInteger;
    var southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;
    var southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;
    var northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;
    var northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;
    return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);
  }
  function triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {
    if (dY < dX) {
      return southwestHeight + (dX * (southeastHeight - southwestHeight)) + (dY * (northeastHeight - southeastHeight));
    }
    return southwestHeight + (dX * (northeastHeight - northwestHeight)) + (dY * (northwestHeight - southwestHeight));
  }
  function getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {
    index *= stride;
    var height = 0;
    var i;
    if (isBigEndian) {
      for (i = 0; i < elementsPerHeight; ++i) {
        height = (height * elementMultiplier) + heights[index + i];
      }
    } else {
      for (i = elementsPerHeight - 1; i >= 0; --i) {
        height = (height * elementMultiplier) + heights[index + i];
      }
    }
    return height;
  }
  function setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {
    index *= stride;
    var i;
    if (isBigEndian) {
      for (i = 0; i < elementsPerHeight - 1; ++i) {
        heights[index + i] = (height / divisor) | 0;
        height -= heights[index + i] * divisor;
        divisor /= elementMultiplier;
      }
    } else {
      for (i = elementsPerHeight - 1; i > 0; --i) {
        heights[index + i] = (height / divisor) | 0;
        height -= heights[index + i] * divisor;
        divisor /= elementMultiplier;
      }
    }
    heights[index + i] = height;
  }
  return HeightmapTerrainData;
});

})();
(function() {
var define = $__System.amdDefine;
define("6", ["5"], function(defined) {
  'use strict';
  var definePropertyWorks = (function() {
    try {
      return 'x' in Object.defineProperty({}, 'x', {});
    } catch (e) {
      return false;
    }
  })();
  var defineProperties = Object.defineProperties;
  if (!definePropertyWorks || !defined(defineProperties)) {
    defineProperties = function(o) {
      return o;
    };
  }
  return defineProperties;
});

})();
(function() {
var define = $__System.amdDefine;
define("7e", ["5", "6", "7"], function(defined, defineProperties, DeveloperError) {
  'use strict';
  var nextCreditId = 0;
  var creditToId = {};
  function Credit(text, imageUrl, link) {
    var hasLink = (defined(link));
    var hasImage = (defined(imageUrl));
    var hasText = (defined(text));
    if (!hasText && !hasImage && !hasLink) {
      throw new DeveloperError('text, imageUrl or link is required');
    }
    if (!hasText && !hasImage) {
      text = link;
    }
    this._text = text;
    this._imageUrl = imageUrl;
    this._link = link;
    this._hasLink = hasLink;
    this._hasImage = hasImage;
    var id;
    var key = JSON.stringify([text, imageUrl, link]);
    if (defined(creditToId[key])) {
      id = creditToId[key];
    } else {
      id = nextCreditId++;
      creditToId[key] = id;
    }
    this._id = id;
  }
  defineProperties(Credit.prototype, {
    text: {get: function() {
        return this._text;
      }},
    imageUrl: {get: function() {
        return this._imageUrl;
      }},
    link: {get: function() {
        return this._link;
      }},
    id: {get: function() {
        return this._id;
      }}
  });
  Credit.prototype.hasImage = function() {
    return this._hasImage;
  };
  Credit.prototype.hasLink = function() {
    return this._hasLink;
  };
  Credit.equals = function(left, right) {
    return (left === right) || ((defined(left)) && (defined(right)) && (left._id === right._id));
  };
  Credit.prototype.equals = function(credit) {
    return Credit.equals(this, credit);
  };
  return Credit;
});

})();
(function() {
var define = $__System.amdDefine;
(function(define) {
  'use strict';
  define("48", [], function() {
    var reduceArray,
        slice,
        undef;
    when.defer = defer;
    when.resolve = resolve;
    when.reject = reject;
    when.join = join;
    when.all = all;
    when.map = map;
    when.reduce = reduce;
    when.any = any;
    when.some = some;
    when.chain = chain;
    when.isPromise = isPromise;
    function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
      return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
    }
    function resolve(promiseOrValue) {
      var promise,
          deferred;
      if (promiseOrValue instanceof Promise) {
        promise = promiseOrValue;
      } else {
        if (isPromise(promiseOrValue)) {
          deferred = defer();
          promiseOrValue.then(function(value) {
            deferred.resolve(value);
          }, function(reason) {
            deferred.reject(reason);
          }, function(update) {
            deferred.progress(update);
          });
          promise = deferred.promise;
        } else {
          promise = fulfilled(promiseOrValue);
        }
      }
      return promise;
    }
    function reject(promiseOrValue) {
      return when(promiseOrValue, rejected);
    }
    function Promise(then) {
      this.then = then;
    }
    Promise.prototype = {
      always: function(onFulfilledOrRejected, onProgress) {
        return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
      },
      otherwise: function(onRejected) {
        return this.then(undef, onRejected);
      },
      yield: function(value) {
        return this.then(function() {
          return value;
        });
      },
      spread: function(onFulfilled) {
        return this.then(function(array) {
          return all(array, function(array) {
            return onFulfilled.apply(undef, array);
          });
        });
      }
    };
    function fulfilled(value) {
      var p = new Promise(function(onFulfilled) {
        try {
          return resolve(onFulfilled ? onFulfilled(value) : value);
        } catch (e) {
          return rejected(e);
        }
      });
      return p;
    }
    function rejected(reason) {
      var p = new Promise(function(_, onRejected) {
        try {
          return onRejected ? resolve(onRejected(reason)) : rejected(reason);
        } catch (e) {
          return rejected(e);
        }
      });
      return p;
    }
    function defer() {
      var deferred,
          promise,
          handlers,
          progressHandlers,
          _then,
          _progress,
          _resolve;
      promise = new Promise(then);
      deferred = {
        then: then,
        resolve: promiseResolve,
        reject: promiseReject,
        progress: promiseProgress,
        promise: promise,
        resolver: {
          resolve: promiseResolve,
          reject: promiseReject,
          progress: promiseProgress
        }
      };
      handlers = [];
      progressHandlers = [];
      _then = function(onFulfilled, onRejected, onProgress) {
        var deferred,
            progressHandler;
        deferred = defer();
        progressHandler = typeof onProgress === 'function' ? function(update) {
          try {
            deferred.progress(onProgress(update));
          } catch (e) {
            deferred.progress(e);
          }
        } : function(update) {
          deferred.progress(update);
        };
        handlers.push(function(promise) {
          promise.then(onFulfilled, onRejected).then(deferred.resolve, deferred.reject, progressHandler);
        });
        progressHandlers.push(progressHandler);
        return deferred.promise;
      };
      _progress = function(update) {
        processQueue(progressHandlers, update);
        return update;
      };
      _resolve = function(value) {
        value = resolve(value);
        _then = value.then;
        _resolve = resolve;
        _progress = noop;
        processQueue(handlers, value);
        progressHandlers = handlers = undef;
        return value;
      };
      return deferred;
      function then(onFulfilled, onRejected, onProgress) {
        return _then(onFulfilled, onRejected, onProgress);
      }
      function promiseResolve(val) {
        return _resolve(val);
      }
      function promiseReject(err) {
        return _resolve(rejected(err));
      }
      function promiseProgress(update) {
        return _progress(update);
      }
    }
    function isPromise(promiseOrValue) {
      return promiseOrValue && typeof promiseOrValue.then === 'function';
    }
    function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {
      checkCallbacks(2, arguments);
      return when(promisesOrValues, function(promisesOrValues) {
        var toResolve,
            toReject,
            values,
            reasons,
            deferred,
            fulfillOne,
            rejectOne,
            progress,
            len,
            i;
        len = promisesOrValues.length >>> 0;
        toResolve = Math.max(0, Math.min(howMany, len));
        values = [];
        toReject = (len - toResolve) + 1;
        reasons = [];
        deferred = defer();
        if (!toResolve) {
          deferred.resolve(values);
        } else {
          progress = deferred.progress;
          rejectOne = function(reason) {
            reasons.push(reason);
            if (!--toReject) {
              fulfillOne = rejectOne = noop;
              deferred.reject(reasons);
            }
          };
          fulfillOne = function(val) {
            values.push(val);
            if (!--toResolve) {
              fulfillOne = rejectOne = noop;
              deferred.resolve(values);
            }
          };
          for (i = 0; i < len; ++i) {
            if (i in promisesOrValues) {
              when(promisesOrValues[i], fulfiller, rejecter, progress);
            }
          }
        }
        return deferred.then(onFulfilled, onRejected, onProgress);
        function rejecter(reason) {
          rejectOne(reason);
        }
        function fulfiller(val) {
          fulfillOne(val);
        }
      });
    }
    function any(promisesOrValues, onFulfilled, onRejected, onProgress) {
      function unwrapSingleResult(val) {
        return onFulfilled ? onFulfilled(val[0]) : val[0];
      }
      return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
    }
    function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
      checkCallbacks(1, arguments);
      return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
    }
    function join() {
      return map(arguments, identity);
    }
    function map(promise, mapFunc) {
      return when(promise, function(array) {
        var results,
            len,
            toResolve,
            resolve,
            i,
            d;
        toResolve = len = array.length >>> 0;
        results = [];
        d = defer();
        if (!toResolve) {
          d.resolve(results);
        } else {
          resolve = function resolveOne(item, i) {
            when(item, mapFunc).then(function(mapped) {
              results[i] = mapped;
              if (!--toResolve) {
                d.resolve(results);
              }
            }, d.reject);
          };
          for (i = 0; i < len; i++) {
            if (i in array) {
              resolve(array[i], i);
            } else {
              --toResolve;
            }
          }
        }
        return d.promise;
      });
    }
    function reduce(promise, reduceFunc) {
      var args = slice.call(arguments, 1);
      return when(promise, function(array) {
        var total;
        total = array.length;
        args[0] = function(current, val, i) {
          return when(current, function(c) {
            return when(val, function(value) {
              return reduceFunc(c, value, i, total);
            });
          });
        };
        return reduceArray.apply(array, args);
      });
    }
    function chain(promiseOrValue, resolver, resolveValue) {
      var useResolveValue = arguments.length > 2;
      return when(promiseOrValue, function(val) {
        val = useResolveValue ? resolveValue : val;
        resolver.resolve(val);
        return val;
      }, function(reason) {
        resolver.reject(reason);
        return rejected(reason);
      }, resolver.progress);
    }
    function processQueue(queue, value) {
      var handler,
          i = 0;
      while (handler = queue[i++]) {
        handler(value);
      }
    }
    function checkCallbacks(start, arrayOfCallbacks) {
      var arg,
          i = arrayOfCallbacks.length;
      while (i > start) {
        arg = arrayOfCallbacks[--i];
        if (arg != null && typeof arg != 'function') {
          throw new Error('arg ' + i + ' must be a function');
        }
      }
    }
    function noop() {}
    slice = [].slice;
    reduceArray = [].reduce || function(reduceFunc) {
      var arr,
          args,
          reduced,
          len,
          i;
      i = 0;
      arr = Object(this);
      len = arr.length >>> 0;
      args = arguments;
      if (args.length <= 1) {
        for (; ; ) {
          if (i in arr) {
            reduced = arr[i++];
            break;
          }
          if (++i >= len) {
            throw new TypeError();
          }
        }
      } else {
        reduced = args[1];
      }
      for (; i < len; ++i) {
        if (i in arr) {
          reduced = reduceFunc(reduced, arr[i], i, arr);
        }
      }
      return reduced;
    };
    function identity(x) {
      return x;
    }
    return when;
  });
})(typeof define == 'function' && define.amd ? define : function(factory) {
  typeof exports === 'object' ? (module.exports = factory()) : (this.when = factory());
});

})();
(function() {
var define = $__System.amdDefine;
define("5", [], function() {
  'use strict';
  function defined(value) {
    return value !== undefined && value !== null;
  }
  return defined;
});

})();
(function() {
var define = $__System.amdDefine;
define("7", ["5"], function(defined) {
  'use strict';
  function DeveloperError(message) {
    this.name = 'DeveloperError';
    this.message = message;
    var stack;
    try {
      throw new Error();
    } catch (e) {
      stack = e.stack;
    }
    this.stack = stack;
  }
  if (defined(Object.create)) {
    DeveloperError.prototype = Object.create(Error.prototype);
    DeveloperError.prototype.constructor = DeveloperError;
  }
  DeveloperError.prototype.toString = function() {
    var str = this.name + ': ' + this.message;
    if (defined(this.stack)) {
      str += '\n' + this.stack.toString();
    }
    return str;
  };
  DeveloperError.throwInstantiationError = function() {
    throw new DeveloperError('This function defines an interface and should not be called directly.');
  };
  return DeveloperError;
});

})();
(function() {
var define = $__System.amdDefine;
define("7f", ["48", "5", "7"], function(when, defined, DeveloperError) {
  'use strict';
  function sampleTerrain(terrainProvider, level, positions) {
    if (!defined(terrainProvider)) {
      throw new DeveloperError('terrainProvider is required.');
    }
    if (!defined(level)) {
      throw new DeveloperError('level is required.');
    }
    if (!defined(positions)) {
      throw new DeveloperError('positions is required.');
    }
    var deferred = when.defer();
    function doSamplingWhenReady() {
      if (terrainProvider.ready) {
        when(doSampling(terrainProvider, level, positions), function(updatedPositions) {
          deferred.resolve(updatedPositions);
        });
      } else {
        setTimeout(doSamplingWhenReady, 10);
      }
    }
    doSamplingWhenReady();
    return deferred.promise;
  }
  function doSampling(terrainProvider, level, positions) {
    var tilingScheme = terrainProvider.tilingScheme;
    var i;
    var tileRequests = [];
    var tileRequestSet = {};
    for (i = 0; i < positions.length; ++i) {
      var xy = tilingScheme.positionToTileXY(positions[i], level);
      var key = xy.toString();
      if (!tileRequestSet.hasOwnProperty(key)) {
        var value = {
          x: xy.x,
          y: xy.y,
          level: level,
          tilingScheme: tilingScheme,
          terrainProvider: terrainProvider,
          positions: []
        };
        tileRequestSet[key] = value;
        tileRequests.push(value);
      }
      tileRequestSet[key].positions.push(positions[i]);
    }
    var tilePromises = [];
    for (i = 0; i < tileRequests.length; ++i) {
      var tileRequest = tileRequests[i];
      var requestPromise = tileRequest.terrainProvider.requestTileGeometry(tileRequest.x, tileRequest.y, tileRequest.level, false);
      var tilePromise = when(requestPromise, createInterpolateFunction(tileRequest), createMarkFailedFunction(tileRequest));
      tilePromises.push(tilePromise);
    }
    return when.all(tilePromises, function() {
      return positions;
    });
  }
  function createInterpolateFunction(tileRequest) {
    var tilePositions = tileRequest.positions;
    var rectangle = tileRequest.tilingScheme.tileXYToRectangle(tileRequest.x, tileRequest.y, tileRequest.level);
    return function(terrainData) {
      for (var i = 0; i < tilePositions.length; ++i) {
        var position = tilePositions[i];
        position.height = terrainData.interpolateHeight(rectangle, position.longitude, position.latitude);
      }
    };
  }
  function createMarkFailedFunction(tileRequest) {
    var tilePositions = tileRequest.positions;
    return function() {
      for (var i = 0; i < tilePositions.length; ++i) {
        var position = tilePositions[i];
        position.height = undefined;
      }
    };
  }
  return sampleTerrain;
});

})();
$__System.registerDynamic('80', ['81', '82', '83'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var CardboardUI = $__require('81');
  var Util = $__require('82');
  var WGLUPreserveGLState = $__require('83');

  var distortionVS = ['attribute vec2 position;', 'attribute vec3 texCoord;', 'varying vec2 vTexCoord;', 'uniform vec4 viewportOffsetScale[2];', 'void main() {', '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];', '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;', '  gl_Position = vec4( position, 1.0, 1.0 );', '}'].join('\n');

  var distortionFS = ['precision mediump float;', 'uniform sampler2D diffuse;', 'varying vec2 vTexCoord;', 'void main() {', '  gl_FragColor = texture2D(diffuse, vTexCoord);', '}'].join('\n');

  /**
   * A mesh-based distorter.
   */
  function CardboardDistorter(gl) {
    this.gl = gl;
    this.ctxAttribs = gl.getContextAttributes();

    this.meshWidth = 20;
    this.meshHeight = 20;

    this.bufferScale = WebVRConfig.BUFFER_SCALE;

    this.bufferWidth = gl.drawingBufferWidth;
    this.bufferHeight = gl.drawingBufferHeight;

    // Patching support
    this.realBindFramebuffer = gl.bindFramebuffer;
    this.realEnable = gl.enable;
    this.realDisable = gl.disable;
    this.realColorMask = gl.colorMask;
    this.realClearColor = gl.clearColor;
    this.realViewport = gl.viewport;

    if (!Util.isIOS()) {
      this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
      this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
    }

    this.isPatched = false;

    // State tracking
    this.lastBoundFramebuffer = null;
    this.cullFace = false;
    this.depthTest = false;
    this.blend = false;
    this.scissorTest = false;
    this.stencilTest = false;
    this.viewport = [0, 0, 0, 0];
    this.colorMask = [true, true, true, true];
    this.clearColor = [0, 0, 0, 0];

    this.attribs = {
      position: 0,
      texCoord: 1
    };
    this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
    this.uniforms = Util.getProgramUniforms(gl, this.program);

    this.viewportOffsetScale = new Float32Array(8);
    this.setTextureBounds();

    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();
    this.indexCount = 0;

    this.renderTarget = gl.createTexture();
    this.framebuffer = gl.createFramebuffer();

    this.depthStencilBuffer = null;
    this.depthBuffer = null;
    this.stencilBuffer = null;

    if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
      this.depthStencilBuffer = gl.createRenderbuffer();
    } else if (this.ctxAttribs.depth) {
      this.depthBuffer = gl.createRenderbuffer();
    } else if (this.ctxAttribs.stencil) {
      this.stencilBuffer = gl.createRenderbuffer();
    }

    this.patch();

    this.onResize();

    if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
      this.cardboardUI = new CardboardUI(gl);
    }
  };

  /**
   * Tears down all the resources created by the distorter and removes any
   * patches.
   */
  CardboardDistorter.prototype.destroy = function () {
    var gl = this.gl;

    this.unpatch();

    gl.deleteProgram(this.program);
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.indexBuffer);
    gl.deleteTexture(this.renderTarget);
    gl.deleteFramebuffer(this.framebuffer);
    if (this.depthStencilBuffer) {
      gl.deleteRenderbuffer(this.depthStencilBuffer);
    }
    if (this.depthBuffer) {
      gl.deleteRenderbuffer(this.depthBuffer);
    }
    if (this.stencilBuffer) {
      gl.deleteRenderbuffer(this.stencilBuffer);
    }

    if (this.cardboardUI) {
      this.cardboardUI.destroy();
    }
  };

  /**
   * Resizes the backbuffer to match the canvas width and height.
   */
  CardboardDistorter.prototype.onResize = function () {
    var gl = this.gl;
    var self = this;

    var glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];

    WGLUPreserveGLState(gl, glState, function (gl) {
      // Bind real backbuffer and clear it once. We don't need to clear it again
      // after that because we're overwriting the same area every frame.
      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

      // Put things in a good state
      if (self.scissorTest) {
        self.realDisable.call(gl, gl.SCISSOR_TEST);
      }
      self.realColorMask.call(gl, true, true, true, true);
      self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      self.realClearColor.call(gl, 0, 0, 0, 1);

      gl.clear(gl.COLOR_BUFFER_BIT);

      // Now bind and resize the fake backbuffer
      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);

      gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
      gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, self.bufferWidth, self.bufferHeight, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);

      if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, self.bufferWidth, self.bufferHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.depthStencilBuffer);
      } else if (self.ctxAttribs.depth) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, self.bufferWidth, self.bufferHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, self.depthBuffer);
      } else if (self.ctxAttribs.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, self.bufferWidth, self.bufferHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.stencilBuffer);
      }

      if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        console.error('Framebuffer incomplete!');
      }

      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);

      if (self.scissorTest) {
        self.realEnable.call(gl, gl.SCISSOR_TEST);
      }

      self.realColorMask.apply(gl, self.colorMask);
      self.realViewport.apply(gl, self.viewport);
      self.realClearColor.apply(gl, self.clearColor);
    });

    if (this.cardboardUI) {
      this.cardboardUI.onResize();
    }
  };

  CardboardDistorter.prototype.patch = function () {
    if (this.isPatched) {
      return;
    }

    var self = this;
    var canvas = this.gl.canvas;
    var gl = this.gl;

    if (!Util.isIOS()) {
      canvas.width = Util.getScreenWidth() * this.bufferScale;
      canvas.height = Util.getScreenHeight() * this.bufferScale;

      Object.defineProperty(canvas, 'width', {
        configurable: true,
        enumerable: true,
        get: function () {
          return self.bufferWidth;
        },
        set: function (value) {
          self.bufferWidth = value;
          self.onResize();
        }
      });

      Object.defineProperty(canvas, 'height', {
        configurable: true,
        enumerable: true,
        get: function () {
          return self.bufferHeight;
        },
        set: function (value) {
          self.bufferHeight = value;
          self.onResize();
        }
      });
    }

    this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);

    if (this.lastBoundFramebuffer == null) {
      this.lastBoundFramebuffer = this.framebuffer;
      this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    }

    this.gl.bindFramebuffer = function (target, framebuffer) {
      self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
      // Silently make calls to bind the default framebuffer bind ours instead.
      self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
    };

    this.cullFace = gl.getParameter(gl.CULL_FACE);
    this.depthTest = gl.getParameter(gl.DEPTH_TEST);
    this.blend = gl.getParameter(gl.BLEND);
    this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
    this.stencilTest = gl.getParameter(gl.STENCIL_TEST);

    gl.enable = function (pname) {
      switch (pname) {
        case gl.CULL_FACE:
          self.cullFace = true;break;
        case gl.DEPTH_TEST:
          self.depthTest = true;break;
        case gl.BLEND:
          self.blend = true;break;
        case gl.SCISSOR_TEST:
          self.scissorTest = true;break;
        case gl.STENCIL_TEST:
          self.stencilTest = true;break;
      }
      self.realEnable.call(gl, pname);
    };

    gl.disable = function (pname) {
      switch (pname) {
        case gl.CULL_FACE:
          self.cullFace = false;break;
        case gl.DEPTH_TEST:
          self.depthTest = false;break;
        case gl.BLEND:
          self.blend = false;break;
        case gl.SCISSOR_TEST:
          self.scissorTest = false;break;
        case gl.STENCIL_TEST:
          self.stencilTest = false;break;
      }
      self.realDisable.call(gl, pname);
    };

    this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
    gl.colorMask = function (r, g, b, a) {
      self.colorMask[0] = r;
      self.colorMask[1] = g;
      self.colorMask[2] = b;
      self.colorMask[3] = a;
      self.realColorMask.call(gl, r, g, b, a);
    };

    this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
    gl.clearColor = function (r, g, b, a) {
      self.clearColor[0] = r;
      self.clearColor[1] = g;
      self.clearColor[2] = b;
      self.clearColor[3] = a;
      self.realClearColor.call(gl, r, g, b, a);
    };

    this.viewport = gl.getParameter(gl.VIEWPORT);
    gl.viewport = function (x, y, w, h) {
      self.viewport[0] = x;
      self.viewport[1] = y;
      self.viewport[2] = w;
      self.viewport[3] = h;
      self.realViewport.call(gl, x, y, w, h);
    };

    this.isPatched = true;
    Util.safariCssSizeWorkaround(canvas);
  };

  CardboardDistorter.prototype.unpatch = function () {
    if (!this.isPatched) {
      return;
    }

    var gl = this.gl;
    var canvas = this.gl.canvas;

    if (!Util.isIOS()) {
      Object.defineProperty(canvas, 'width', this.realCanvasWidth);
      Object.defineProperty(canvas, 'height', this.realCanvasHeight);
    }
    canvas.width = this.bufferWidth;
    canvas.height = this.bufferHeight;

    gl.bindFramebuffer = this.realBindFramebuffer;
    gl.enable = this.realEnable;
    gl.disable = this.realDisable;
    gl.colorMask = this.realColorMask;
    gl.clearColor = this.realClearColor;
    gl.viewport = this.realViewport;

    // Check to see if our fake backbuffer is bound and bind the real backbuffer
    // if that's the case.
    if (this.lastBoundFramebuffer == this.framebuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    this.isPatched = false;

    setTimeout(function () {
      Util.safariCssSizeWorkaround(canvas);
    }, 1);
  };

  CardboardDistorter.prototype.setTextureBounds = function (leftBounds, rightBounds) {
    if (!leftBounds) {
      leftBounds = [0, 0, 0.5, 1];
    }

    if (!rightBounds) {
      rightBounds = [0.5, 0, 0.5, 1];
    }

    // Left eye
    this.viewportOffsetScale[0] = leftBounds[0]; // X
    this.viewportOffsetScale[1] = leftBounds[1]; // Y
    this.viewportOffsetScale[2] = leftBounds[2]; // Width
    this.viewportOffsetScale[3] = leftBounds[3]; // Height

    // Right eye
    this.viewportOffsetScale[4] = rightBounds[0]; // X
    this.viewportOffsetScale[5] = rightBounds[1]; // Y
    this.viewportOffsetScale[6] = rightBounds[2]; // Width
    this.viewportOffsetScale[7] = rightBounds[3]; // Height
  };

  /**
   * Performs distortion pass on the injected backbuffer, rendering it to the real
   * backbuffer.
   */
  CardboardDistorter.prototype.submitFrame = function () {
    var gl = this.gl;
    var self = this;

    var glState = [];

    if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
      glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0);
    }

    WGLUPreserveGLState(gl, glState, function (gl) {
      // Bind the real default framebuffer
      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

      // Make sure the GL state is in a good place
      if (self.cullFace) {
        self.realDisable.call(gl, gl.CULL_FACE);
      }
      if (self.depthTest) {
        self.realDisable.call(gl, gl.DEPTH_TEST);
      }
      if (self.blend) {
        self.realDisable.call(gl, gl.BLEND);
      }
      if (self.scissorTest) {
        self.realDisable.call(gl, gl.SCISSOR_TEST);
      }
      if (self.stencilTest) {
        self.realDisable.call(gl, gl.STENCIL_TEST);
      }
      self.realColorMask.call(gl, true, true, true, true);
      self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      // If the backbuffer has an alpha channel clear every frame so the page
      // doesn't show through.
      if (self.ctxAttribs.alpha || Util.isIOS()) {
        self.realClearColor.call(gl, 0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      // Bind distortion program and mesh
      gl.useProgram(self.program);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);

      gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
      gl.enableVertexAttribArray(self.attribs.position);
      gl.enableVertexAttribArray(self.attribs.texCoord);
      gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
      gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);

      gl.activeTexture(gl.TEXTURE0);
      gl.uniform1i(self.uniforms.diffuse, 0);
      gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);

      gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);

      // Draws both eyes
      gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);

      if (self.cardboardUI) {
        self.cardboardUI.renderNoState();
      }

      // Bind the fake default framebuffer again
      self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);

      // If preserveDrawingBuffer == false clear the framebuffer
      if (!self.ctxAttribs.preserveDrawingBuffer) {
        self.realClearColor.call(gl, 0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
        self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
      }

      // Restore state
      if (self.cullFace) {
        self.realEnable.call(gl, gl.CULL_FACE);
      }
      if (self.depthTest) {
        self.realEnable.call(gl, gl.DEPTH_TEST);
      }
      if (self.blend) {
        self.realEnable.call(gl, gl.BLEND);
      }
      if (self.scissorTest) {
        self.realEnable.call(gl, gl.SCISSOR_TEST);
      }
      if (self.stencilTest) {
        self.realEnable.call(gl, gl.STENCIL_TEST);
      }

      self.realColorMask.apply(gl, self.colorMask);
      self.realViewport.apply(gl, self.viewport);
      if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
        self.realClearColor.apply(gl, self.clearColor);
      }
    });

    // Workaround for the fact that Safari doesn't allow us to patch the canvas
    // width and height correctly. After each submit frame check to see what the
    // real backbuffer size has been set to and resize the fake backbuffer size
    // to match.
    if (Util.isIOS()) {
      var canvas = gl.canvas;
      if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
        self.bufferWidth = canvas.width;
        self.bufferHeight = canvas.height;
        self.onResize();
      }
    }
  };

  /**
   * Call when the deviceInfo has changed. At this point we need
   * to re-calculate the distortion mesh.
   */
  CardboardDistorter.prototype.updateDeviceInfo = function (deviceInfo) {
    var gl = this.gl;
    var self = this;

    var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
    WGLUPreserveGLState(gl, glState, function (gl) {
      var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
      gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // Indices don't change based on device parameters, so only compute once.
      if (!self.indexCount) {
        var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        self.indexCount = indices.length;
      }
    });
  };

  /**
   * Build the distortion mesh vertices.
   * Based on code from the Unity cardboard plugin.
   */
  CardboardDistorter.prototype.computeMeshVertices_ = function (width, height, deviceInfo) {
    var vertices = new Float32Array(2 * width * height * 5);

    var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
    var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
    var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
    var vidx = 0;
    var iidx = 0;
    for (var e = 0; e < 2; e++) {
      for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++, vidx++) {
          var u = i / (width - 1);
          var v = j / (height - 1);

          // Grid points regularly spaced in StreoScreen, and barrel distorted in
          // the mesh.
          var s = u;
          var t = v;
          var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
          var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
          var d = Math.sqrt(x * x + y * y);
          var r = deviceInfo.distortion.distortInverse(d);
          var p = x * r / d;
          var q = y * r / d;
          u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
          v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);

          // Convert u,v to mesh screen coordinates.
          var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;

          // FIXME: The original Unity plugin multiplied U by the aspect ratio
          // and didn't multiply either value by 2, but that seems to get it
          // really close to correct looking for me. I hate this kind of "Don't
          // know why it works" code though, and wold love a more logical
          // explanation of what needs to happen here.
          u = (viewport.x + u * viewport.width - 0.5) * 2.0; //* aspect;
          v = (viewport.y + v * viewport.height - 0.5) * 2.0;

          vertices[vidx * 5 + 0] = u; // position.x
          vertices[vidx * 5 + 1] = v; // position.y
          vertices[vidx * 5 + 2] = s; // texCoord.x
          vertices[vidx * 5 + 3] = t; // texCoord.y
          vertices[vidx * 5 + 4] = e; // texCoord.z (viewport index)
        }
      }
      var w = lensFrustum[2] - lensFrustum[0];
      lensFrustum[0] = -(w + lensFrustum[0]);
      lensFrustum[2] = w - lensFrustum[2];
      w = noLensFrustum[2] - noLensFrustum[0];
      noLensFrustum[0] = -(w + noLensFrustum[0]);
      noLensFrustum[2] = w - noLensFrustum[2];
      viewport.x = 1 - (viewport.x + viewport.width);
    }
    return vertices;
  };

  /**
   * Build the distortion mesh indices.
   * Based on code from the Unity cardboard plugin.
   */
  CardboardDistorter.prototype.computeMeshIndices_ = function (width, height) {
    var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
    var halfwidth = width / 2;
    var halfheight = height / 2;
    var vidx = 0;
    var iidx = 0;
    for (var e = 0; e < 2; e++) {
      for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++, vidx++) {
          if (i == 0 || j == 0) continue;
          // Build a quad.  Lower right and upper left quadrants have quads with
          // the triangle diagonal flipped to get the vignette to interpolate
          // correctly.
          if (i <= halfwidth == j <= halfheight) {
            // Quad diagonal lower left to upper right.
            indices[iidx++] = vidx;
            indices[iidx++] = vidx - width - 1;
            indices[iidx++] = vidx - width;
            indices[iidx++] = vidx - width - 1;
            indices[iidx++] = vidx;
            indices[iidx++] = vidx - 1;
          } else {
            // Quad diagonal upper left to lower right.
            indices[iidx++] = vidx - 1;
            indices[iidx++] = vidx - width;
            indices[iidx++] = vidx;
            indices[iidx++] = vidx - width;
            indices[iidx++] = vidx - 1;
            indices[iidx++] = vidx - width - 1;
          }
        }
      }
    }
    return indices;
  };

  CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function (proto, attrName) {
    var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
    // In some cases (ahem... Safari), the descriptor returns undefined get and
    // set fields. In this case, we need to create a synthetic property
    // descriptor. This works around some of the issues in
    // https://github.com/borismus/webvr-polyfill/issues/46
    if (descriptor.get === undefined || descriptor.set === undefined) {
      descriptor.configurable = true;
      descriptor.enumerable = true;
      descriptor.get = function () {
        return this.getAttribute(attrName);
      };
      descriptor.set = function (val) {
        this.setAttribute(attrName, val);
      };
    }
    return descriptor;
  };

  module.exports = CardboardDistorter;
  return module.exports;
});
$__System.registerDynamic("83", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
  Copyright (c) 2016, Brandon Jones.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  */

  /*
  Caches specified GL state, runs a callback, and restores the cached state when
  done.
  
  Example usage:
  
  var savedState = [
    gl.ARRAY_BUFFER_BINDING,
  
    // TEXTURE_BINDING_2D or _CUBE_MAP must always be followed by the texure unit.
    gl.TEXTURE_BINDING_2D, gl.TEXTURE0,
  
    gl.CLEAR_COLOR,
  ];
  // After this call the array buffer, texture unit 0, active texture, and clear
  // color will be restored. The viewport will remain changed, however, because
  // gl.VIEWPORT was not included in the savedState list.
  WGLUPreserveGLState(gl, savedState, function(gl) {
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, ....);
  
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, ...);
  
    gl.clearColor(1, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  });
  
  Note that this is not intended to be fast. Managing state in your own code to
  avoid redundant state setting and querying will always be faster. This function
  is most useful for cases where you may not have full control over the WebGL
  calls being made, such as tooling or effect injectors.
  */

  function WGLUPreserveGLState(gl, bindings, callback) {
    if (!bindings) {
      callback(gl);
      return;
    }

    var boundValues = [];

    var activeTexture = null;
    for (var i = 0; i < bindings.length; ++i) {
      var binding = bindings[i];
      switch (binding) {
        case gl.TEXTURE_BINDING_2D:
        case gl.TEXTURE_BINDING_CUBE_MAP:
          var textureUnit = bindings[++i];
          if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
            console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
            boundValues.push(null, null);
            break;
          }
          if (!activeTexture) {
            activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
          }
          gl.activeTexture(textureUnit);
          boundValues.push(gl.getParameter(binding), null);
          break;
        case gl.ACTIVE_TEXTURE:
          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
          boundValues.push(null);
          break;
        default:
          boundValues.push(gl.getParameter(binding));
          break;
      }
    }

    callback(gl);

    for (var i = 0; i < bindings.length; ++i) {
      var binding = bindings[i];
      var boundValue = boundValues[i];
      switch (binding) {
        case gl.ACTIVE_TEXTURE:
          break; // Ignore this binding, since we special-case it to happen last.
        case gl.ARRAY_BUFFER_BINDING:
          gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
          break;
        case gl.COLOR_CLEAR_VALUE:
          gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
          break;
        case gl.COLOR_WRITEMASK:
          gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
          break;
        case gl.CURRENT_PROGRAM:
          gl.useProgram(boundValue);
          break;
        case gl.ELEMENT_ARRAY_BUFFER_BINDING:
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
          break;
        case gl.FRAMEBUFFER_BINDING:
          gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
          break;
        case gl.RENDERBUFFER_BINDING:
          gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
          break;
        case gl.TEXTURE_BINDING_2D:
          var textureUnit = bindings[++i];
          if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) break;
          gl.activeTexture(textureUnit);
          gl.bindTexture(gl.TEXTURE_2D, boundValue);
          break;
        case gl.TEXTURE_BINDING_CUBE_MAP:
          var textureUnit = bindings[++i];
          if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) break;
          gl.activeTexture(textureUnit);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
          break;
        case gl.VIEWPORT:
          gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
          break;
        case gl.BLEND:
        case gl.CULL_FACE:
        case gl.DEPTH_TEST:
        case gl.SCISSOR_TEST:
        case gl.STENCIL_TEST:
          if (boundValue) {
            gl.enable(binding);
          } else {
            gl.disable(binding);
          }
          break;
        default:
          console.log("No GL restore behavior for 0x" + binding.toString(16));
          break;
      }

      if (activeTexture) {
        gl.activeTexture(activeTexture);
      }
    }
  }

  module.exports = WGLUPreserveGLState;
  return module.exports;
});
$__System.registerDynamic('81', ['82', '83'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Util = $__require('82');
  var WGLUPreserveGLState = $__require('83');

  var uiVS = ['attribute vec2 position;', 'uniform mat4 projectionMat;', 'void main() {', '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );', '}'].join('\n');

  var uiFS = ['precision mediump float;', 'uniform vec4 color;', 'void main() {', '  gl_FragColor = color;', '}'].join('\n');

  var DEG2RAD = Math.PI / 180.0;

  // The gear has 6 identical sections, each spanning 60 degrees.
  var kAnglePerGearSection = 60;

  // Half-angle of the span of the outer rim.
  var kOuterRimEndAngle = 12;

  // Angle between the middle of the outer rim and the start of the inner rim.
  var kInnerRimBeginAngle = 20;

  // Distance from center to outer rim, normalized so that the entire model
  // fits in a [-1, 1] x [-1, 1] square.
  var kOuterRadius = 1;

  // Distance from center to depressed rim, in model units.
  var kMiddleRadius = 0.75;

  // Radius of the inner hollow circle, in model units.
  var kInnerRadius = 0.3125;

  // Center line thickness in DP.
  var kCenterLineThicknessDp = 4;

  // Button width in DP.
  var kButtonWidthDp = 28;

  // Factor to scale the touch area that responds to the touch.
  var kTouchSlopFactor = 1.5;

  var Angles = [0, kOuterRimEndAngle, kInnerRimBeginAngle, kAnglePerGearSection - kInnerRimBeginAngle, kAnglePerGearSection - kOuterRimEndAngle];

  /**
   * Renders the alignment line and "options" gear. It is assumed that the canvas
   * this is rendered into covers the entire screen (or close to it.)
   */
  function CardboardUI(gl) {
    this.gl = gl;

    this.attribs = {
      position: 0
    };
    this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
    this.uniforms = Util.getProgramUniforms(gl, this.program);

    this.vertexBuffer = gl.createBuffer();
    this.gearOffset = 0;
    this.gearVertexCount = 0;
    this.arrowOffset = 0;
    this.arrowVertexCount = 0;

    this.projMat = new Float32Array(16);

    this.listener = null;

    this.onResize();
  };

  /**
   * Tears down all the resources created by the UI renderer.
   */
  CardboardUI.prototype.destroy = function () {
    var gl = this.gl;

    if (this.listener) {
      gl.canvas.removeEventListener('click', this.listener, false);
    }

    gl.deleteProgram(this.program);
    gl.deleteBuffer(this.vertexBuffer);
  };

  /**
   * Adds a listener to clicks on the gear and back icons
   */
  CardboardUI.prototype.listen = function (optionsCallback, backCallback) {
    var canvas = this.gl.canvas;
    this.listener = function (event) {
      var midline = canvas.clientWidth / 2;
      var buttonSize = kButtonWidthDp * kTouchSlopFactor;
      // Check to see if the user clicked on (or around) the gear icon
      if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
        optionsCallback(event);
      }
      // Check to see if the user clicked on (or around) the back icon
      else if (event.clientX < buttonSize && event.clientY < buttonSize) {
          backCallback(event);
        }
    };
    canvas.addEventListener('click', this.listener, false);
  };

  /**
   * Builds the UI mesh.
   */
  CardboardUI.prototype.onResize = function () {
    var gl = this.gl;
    var self = this;

    var glState = [gl.ARRAY_BUFFER_BINDING];

    WGLUPreserveGLState(gl, glState, function (gl) {
      var vertices = [];

      var midline = gl.drawingBufferWidth / 2;

      // Assumes your canvas width and height is scaled proportionately.
      // TODO(smus): The following causes buttons to become huge on iOS, but seems
      // like the right thing to do. For now, added a hack. But really, investigate why.
      var dps = gl.drawingBufferWidth / (screen.width * window.devicePixelRatio);
      if (!Util.isIOS()) {
        dps *= window.devicePixelRatio;
      }

      var lineWidth = kCenterLineThicknessDp * dps / 2;
      var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
      var buttonScale = kButtonWidthDp * dps / 2;
      var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;

      // Build centerline
      vertices.push(midline - lineWidth, buttonSize);
      vertices.push(midline - lineWidth, gl.drawingBufferHeight);
      vertices.push(midline + lineWidth, buttonSize);
      vertices.push(midline + lineWidth, gl.drawingBufferHeight);

      // Build gear
      self.gearOffset = vertices.length / 2;

      function addGearSegment(theta, r) {
        var angle = (90 - theta) * DEG2RAD;
        var x = Math.cos(angle);
        var y = Math.sin(angle);
        vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
        vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
      }

      for (var i = 0; i <= 6; i++) {
        var segmentTheta = i * kAnglePerGearSection;

        addGearSegment(segmentTheta, kOuterRadius);
        addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
        addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
        addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
        addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
      }

      self.gearVertexCount = vertices.length / 2 - self.gearOffset;

      // Build back arrow
      self.arrowOffset = vertices.length / 2;

      function addArrowVertex(x, y) {
        vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
      }

      var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);

      addArrowVertex(0, buttonScale);
      addArrowVertex(buttonScale, 0);
      addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
      addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);

      addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
      addArrowVertex(0, buttonScale);
      addArrowVertex(buttonScale, buttonScale * 2);
      addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);

      addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
      addArrowVertex(0, buttonScale);

      addArrowVertex(angledLineWidth, buttonScale - lineWidth);
      addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
      addArrowVertex(angledLineWidth, buttonScale + lineWidth);
      addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);

      self.arrowVertexCount = vertices.length / 2 - self.arrowOffset;

      // Buffer data
      gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    });
  };

  /**
   * Performs distortion pass on the injected backbuffer, rendering it to the real
   * backbuffer.
   */
  CardboardUI.prototype.render = function () {
    var gl = this.gl;
    var self = this;

    var glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];

    WGLUPreserveGLState(gl, glState, function (gl) {
      // Make sure the GL state is in a good place
      gl.disable(gl.CULL_FACE);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);
      gl.disable(gl.SCISSOR_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.colorMask(true, true, true, true);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      self.renderNoState();
    });
  };

  CardboardUI.prototype.renderNoState = function () {
    var gl = this.gl;

    // Bind distortion program and mesh
    gl.useProgram(this.program);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.enableVertexAttribArray(this.attribs.position);
    gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);

    gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);

    Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
    gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);

    // Draws UI element
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
    gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
  };

  module.exports = CardboardUI;
  return module.exports;
});
$__System.registerDynamic("84", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * DPDB cache.
   */
  var DPDB_CACHE = {
    "format": 1,
    "last_updated": "2016-01-20T00:18:35Z",
    "devices": [{
      "type": "android",
      "rules": [{ "mdmh": "asus/*/Nexus 7/*" }, { "ua": "Nexus 7" }],
      "dpi": [320.8, 323.0],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "asus/*/ASUS_Z00AD/*" }, { "ua": "ASUS_Z00AD" }],
      "dpi": [403.0, 404.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "HTC/*/HTC6435LVW/*" }, { "ua": "HTC6435LVW" }],
      "dpi": [449.7, 443.3],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "HTC/*/HTC One XL/*" }, { "ua": "HTC One XL" }],
      "dpi": [315.3, 314.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "htc/*/Nexus 9/*" }, { "ua": "Nexus 9" }],
      "dpi": 289.0,
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "HTC/*/HTC One M9/*" }, { "ua": "HTC One M9" }],
      "dpi": [442.5, 443.3],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "HTC/*/HTC One_M8/*" }, { "ua": "HTC One_M8" }],
      "dpi": [449.7, 447.4],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "HTC/*/HTC One/*" }, { "ua": "HTC One" }],
      "dpi": 472.8,
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Huawei/*/Nexus 6P/*" }, { "ua": "Nexus 6P" }],
      "dpi": [515.1, 518.0],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/Nexus 5X/*" }, { "ua": "Nexus 5X" }],
      "dpi": [422.0, 419.9],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LGMS345/*" }, { "ua": "LGMS345" }],
      "dpi": [221.7, 219.1],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LG-D800/*" }, { "ua": "LG-D800" }],
      "dpi": [422.0, 424.1],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LG-D850/*" }, { "ua": "LG-D850" }],
      "dpi": [537.9, 541.9],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/VS985 4G/*" }, { "ua": "VS985 4G" }],
      "dpi": [537.9, 535.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/Nexus 5/*" }, { "ua": "Nexus 5 " }],
      "dpi": [442.4, 444.8],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/Nexus 4/*" }, { "ua": "Nexus 4" }],
      "dpi": [319.8, 318.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LG-P769/*" }, { "ua": "LG-P769" }],
      "dpi": [240.6, 247.5],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LGMS323/*" }, { "ua": "LGMS323" }],
      "dpi": [206.6, 204.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "LGE/*/LGLS996/*" }, { "ua": "LGLS996" }],
      "dpi": [403.4, 401.5],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Micromax/*/4560MMX/*" }, { "ua": "4560MMX" }],
      "dpi": [240.0, 219.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Micromax/*/A250/*" }, { "ua": "Micromax A250" }],
      "dpi": [480.0, 446.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Micromax/*/Micromax AQ4501/*" }, { "ua": "Micromax AQ4501" }],
      "dpi": 240.0,
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/DROID RAZR/*" }, { "ua": "DROID RAZR" }],
      "dpi": [368.1, 256.7],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT830C/*" }, { "ua": "XT830C" }],
      "dpi": [254.0, 255.9],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1021/*" }, { "ua": "XT1021" }],
      "dpi": [254.0, 256.7],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1023/*" }, { "ua": "XT1023" }],
      "dpi": [254.0, 256.7],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1028/*" }, { "ua": "XT1028" }],
      "dpi": [326.6, 327.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1034/*" }, { "ua": "XT1034" }],
      "dpi": [326.6, 328.4],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1053/*" }, { "ua": "XT1053" }],
      "dpi": [315.3, 316.1],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1562/*" }, { "ua": "XT1562" }],
      "dpi": [403.4, 402.7],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/Nexus 6/*" }, { "ua": "Nexus 6 " }],
      "dpi": [494.3, 489.7],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1063/*" }, { "ua": "XT1063" }],
      "dpi": [295.0, 296.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1064/*" }, { "ua": "XT1064" }],
      "dpi": [295.0, 295.6],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1092/*" }, { "ua": "XT1092" }],
      "dpi": [422.0, 424.1],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "motorola/*/XT1095/*" }, { "ua": "XT1095" }],
      "dpi": [422.0, 423.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "OnePlus/*/A0001/*" }, { "ua": "A0001" }],
      "dpi": [403.4, 401.0],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "OnePlus/*/ONE E1005/*" }, { "ua": "ONE E1005" }],
      "dpi": [442.4, 441.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "OnePlus/*/ONE A2005/*" }, { "ua": "ONE A2005" }],
      "dpi": [391.9, 405.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "OPPO/*/X909/*" }, { "ua": "X909" }],
      "dpi": [442.4, 444.1],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9082/*" }, { "ua": "GT-I9082" }],
      "dpi": [184.7, 185.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G360P/*" }, { "ua": "SM-G360P" }],
      "dpi": [196.7, 205.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/Nexus S/*" }, { "ua": "Nexus S" }],
      "dpi": [234.5, 229.8],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }],
      "dpi": [304.8, 303.9],
      "bw": 5,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-T230NU/*" }, { "ua": "SM-T230NU" }],
      "dpi": 216.0,
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SGH-T399/*" }, { "ua": "SGH-T399" }],
      "dpi": [217.7, 231.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-N9005/*" }, { "ua": "SM-N9005" }],
      "dpi": [386.4, 387.0],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" }, { "ua": "SAMSUNG-SM-N900A" }],
      "dpi": [386.4, 387.7],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9500/*" }, { "ua": "GT-I9500" }],
      "dpi": [442.5, 443.3],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9505/*" }, { "ua": "GT-I9505" }],
      "dpi": 439.4,
      "bw": 4,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G900F/*" }, { "ua": "SM-G900F" }],
      "dpi": [415.6, 431.6],
      "bw": 5,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G900M/*" }, { "ua": "SM-G900M" }],
      "dpi": [415.6, 431.6],
      "bw": 5,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G800F/*" }, { "ua": "SM-G800F" }],
      "dpi": 326.8,
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G906S/*" }, { "ua": "SM-G906S" }],
      "dpi": [562.7, 572.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }],
      "dpi": [306.7, 304.8],
      "bw": 5,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-T535/*" }, { "ua": "SM-T535" }],
      "dpi": [142.6, 136.4],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-N920C/*" }, { "ua": "SM-N920C" }],
      "dpi": [515.1, 518.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9300I/*" }, { "ua": "GT-I9300I" }],
      "dpi": [304.8, 305.8],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-I9195/*" }, { "ua": "GT-I9195" }],
      "dpi": [249.4, 256.7],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SPH-L520/*" }, { "ua": "SPH-L520" }],
      "dpi": [249.4, 255.9],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" }, { "ua": "SAMSUNG-SGH-I717" }],
      "dpi": 285.8,
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SPH-D710/*" }, { "ua": "SPH-D710" }],
      "dpi": [217.7, 204.2],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/GT-N7100/*" }, { "ua": "GT-N7100" }],
      "dpi": 265.1,
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SCH-I605/*" }, { "ua": "SCH-I605" }],
      "dpi": 265.1,
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/Galaxy Nexus/*" }, { "ua": "Galaxy Nexus" }],
      "dpi": [315.3, 314.2],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-N910H/*" }, { "ua": "SM-N910H" }],
      "dpi": [515.1, 518.0],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-N910C/*" }, { "ua": "SM-N910C" }],
      "dpi": [515.2, 520.2],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G130M/*" }, { "ua": "SM-G130M" }],
      "dpi": [165.9, 164.8],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G928I/*" }, { "ua": "SM-G928I" }],
      "dpi": [515.1, 518.4],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G920F/*" }, { "ua": "SM-G920F" }],
      "dpi": 580.6,
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G920P/*" }, { "ua": "SM-G920P" }],
      "dpi": [522.5, 577.0],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G925F/*" }, { "ua": "SM-G925F" }],
      "dpi": 580.6,
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "samsung/*/SM-G925V/*" }, { "ua": "SM-G925V" }],
      "dpi": [522.5, 576.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Sony/*/C6903/*" }, { "ua": "C6903" }],
      "dpi": [442.5, 443.3],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Sony/*/D6653/*" }, { "ua": "D6653" }],
      "dpi": [428.6, 427.6],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Sony/*/E6653/*" }, { "ua": "E6653" }],
      "dpi": [428.6, 425.7],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Sony/*/E6853/*" }, { "ua": "E6853" }],
      "dpi": [403.4, 401.9],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "Sony/*/SGP321/*" }, { "ua": "SGP321" }],
      "dpi": [224.7, 224.1],
      "bw": 3,
      "ac": 500
    }, {
      "type": "android",
      "rules": [{ "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { "ua": "ALCATEL ONE TOUCH Fierce" }],
      "dpi": [240.0, 247.5],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "THL/*/thl 5000/*" }, { "ua": "thl 5000" }],
      "dpi": [480.0, 443.3],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "android",
      "rules": [{ "mdmh": "ZTE/*/ZTE Blade L2/*" }, { "ua": "ZTE Blade L2" }],
      "dpi": 240.0,
      "bw": 3,
      "ac": 500
    }, {
      "type": "ios",
      "rules": [{ "res": [640, 960] }],
      "dpi": [325.1, 328.4],
      "bw": 4,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [640, 960] }],
      "dpi": [325.1, 328.4],
      "bw": 4,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [640, 1136] }],
      "dpi": [317.1, 320.2],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [640, 1136] }],
      "dpi": [317.1, 320.2],
      "bw": 3,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [750, 1334] }],
      "dpi": 326.4,
      "bw": 4,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [750, 1334] }],
      "dpi": 326.4,
      "bw": 4,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [1242, 2208] }],
      "dpi": [453.6, 458.4],
      "bw": 4,
      "ac": 1000
    }, {
      "type": "ios",
      "rules": [{ "res": [1242, 2208] }],
      "dpi": [453.6, 458.4],
      "bw": 4,
      "ac": 1000
    }] };

  module.exports = DPDB_CACHE;
  return module.exports;
});
$__System.registerDynamic('85', ['84', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Offline cache of the DPDB, to be used until we load the online one (and
  // as a fallback in case we can't load the online one).
  var DPDB_CACHE = $__require('84');
  var Util = $__require('82');

  // Online DPDB URL.
  var ONLINE_DPDB_URL = 'https://storage.googleapis.com/cardboard-dpdb/dpdb.json';

  /**
   * Calculates device parameters based on the DPDB (Device Parameter Database).
   * Initially, uses the cached DPDB values.
   *
   * If fetchOnline == true, then this object tries to fetch the online version
   * of the DPDB and updates the device info if a better match is found.
   * Calls the onDeviceParamsUpdated callback when there is an update to the
   * device information.
   */
  function Dpdb(fetchOnline, onDeviceParamsUpdated) {
    // Start with the offline DPDB cache while we are loading the real one.
    this.dpdb = DPDB_CACHE;

    // Calculate device params based on the offline version of the DPDB.
    this.recalculateDeviceParams_();

    // XHR to fetch online DPDB file, if requested.
    if (fetchOnline) {
      // Set the callback.
      this.onDeviceParamsUpdated = onDeviceParamsUpdated;

      console.log('Fetching DPDB...');
      var xhr = new XMLHttpRequest();
      var obj = this;
      xhr.open('GET', ONLINE_DPDB_URL, true);
      xhr.addEventListener('load', function () {
        obj.loading = false;
        if (xhr.status >= 200 && xhr.status <= 299) {
          // Success.
          console.log('Successfully loaded online DPDB.');
          obj.dpdb = JSON.parse(xhr.response);
          obj.recalculateDeviceParams_();
        } else {
          // Error loading the DPDB.
          console.error('Error loading online DPDB!');
        }
      });
      xhr.send();
    }
  }

  // Returns the current device parameters.
  Dpdb.prototype.getDeviceParams = function () {
    return this.deviceParams;
  };

  // Recalculates this device's parameters based on the DPDB.
  Dpdb.prototype.recalculateDeviceParams_ = function () {
    console.log('Recalculating device params.');
    var newDeviceParams = this.calcDeviceParams_();
    console.log('New device parameters:');
    console.log(newDeviceParams);
    if (newDeviceParams) {
      this.deviceParams = newDeviceParams;
      // Invoke callback, if it is set.
      if (this.onDeviceParamsUpdated) {
        this.onDeviceParamsUpdated(this.deviceParams);
      }
    } else {
      console.error('Failed to recalculate device parameters.');
    }
  };

  // Returns a DeviceParams object that represents the best guess as to this
  // device's parameters. Can return null if the device does not match any
  // known devices.
  Dpdb.prototype.calcDeviceParams_ = function () {
    var db = this.dpdb; // shorthand
    if (!db) {
      console.error('DPDB not available.');
      return null;
    }
    if (db.format != 1) {
      console.error('DPDB has unexpected format version.');
      return null;
    }
    if (!db.devices || !db.devices.length) {
      console.error('DPDB does not have a devices section.');
      return null;
    }

    // Get the actual user agent and screen dimensions in pixels.
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;
    var width = Util.getScreenWidth();
    var height = Util.getScreenHeight();
    console.log('User agent: ' + userAgent);
    console.log('Pixel width: ' + width);
    console.log('Pixel height: ' + height);

    if (!db.devices) {
      console.error('DPDB has no devices section.');
      return null;
    }

    for (var i = 0; i < db.devices.length; i++) {
      var device = db.devices[i];
      if (!device.rules) {
        console.warn('Device[' + i + '] has no rules section.');
        continue;
      }

      if (device.type != 'ios' && device.type != 'android') {
        console.warn('Device[' + i + '] has invalid type.');
        continue;
      }

      // See if this device is of the appropriate type.
      if (Util.isIOS() != (device.type == 'ios')) continue;

      // See if this device matches any of the rules:
      var matched = false;
      for (var j = 0; j < device.rules.length; j++) {
        var rule = device.rules[j];
        if (this.matchRule_(rule, userAgent, width, height)) {
          console.log('Rule matched:');
          console.log(rule);
          matched = true;
          break;
        }
      }
      if (!matched) continue;

      // device.dpi might be an array of [ xdpi, ydpi] or just a scalar.
      var xdpi = device.dpi[0] || device.dpi;
      var ydpi = device.dpi[1] || device.dpi;

      return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
    }

    console.warn('No DPDB device match.');
    return null;
  };

  Dpdb.prototype.matchRule_ = function (rule, ua, screenWidth, screenHeight) {
    // We can only match 'ua' and 'res' rules, not other types like 'mdmh'
    // (which are meant for native platforms).
    if (!rule.ua && !rule.res) return false;

    // If our user agent string doesn't contain the indicated user agent string,
    // the match fails.
    if (rule.ua && ua.indexOf(rule.ua) < 0) return false;

    // If the rule specifies screen dimensions that don't correspond to ours,
    // the match fails.
    if (rule.res) {
      if (!rule.res[0] || !rule.res[1]) return false;
      var resX = rule.res[0];
      var resY = rule.res[1];
      // Compare min and max so as to make the order not matter, i.e., it should
      // be true that 640x480 == 480x640.
      if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
        return false;
      }
    }

    return true;
  };

  function DeviceParams(params) {
    this.xdpi = params.xdpi;
    this.ydpi = params.ydpi;
    this.bevelMm = params.bevelMm;
  }

  module.exports = Dpdb;
  return module.exports;
});
$__System.registerDynamic("86", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  function SensorSample(sample, timestampS) {
    this.set(sample, timestampS);
  };

  SensorSample.prototype.set = function (sample, timestampS) {
    this.sample = sample;
    this.timestampS = timestampS;
  };

  SensorSample.prototype.copy = function (sensorSample) {
    this.set(sensorSample.sample, sensorSample.timestampS);
  };

  module.exports = SensorSample;
  return module.exports;
});
$__System.registerDynamic('87', ['86', '88', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var SensorSample = $__require('86');
  var MathUtil = $__require('88');
  var Util = $__require('82');

  var DEBUG = false;

  /**
   * An implementation of a simple complementary filter, which fuses gyroscope and
   * accelerometer data from the 'devicemotion' event.
   *
   * Accelerometer data is very noisy, but stable over the long term.
   * Gyroscope data is smooth, but tends to drift over the long term.
   *
   * This fusion is relatively simple:
   * 1. Get orientation estimates from accelerometer by applying a low-pass filter
   *    on that data.
   * 2. Get orientation estimates from gyroscope by integrating over time.
   * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
   *    short term.
   */
  function ComplementaryFilter(kFilter) {
    this.kFilter = kFilter;

    // Raw sensor measurements.
    this.currentAccelMeasurement = new SensorSample();
    this.currentGyroMeasurement = new SensorSample();
    this.previousGyroMeasurement = new SensorSample();

    // Set default look direction to be in the correct direction.
    if (Util.isIOS()) {
      this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
    } else {
      this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
    }
    this.previousFilterQ = new MathUtil.Quaternion();
    this.previousFilterQ.copy(this.filterQ);

    // Orientation based on the accelerometer.
    this.accelQ = new MathUtil.Quaternion();
    // Whether or not the orientation has been initialized.
    this.isOrientationInitialized = false;
    // Running estimate of gravity based on the current orientation.
    this.estimatedGravity = new MathUtil.Vector3();
    // Measured gravity based on accelerometer.
    this.measuredGravity = new MathUtil.Vector3();

    // Debug only quaternion of gyro-based orientation.
    this.gyroIntegralQ = new MathUtil.Quaternion();
  }

  ComplementaryFilter.prototype.addAccelMeasurement = function (vector, timestampS) {
    this.currentAccelMeasurement.set(vector, timestampS);
  };

  ComplementaryFilter.prototype.addGyroMeasurement = function (vector, timestampS) {
    this.currentGyroMeasurement.set(vector, timestampS);

    var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
    if (Util.isTimestampDeltaValid(deltaT)) {
      this.run_();
    }

    this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
  };

  ComplementaryFilter.prototype.run_ = function () {

    if (!this.isOrientationInitialized) {
      this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
      this.previousFilterQ.copy(this.accelQ);
      this.isOrientationInitialized = true;
      return;
    }

    var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;

    // Convert gyro rotation vector to a quaternion delta.
    var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
    this.gyroIntegralQ.multiply(gyroDeltaQ);

    // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
    this.filterQ.copy(this.previousFilterQ);
    this.filterQ.multiply(gyroDeltaQ);

    // Calculate the delta between the current estimated gravity and the real
    // gravity vector from accelerometer.
    var invFilterQ = new MathUtil.Quaternion();
    invFilterQ.copy(this.filterQ);
    invFilterQ.inverse();

    this.estimatedGravity.set(0, 0, -1);
    this.estimatedGravity.applyQuaternion(invFilterQ);
    this.estimatedGravity.normalize();

    this.measuredGravity.copy(this.currentAccelMeasurement.sample);
    this.measuredGravity.normalize();

    // Compare estimated gravity with measured gravity, get the delta quaternion
    // between the two.
    var deltaQ = new MathUtil.Quaternion();
    deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
    deltaQ.inverse();

    if (DEBUG) {
      console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)', MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
    }

    // Calculate the SLERP target: current orientation plus the measured-estimated
    // quaternion delta.
    var targetQ = new MathUtil.Quaternion();
    targetQ.copy(this.filterQ);
    targetQ.multiply(deltaQ);

    // SLERP factor: 0 is pure gyro, 1 is pure accel.
    this.filterQ.slerp(targetQ, 1 - this.kFilter);

    this.previousFilterQ.copy(this.filterQ);
  };

  ComplementaryFilter.prototype.getOrientation = function () {
    return this.filterQ;
  };

  ComplementaryFilter.prototype.accelToQuaternion_ = function (accel) {
    var normAccel = new MathUtil.Vector3();
    normAccel.copy(accel);
    normAccel.normalize();
    var quat = new MathUtil.Quaternion();
    quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
    quat.inverse();
    return quat;
  };

  ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function (gyro, dt) {
    // Extract axis and angle from the gyroscope data.
    var quat = new MathUtil.Quaternion();
    var axis = new MathUtil.Vector3();
    axis.copy(gyro);
    axis.normalize();
    quat.setFromAxisAngle(axis, gyro.length() * dt);
    return quat;
  };

  module.exports = ComplementaryFilter;
  return module.exports;
});
$__System.registerDynamic('89', ['88'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MathUtil = $__require('88');
  var DEBUG = false;

  /**
   * Given an orientation and the gyroscope data, predicts the future orientation
   * of the head. This makes rendering appear faster.
   *
   * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
   *
   * @param {Number} predictionTimeS time from head movement to the appearance of
   * the corresponding image.
   */
  function PosePredictor(predictionTimeS) {
    this.predictionTimeS = predictionTimeS;

    // The quaternion corresponding to the previous state.
    this.previousQ = new MathUtil.Quaternion();
    // Previous time a prediction occurred.
    this.previousTimestampS = null;

    // The delta quaternion that adjusts the current pose.
    this.deltaQ = new MathUtil.Quaternion();
    // The output quaternion.
    this.outQ = new MathUtil.Quaternion();
  }

  PosePredictor.prototype.getPrediction = function (currentQ, gyro, timestampS) {
    if (!this.previousTimestampS) {
      this.previousQ.copy(currentQ);
      this.previousTimestampS = timestampS;
      return currentQ;
    }

    // Calculate axis and angle based on gyroscope rotation rate data.
    var axis = new MathUtil.Vector3();
    axis.copy(gyro);
    axis.normalize();

    var angularSpeed = gyro.length();

    // If we're rotating slowly, don't do prediction.
    if (angularSpeed < MathUtil.degToRad * 20) {
      if (DEBUG) {
        console.log('Moving slowly, at %s deg/s: no prediction', (MathUtil.radToDeg * angularSpeed).toFixed(1));
      }
      this.outQ.copy(currentQ);
      this.previousQ.copy(currentQ);
      return this.outQ;
    }

    // Get the predicted angle based on the time delta and latency.
    var deltaT = timestampS - this.previousTimestampS;
    var predictAngle = angularSpeed * this.predictionTimeS;

    this.deltaQ.setFromAxisAngle(axis, predictAngle);
    this.outQ.copy(this.previousQ);
    this.outQ.multiply(this.deltaQ);

    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;

    return this.outQ;
  };

  module.exports = PosePredictor;
  return module.exports;
});
$__System.registerDynamic('8a', ['88', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MathUtil = $__require('88');
  var Util = $__require('82');

  var ROTATE_SPEED = 0.5;
  /**
   * Provides a quaternion responsible for pre-panning the scene before further
   * transformations due to device sensors.
   */
  function TouchPanner() {
    window.addEventListener('touchstart', this.onTouchStart_.bind(this));
    window.addEventListener('touchmove', this.onTouchMove_.bind(this));
    window.addEventListener('touchend', this.onTouchEnd_.bind(this));

    this.isTouching = false;
    this.rotateStart = new MathUtil.Vector2();
    this.rotateEnd = new MathUtil.Vector2();
    this.rotateDelta = new MathUtil.Vector2();

    this.theta = 0;
    this.orientation = new MathUtil.Quaternion();
  }

  TouchPanner.prototype.getOrientation = function () {
    this.orientation.setFromEulerXYZ(0, 0, this.theta);
    return this.orientation;
  };

  TouchPanner.prototype.resetSensor = function () {
    this.theta = 0;
  };

  TouchPanner.prototype.onTouchStart_ = function (e) {
    // Only respond if there is exactly one touch.
    if (e.touches.length != 1) {
      return;
    }
    this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
    this.isTouching = true;
  };

  TouchPanner.prototype.onTouchMove_ = function (e) {
    if (!this.isTouching) {
      return;
    }
    this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
    this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
    this.rotateStart.copy(this.rotateEnd);

    // On iOS, direction is inverted.
    if (Util.isIOS()) {
      this.rotateDelta.x *= -1;
    }

    var element = document.body;
    this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
  };

  TouchPanner.prototype.onTouchEnd_ = function (e) {
    this.isTouching = false;
  };

  module.exports = TouchPanner;
  return module.exports;
});
$__System.registerDynamic('8b', ['87', '89', '8a', '88', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ComplementaryFilter = $__require('87');
  var PosePredictor = $__require('89');
  var TouchPanner = $__require('8a');
  var MathUtil = $__require('88');
  var Util = $__require('82');

  /**
   * The pose sensor, implemented using DeviceMotion APIs.
   */
  function FusionPoseSensor() {
    this.deviceId = 'webvr-polyfill:fused';
    this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

    this.accelerometer = new MathUtil.Vector3();
    this.gyroscope = new MathUtil.Vector3();

    window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
    window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));

    this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER);
    this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S);
    this.touchPanner = new TouchPanner();

    this.filterToWorldQ = new MathUtil.Quaternion();

    // Set the filter to world transform, depending on OS.
    if (Util.isIOS()) {
      this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
    } else {
      this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
    }

    this.inverseWorldToScreenQ = new MathUtil.Quaternion();
    this.worldToScreenQ = new MathUtil.Quaternion();
    this.originalPoseAdjustQ = new MathUtil.Quaternion();
    this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -window.orientation * Math.PI / 180);

    this.setScreenTransform_();
    // Adjust this filter for being in landscape mode.
    if (Util.isLandscapeMode()) {
      this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
    }

    // Keep track of a reset transform for resetSensor.
    this.resetQ = new MathUtil.Quaternion();

    this.isFirefoxAndroid = Util.isFirefoxAndroid();
    this.isIOS = Util.isIOS();

    this.orientationOut_ = new Float32Array(4);
  }

  FusionPoseSensor.prototype.getPosition = function () {
    // This PoseSensor doesn't support position
    return null;
  };

  FusionPoseSensor.prototype.getOrientation = function () {
    // Convert from filter space to the the same system used by the
    // deviceorientation event.
    var orientation = this.filter.getOrientation();

    // Predict orientation.
    this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

    // Convert to THREE coordinate system: -Z forward, Y up, X right.
    var out = new MathUtil.Quaternion();
    out.copy(this.filterToWorldQ);
    out.multiply(this.resetQ);
    if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
      out.multiply(this.touchPanner.getOrientation());
    }
    out.multiply(this.predictedQ);
    out.multiply(this.worldToScreenQ);

    // Handle the yaw-only case.
    if (WebVRConfig.YAW_ONLY) {
      // Make a quaternion that only turns around the Y-axis.
      out.x = 0;
      out.z = 0;
      out.normalize();
    }

    this.orientationOut_[0] = out.x;
    this.orientationOut_[1] = out.y;
    this.orientationOut_[2] = out.z;
    this.orientationOut_[3] = out.w;
    return this.orientationOut_;
  };

  FusionPoseSensor.prototype.resetPose = function () {
    // Reduce to inverted yaw-only.
    this.resetQ.copy(this.filter.getOrientation());
    this.resetQ.x = 0;
    this.resetQ.y = 0;
    this.resetQ.z *= -1;
    this.resetQ.normalize();

    // Take into account extra transformations in landscape mode.
    if (Util.isLandscapeMode()) {
      this.resetQ.multiply(this.inverseWorldToScreenQ);
    }

    // Take into account original pose.
    this.resetQ.multiply(this.originalPoseAdjustQ);

    if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
      this.touchPanner.resetSensor();
    }
  };

  FusionPoseSensor.prototype.onDeviceMotionChange_ = function (deviceMotion) {
    var accGravity = deviceMotion.accelerationIncludingGravity;
    var rotRate = deviceMotion.rotationRate;
    var timestampS = deviceMotion.timeStamp / 1000;

    // Firefox Android timeStamp returns one thousandth of a millisecond.
    if (this.isFirefoxAndroid) {
      timestampS /= 1000;
    }

    var deltaS = timestampS - this.previousTimestampS;
    if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
      console.warn('Invalid timestamps detected. Time step between successive ' + 'gyroscope sensor samples is very small or not monotonic');
      this.previousTimestampS = timestampS;
      return;
    }
    this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
    this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

    // With iOS and Firefox Android, rotationRate is reported in degrees,
    // so we first convert to radians.
    if (this.isIOS || this.isFirefoxAndroid) {
      this.gyroscope.multiplyScalar(Math.PI / 180);
    }

    this.filter.addAccelMeasurement(this.accelerometer, timestampS);
    this.filter.addGyroMeasurement(this.gyroscope, timestampS);

    this.previousTimestampS = timestampS;
  };

  FusionPoseSensor.prototype.onScreenOrientationChange_ = function (screenOrientation) {
    this.setScreenTransform_();
  };

  FusionPoseSensor.prototype.setScreenTransform_ = function () {
    this.worldToScreenQ.set(0, 0, 0, 1);
    switch (window.orientation) {
      case 0:
        break;
      case 90:
        this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
        break;
      case -90:
        this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
        break;
      case 180:
        // TODO.
        break;
    }
    this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
    this.inverseWorldToScreenQ.inverse();
  };

  module.exports = FusionPoseSensor;
  return module.exports;
});
$__System.registerDynamic('8c', ['82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Util = $__require('82');

  function RotateInstructions() {
    this.loadIcon_();

    var overlay = document.createElement('div');
    var s = overlay.style;
    s.position = 'fixed';
    s.top = 0;
    s.right = 0;
    s.bottom = 0;
    s.left = 0;
    s.backgroundColor = 'gray';
    s.fontFamily = 'sans-serif';
    // Force this to be above the fullscreen canvas, which is at zIndex: 999999.
    s.zIndex = 1000000;

    var img = document.createElement('img');
    img.src = this.icon;
    var s = img.style;
    s.marginLeft = '25%';
    s.marginTop = '25%';
    s.width = '50%';
    overlay.appendChild(img);

    var text = document.createElement('div');
    var s = text.style;
    s.textAlign = 'center';
    s.fontSize = '16px';
    s.lineHeight = '24px';
    s.margin = '24px 25%';
    s.width = '50%';
    text.innerHTML = 'Place your phone into your Cardboard viewer.';
    overlay.appendChild(text);

    var snackbar = document.createElement('div');
    var s = snackbar.style;
    s.backgroundColor = '#CFD8DC';
    s.position = 'fixed';
    s.bottom = 0;
    s.width = '100%';
    s.height = '48px';
    s.padding = '14px 24px';
    s.boxSizing = 'border-box';
    s.color = '#656A6B';
    overlay.appendChild(snackbar);

    var snackbarText = document.createElement('div');
    snackbarText.style.float = 'left';
    snackbarText.innerHTML = 'No Cardboard viewer?';

    var snackbarButton = document.createElement('a');
    snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
    snackbarButton.innerHTML = 'get one';
    snackbarButton.target = '_blank';
    var s = snackbarButton.style;
    s.float = 'right';
    s.fontWeight = 600;
    s.textTransform = 'uppercase';
    s.borderLeft = '1px solid gray';
    s.paddingLeft = '24px';
    s.textDecoration = 'none';
    s.color = '#656A6B';

    snackbar.appendChild(snackbarText);
    snackbar.appendChild(snackbarButton);

    this.overlay = overlay;
    this.text = text;

    this.hide();
  }

  RotateInstructions.prototype.show = function (parent) {
    if (!parent && !this.overlay.parentElement) {
      document.body.appendChild(this.overlay);
    } else if (parent) {
      if (this.overlay.parentElement && this.overlay.parentElement != parent) this.overlay.parentElement.removeChild(this.overlay);

      parent.appendChild(this.overlay);
    }

    this.overlay.style.display = 'block';

    var img = this.overlay.querySelector('img');
    var s = img.style;

    if (Util.isLandscapeMode()) {
      s.width = '20%';
      s.marginLeft = '40%';
      s.marginTop = '3%';
    } else {
      s.width = '50%';
      s.marginLeft = '25%';
      s.marginTop = '25%';
    }
  };

  RotateInstructions.prototype.hide = function () {
    this.overlay.style.display = 'none';
  };

  RotateInstructions.prototype.showTemporarily = function (ms, parent) {
    this.show(parent);
    this.timer = setTimeout(this.hide.bind(this), ms);
  };

  RotateInstructions.prototype.disableShowTemporarily = function () {
    clearTimeout(this.timer);
  };

  RotateInstructions.prototype.update = function () {
    this.disableShowTemporarily();
    // In portrait VR mode, tell the user to rotate to landscape. Otherwise, hide
    // the instructions.
    if (!Util.isLandscapeMode() && Util.isMobile()) {
      this.show();
    } else {
      this.hide();
    }
  };

  RotateInstructions.prototype.loadIcon_ = function () {
    // Encoded asset_src/rotate-instructions.svg
    this.icon = Util.base64('image/svg+xml', 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');
  };

  module.exports = RotateInstructions;
  return module.exports;
});
$__System.registerDynamic("8d", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  function Emitter() {
    this.callbacks = {};
  }

  Emitter.prototype.emit = function (eventName) {
    var callbacks = this.callbacks[eventName];
    if (!callbacks) {
      //console.log('No valid callback specified.');
      return;
    }
    var args = [].slice.call(arguments);
    // Eliminate the first param (the callback).
    args.shift();
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i].apply(this, args);
    }
  };

  Emitter.prototype.on = function (eventName, callback) {
    if (eventName in this.callbacks) {
      this.callbacks[eventName].push(callback);
    } else {
      this.callbacks[eventName] = [callback];
    }
  };

  module.exports = Emitter;
  return module.exports;
});
$__System.registerDynamic("8e", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * TODO(smus): Implement coefficient inversion.
   */
  function Distortion(coefficients) {
    this.coefficients = coefficients;
  }

  /**
   * Calculates the inverse distortion for a radius.
   * </p><p>
   * Allows to compute the original undistorted radius from a distorted one.
   * See also getApproximateInverseDistortion() for a faster but potentially
   * less accurate method.
   *
   * @param {Number} radius Distorted radius from the lens center in tan-angle units.
   * @return {Number} The undistorted radius in tan-angle units.
   */
  Distortion.prototype.distortInverse = function (radius) {
    // Secant method.
    var r0 = 0;
    var r1 = 1;
    var dr0 = radius - this.distort(r0);
    while (Math.abs(r1 - r0) > 0.0001 /** 0.1mm */) {
      var dr1 = radius - this.distort(r1);
      var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
      r0 = r1;
      r1 = r2;
      dr0 = dr1;
    }
    return r1;
  };

  /**
   * Distorts a radius by its distortion factor from the center of the lenses.
   *
   * @param {Number} radius Radius from the lens center in tan-angle units.
   * @return {Number} The distorted radius in tan-angle units.
   */
  Distortion.prototype.distort = function (radius) {
    var r2 = radius * radius;
    var ret = 0;
    for (var i = 0; i < this.coefficients.length; i++) {
      ret = r2 * (ret + this.coefficients[i]);
    }
    return (ret + 1) * radius;
  };

  // Functions below roughly ported from
  // https://github.com/googlesamples/cardboard-unity/blob/master/Cardboard/Scripts/CardboardProfile.cs#L412

  // Solves a small linear equation via destructive gaussian
  // elimination and back substitution.  This isn't generic numeric
  // code, it's just a quick hack to work with the generally
  // well-behaved symmetric matrices for least-squares fitting.
  // Not intended for reuse.
  //
  // @param a Input positive definite symmetrical matrix. Destroyed
  //     during calculation.
  // @param y Input right-hand-side values. Destroyed during calculation.
  // @return Resulting x value vector.
  //
  Distortion.prototype.solveLinear_ = function (a, y) {
    var n = a.length;

    // Gaussian elimination (no row exchange) to triangular matrix.
    // The input matrix is a A^T A product which should be a positive
    // definite symmetrical matrix, and if I remember my linear
    // algebra right this implies that the pivots will be nonzero and
    // calculations sufficiently accurate without needing row
    // exchange.
    for (var j = 0; j < n - 1; ++j) {
      for (var k = j + 1; k < n; ++k) {
        var p = a[j][k] / a[j][j];
        for (var i = j + 1; i < n; ++i) {
          a[i][k] -= p * a[i][j];
        }
        y[k] -= p * y[j];
      }
    }
    // From this point on, only the matrix elements a[j][i] with i>=j are
    // valid. The elimination doesn't fill in eliminated 0 values.

    var x = new Array(n);

    // Back substitution.
    for (var j = n - 1; j >= 0; --j) {
      var v = y[j];
      for (var i = j + 1; i < n; ++i) {
        v -= a[i][j] * x[i];
      }
      x[j] = v / a[j][j];
    }

    return x;
  };

  // Solves a least-squares matrix equation.  Given the equation A * x = y, calculate the
  // least-square fit x = inverse(A * transpose(A)) * transpose(A) * y.  The way this works
  // is that, while A is typically not a square matrix (and hence not invertible), A * transpose(A)
  // is always square.  That is:
  //   A * x = y
  //   transpose(A) * (A * x) = transpose(A) * y   <- multiply both sides by transpose(A)
  //   (transpose(A) * A) * x = transpose(A) * y   <- associativity
  //   x = inverse(transpose(A) * A) * transpose(A) * y  <- solve for x
  // Matrix A's row count (first index) must match y's value count.  A's column count (second index)
  // determines the length of the result vector x.
  Distortion.prototype.solveLeastSquares_ = function (matA, vecY) {
    var i, j, k, sum;
    var numSamples = matA.length;
    var numCoefficients = matA[0].length;
    if (numSamples != vecY.Length) {
      throw new Error("Matrix / vector dimension mismatch");
    }

    // Calculate transpose(A) * A
    var matATA = new Array(numCoefficients);
    for (k = 0; k < numCoefficients; ++k) {
      matATA[k] = new Array(numCoefficients);
      for (j = 0; j < numCoefficients; ++j) {
        sum = 0;
        for (i = 0; i < numSamples; ++i) {
          sum += matA[j][i] * matA[k][i];
        }
        matATA[k][j] = sum;
      }
    }

    // Calculate transpose(A) * y
    var vecATY = new Array(numCoefficients);
    for (j = 0; j < numCoefficients; ++j) {
      sum = 0;
      for (i = 0; i < numSamples; ++i) {
        sum += matA[j][i] * vecY[i];
      }
      vecATY[j] = sum;
    }

    // Now solve (A * transpose(A)) * x = transpose(A) * y.
    return this.solveLinear_(matATA, vecATY);
  };

  /// Calculates an approximate inverse to the given radial distortion parameters.
  Distortion.prototype.approximateInverse = function (maxRadius, numSamples) {
    maxRadius = maxRadius || 1;
    numSamples = numSamples || 100;
    var numCoefficients = 6;
    var i, j;

    // R + K1*R^3 + K2*R^5 = r, with R = rp = distort(r)
    // Repeating for numSamples:
    //   [ R0^3, R0^5 ] * [ K1 ] = [ r0 - R0 ]
    //   [ R1^3, R1^5 ]   [ K2 ]   [ r1 - R1 ]
    //   [ R2^3, R2^5 ]            [ r2 - R2 ]
    //   [ etc... ]                [ etc... ]
    // That is:
    //   matA * [K1, K2] = y
    // Solve:
    //   [K1, K2] = inverse(transpose(matA) * matA) * transpose(matA) * y
    var matA = new Array(numCoefficients);
    for (j = 0; j < numCoefficients; ++j) {
      matA[j] = new Array(numSamples);
    }
    var vecY = new Array(numSamples);

    for (i = 0; i < numSamples; ++i) {
      var r = maxRadius * (i + 1) / numSamples;
      var rp = this.distort(r);
      var v = rp;
      for (j = 0; j < numCoefficients; ++j) {
        v *= rp * rp;
        matA[j][i] = v;
      }
      vecY[i] = r - rp;
    }

    var inverseCoefficients = this.solveLeastSquares_(matA, vecY);

    return new Distortion(inverseCoefficients);
  };

  module.exports = Distortion;
  return module.exports;
});
$__System.registerDynamic('8f', ['8e', '88', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Distortion = $__require('8e');
  var MathUtil = $__require('88');
  var Util = $__require('82');

  function Device(params) {
    this.width = params.width || Util.getScreenWidth();
    this.height = params.height || Util.getScreenHeight();
    this.widthMeters = params.widthMeters;
    this.heightMeters = params.heightMeters;
    this.bevelMeters = params.bevelMeters;
  }

  // Fallback Android device (based on Nexus 5 measurements) for use when
  // we can't recognize an Android device.
  var DEFAULT_ANDROID = new Device({
    widthMeters: 0.110,
    heightMeters: 0.062,
    bevelMeters: 0.004
  });

  // Fallback iOS device (based on iPhone6) for use when
  // we can't recognize an Android device.
  var DEFAULT_IOS = new Device({
    widthMeters: 0.1038,
    heightMeters: 0.0584,
    bevelMeters: 0.004
  });

  var Viewers = {
    CardboardV1: new CardboardViewer({
      id: 'CardboardV1',
      label: 'Cardboard I/O 2014',
      fov: 40,
      interLensDistance: 0.060,
      baselineLensDistance: 0.035,
      screenLensDistance: 0.042,
      distortionCoefficients: [0.441, 0.156],
      inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 0.001559834]
    }),
    CardboardV2: new CardboardViewer({
      id: 'CardboardV2',
      label: 'Cardboard I/O 2015',
      fov: 60,
      interLensDistance: 0.064,
      baselineLensDistance: 0.035,
      screenLensDistance: 0.039,
      distortionCoefficients: [0.34, 0.55],
      inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956, -9.904169E-4, 6.183535E-5, -1.6981803E-6]
    })
  };

  var DEFAULT_LEFT_CENTER = { x: 0.5, y: 0.5 };
  var DEFAULT_RIGHT_CENTER = { x: 0.5, y: 0.5 };

  /**
   * Manages information about the device and the viewer.
   *
   * deviceParams indicates the parameters of the device to use (generally
   * obtained from dpdb.getDeviceParams()). Can be null to mean no device
   * params were found.
   */
  function DeviceInfo(deviceParams) {
    this.viewer = Viewers.CardboardV2;
    this.updateDeviceParams(deviceParams);
    this.distortion = new Distortion(this.viewer.distortionCoefficients);
  }

  DeviceInfo.prototype.updateDeviceParams = function (deviceParams) {
    this.device = this.determineDevice_(deviceParams) || this.device;
  };

  DeviceInfo.prototype.getDevice = function () {
    return this.device;
  };

  DeviceInfo.prototype.setViewer = function (viewer) {
    this.viewer = viewer;
    this.distortion = new Distortion(this.viewer.distortionCoefficients);
  };

  DeviceInfo.prototype.determineDevice_ = function (deviceParams) {
    if (!deviceParams) {
      // No parameters, so use a default.
      if (Util.isIOS()) {
        console.warn('Using fallback iOS device measurements.');
        return DEFAULT_IOS;
      } else {
        console.warn('Using fallback Android device measurements.');
        return DEFAULT_ANDROID;
      }
    }

    // Compute device screen dimensions based on deviceParams.
    var METERS_PER_INCH = 0.0254;
    var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
    var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
    var width = Util.getScreenWidth();
    var height = Util.getScreenHeight();
    return new Device({
      widthMeters: metersPerPixelX * width,
      heightMeters: metersPerPixelY * height,
      bevelMeters: deviceParams.bevelMm * 0.001
    });
  };

  /**
   * Calculates field of view for the left eye.
   */
  DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function () {
    var viewer = this.viewer;
    var device = this.device;
    var distortion = this.distortion;

    // Device.height and device.width for device in portrait mode, so transpose.
    var eyeToScreenDistance = viewer.screenLensDistance;

    var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
    var innerDist = viewer.interLensDistance / 2;
    var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
    var topDist = device.heightMeters - bottomDist;

    var outerAngle = MathUtil.radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
    var innerAngle = MathUtil.radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
    var bottomAngle = MathUtil.radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
    var topAngle = MathUtil.radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));

    return {
      leftDegrees: Math.min(outerAngle, viewer.fov),
      rightDegrees: Math.min(innerAngle, viewer.fov),
      downDegrees: Math.min(bottomAngle, viewer.fov),
      upDegrees: Math.min(topAngle, viewer.fov)
    };
  };

  /**
   * Calculates the tan-angles from the maximum FOV for the left eye for the
   * current device and screen parameters.
   */
  DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function () {
    var viewer = this.viewer;
    var device = this.device;
    var distortion = this.distortion;

    // Tan-angles from the max FOV.
    var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
    var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
    var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
    var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
    // Viewport size.
    var halfWidth = device.widthMeters / 4;
    var halfHeight = device.heightMeters / 2;
    // Viewport center, measured from left lens position.
    var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
    var centerX = viewer.interLensDistance / 2 - halfWidth;
    var centerY = -verticalLensOffset;
    var centerZ = viewer.screenLensDistance;
    // Tan-angles of the viewport edges, as seen through the lens.
    var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
    var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
    var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
    var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
    // Compare the two sets of tan-angles and take the value closer to zero on each side.
    var result = new Float32Array(4);
    result[0] = Math.max(fovLeft, screenLeft);
    result[1] = Math.min(fovTop, screenTop);
    result[2] = Math.min(fovRight, screenRight);
    result[3] = Math.max(fovBottom, screenBottom);
    return result;
  };

  /**
   * Calculates the tan-angles from the maximum FOV for the left eye for the
   * current device and screen parameters, assuming no lenses.
   */
  DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function () {
    var viewer = this.viewer;
    var device = this.device;
    var distortion = this.distortion;

    var result = new Float32Array(4);
    // Tan-angles from the max FOV.
    var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
    var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
    var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
    var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
    // Viewport size.
    var halfWidth = device.widthMeters / 4;
    var halfHeight = device.heightMeters / 2;
    // Viewport center, measured from left lens position.
    var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
    var centerX = viewer.interLensDistance / 2 - halfWidth;
    var centerY = -verticalLensOffset;
    var centerZ = viewer.screenLensDistance;
    // Tan-angles of the viewport edges, as seen through the lens.
    var screenLeft = (centerX - halfWidth) / centerZ;
    var screenTop = (centerY + halfHeight) / centerZ;
    var screenRight = (centerX + halfWidth) / centerZ;
    var screenBottom = (centerY - halfHeight) / centerZ;
    // Compare the two sets of tan-angles and take the value closer to zero on each side.
    result[0] = Math.max(fovLeft, screenLeft);
    result[1] = Math.min(fovTop, screenTop);
    result[2] = Math.min(fovRight, screenRight);
    result[3] = Math.max(fovBottom, screenBottom);
    return result;
  };

  /**
   * Calculates the screen rectangle visible from the left eye for the
   * current device and screen parameters.
   */
  DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function (undistortedFrustum) {
    var viewer = this.viewer;
    var device = this.device;

    var dist = viewer.screenLensDistance;
    var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
    var eyeY = viewer.baselineLensDistance - device.bevelMeters;
    var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
    var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
    var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
    var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
    return {
      x: left,
      y: bottom,
      width: right - left,
      height: top - bottom
    };
  };

  DeviceInfo.prototype.getFieldOfViewLeftEye = function (opt_isUndistorted) {
    return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
  };

  DeviceInfo.prototype.getFieldOfViewRightEye = function (opt_isUndistorted) {
    var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
    return {
      leftDegrees: fov.rightDegrees,
      rightDegrees: fov.leftDegrees,
      upDegrees: fov.upDegrees,
      downDegrees: fov.downDegrees
    };
  };

  /**
   * Calculates undistorted field of view for the left eye.
   */
  DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function () {
    var p = this.getUndistortedParams_();

    return {
      leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
      rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
      downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
      upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
    };
  };

  DeviceInfo.prototype.getUndistortedViewportLeftEye = function () {
    var p = this.getUndistortedParams_();
    var viewer = this.viewer;
    var device = this.device;

    // Distances stored in local variables are in tan-angle units unless otherwise
    // noted.
    var eyeToScreenDistance = viewer.screenLensDistance;
    var screenWidth = device.widthMeters / eyeToScreenDistance;
    var screenHeight = device.heightMeters / eyeToScreenDistance;
    var xPxPerTanAngle = device.width / screenWidth;
    var yPxPerTanAngle = device.height / screenHeight;

    var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
    var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
    return {
      x: x,
      y: y,
      width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
      height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
    };
  };

  DeviceInfo.prototype.getUndistortedParams_ = function () {
    var viewer = this.viewer;
    var device = this.device;
    var distortion = this.distortion;

    // Most of these variables in tan-angle units.
    var eyeToScreenDistance = viewer.screenLensDistance;
    var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
    var screenWidth = device.widthMeters / eyeToScreenDistance;
    var screenHeight = device.heightMeters / eyeToScreenDistance;

    var eyePosX = screenWidth / 2 - halfLensDistance;
    var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;

    var maxFov = viewer.fov;
    var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
    var outerDist = Math.min(eyePosX, viewerMax);
    var innerDist = Math.min(halfLensDistance, viewerMax);
    var bottomDist = Math.min(eyePosY, viewerMax);
    var topDist = Math.min(screenHeight - eyePosY, viewerMax);

    return {
      outerDist: outerDist,
      innerDist: innerDist,
      topDist: topDist,
      bottomDist: bottomDist,
      eyePosX: eyePosX,
      eyePosY: eyePosY
    };
  };

  function CardboardViewer(params) {
    // A machine readable ID.
    this.id = params.id;
    // A human readable label.
    this.label = params.label;

    // Field of view in degrees (per side).
    this.fov = params.fov;

    // Distance between lens centers in meters.
    this.interLensDistance = params.interLensDistance;
    // Distance between viewer baseline and lens center in meters.
    this.baselineLensDistance = params.baselineLensDistance;
    // Screen-to-lens distance in meters.
    this.screenLensDistance = params.screenLensDistance;

    // Distortion coefficients.
    this.distortionCoefficients = params.distortionCoefficients;
    // Inverse distortion coefficients.
    // TODO: Calculate these from distortionCoefficients in the future.
    this.inverseCoefficients = params.inverseCoefficients;
  }

  // Export viewer information.
  DeviceInfo.Viewers = Viewers;
  module.exports = DeviceInfo;
  return module.exports;
});
$__System.registerDynamic('90', ['8d', '82', '8f'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Emitter = $__require('8d');
  var Util = $__require('82');
  var DeviceInfo = $__require('8f');

  var DEFAULT_VIEWER = 'CardboardV1';
  var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
  var CLASS_NAME = 'webvr-polyfill-viewer-selector';

  /**
   * Creates a viewer selector with the options specified. Supports being shown
   * and hidden. Generates events when viewer parameters change. Also supports
   * saving the currently selected index in localStorage.
   */
  function ViewerSelector() {
    // Try to load the selected key from local storage. If none exists, use the
    // default key.
    try {
      this.selectedKey = localStorage.getItem(VIEWER_KEY) || DEFAULT_VIEWER;
    } catch (error) {
      console.error('Failed to load viewer profile: %s', error);
    }
    this.dialog = this.createDialog_(DeviceInfo.Viewers);
    this.root = null;
  }
  ViewerSelector.prototype = new Emitter();

  ViewerSelector.prototype.show = function (root) {
    this.root = root;

    root.appendChild(this.dialog);
    //console.log('ViewerSelector.show');

    // Ensure the currently selected item is checked.
    var selected = this.dialog.querySelector('#' + this.selectedKey);
    selected.checked = true;

    // Show the UI.
    this.dialog.style.display = 'block';
  };

  ViewerSelector.prototype.hide = function () {
    if (this.root && this.root.contains(this.dialog)) {
      this.root.removeChild(this.dialog);
    }
    //console.log('ViewerSelector.hide');
    this.dialog.style.display = 'none';
  };

  ViewerSelector.prototype.getCurrentViewer = function () {
    return DeviceInfo.Viewers[this.selectedKey];
  };

  ViewerSelector.prototype.getSelectedKey_ = function () {
    var input = this.dialog.querySelector('input[name=field]:checked');
    if (input) {
      return input.id;
    }
    return null;
  };

  ViewerSelector.prototype.onSave_ = function () {
    this.selectedKey = this.getSelectedKey_();
    if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
      console.error('ViewerSelector.onSave_: this should never happen!');
      return;
    }

    this.emit('change', DeviceInfo.Viewers[this.selectedKey]);

    // Attempt to save the viewer profile, but fails in private mode.
    try {
      localStorage.setItem(VIEWER_KEY, this.selectedKey);
    } catch (error) {
      console.error('Failed to save viewer profile: %s', error);
    }
    this.hide();
  };

  /**
   * Creates the dialog.
   */
  ViewerSelector.prototype.createDialog_ = function (options) {
    var container = document.createElement('div');
    container.classList.add(CLASS_NAME);
    container.style.display = 'none';
    // Create an overlay that dims the background, and which goes away when you
    // tap it.
    var overlay = document.createElement('div');
    var s = overlay.style;
    s.position = 'fixed';
    s.left = 0;
    s.top = 0;
    s.width = '100%';
    s.height = '100%';
    s.background = 'rgba(0, 0, 0, 0.3)';
    overlay.addEventListener('click', this.hide.bind(this));

    var width = 280;
    var dialog = document.createElement('div');
    var s = dialog.style;
    s.boxSizing = 'border-box';
    s.position = 'fixed';
    s.top = '24px';
    s.left = '50%';
    s.marginLeft = -width / 2 + 'px';
    s.width = width + 'px';
    s.padding = '24px';
    s.overflow = 'hidden';
    s.background = '#fafafa';
    s.fontFamily = "'Roboto', sans-serif";
    s.boxShadow = '0px 5px 20px #666';

    dialog.appendChild(this.createH1_('Select your viewer'));
    for (var id in options) {
      dialog.appendChild(this.createChoice_(id, options[id].label));
    }
    dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));

    container.appendChild(overlay);
    container.appendChild(dialog);

    return container;
  };

  ViewerSelector.prototype.createH1_ = function (name) {
    var h1 = document.createElement('h1');
    var s = h1.style;
    s.color = 'black';
    s.fontSize = '20px';
    s.fontWeight = 'bold';
    s.marginTop = 0;
    s.marginBottom = '24px';
    h1.innerHTML = name;
    return h1;
  };

  ViewerSelector.prototype.createChoice_ = function (id, name) {
    /*
    <div class="choice">
    <input id="v1" type="radio" name="field" value="v1">
    <label for="v1">Cardboard V1</label>
    </div>
    */
    var div = document.createElement('div');
    div.style.marginTop = '8px';
    div.style.color = 'black';

    var input = document.createElement('input');
    input.style.fontSize = '30px';
    input.setAttribute('id', id);
    input.setAttribute('type', 'radio');
    input.setAttribute('value', id);
    input.setAttribute('name', 'field');

    var label = document.createElement('label');
    label.style.marginLeft = '4px';
    label.setAttribute('for', id);
    label.innerHTML = name;

    div.appendChild(input);
    div.appendChild(label);

    return div;
  };

  ViewerSelector.prototype.createButton_ = function (label, onclick) {
    var button = document.createElement('button');
    button.innerHTML = label;
    var s = button.style;
    s.float = 'right';
    s.textTransform = 'uppercase';
    s.color = '#1094f7';
    s.fontSize = '14px';
    s.letterSpacing = 0;
    s.border = 0;
    s.background = 'none';
    s.marginTop = '16px';

    button.addEventListener('click', onclick);

    return button;
  };

  module.exports = ViewerSelector;
  return module.exports;
});
$__System.registerDynamic('91', ['80', '81', '8f', '85', '8b', '8c', '90', '92', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var CardboardDistorter = $__require('80');
  var CardboardUI = $__require('81');
  var DeviceInfo = $__require('8f');
  var Dpdb = $__require('85');
  var FusionPoseSensor = $__require('8b');
  var RotateInstructions = $__require('8c');
  var ViewerSelector = $__require('90');
  var VRDisplay = $__require('92').VRDisplay;
  var Util = $__require('82');

  var Eye = {
    LEFT: 'left',
    RIGHT: 'right'
  };

  /**
   * VRDisplay based on mobile device parameters and DeviceMotion APIs.
   */
  function CardboardVRDisplay() {
    this.displayName = 'Cardboard VRDisplay (webvr-polyfill)';

    this.capabilities.hasOrientation = true;
    this.capabilities.canPresent = true;

    // "Private" members.
    this.bufferScale_ = WebVRConfig.BUFFER_SCALE;
    this.poseSensor_ = new FusionPoseSensor();
    this.distorter_ = null;
    this.cardboardUI_ = null;

    this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
    this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());

    this.viewerSelector_ = new ViewerSelector();
    this.viewerSelector_.on('change', this.onViewerChanged_.bind(this));

    // Set the correct initial viewer.
    this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());

    if (!WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
      this.rotateInstructions_ = new RotateInstructions();
    }

    if (Util.isIOS()) {
      // Listen for resize events to workaround this awful Safari bug.
      window.addEventListener('resize', this.onResize_.bind(this));
    }
  }
  CardboardVRDisplay.prototype = new VRDisplay();

  CardboardVRDisplay.prototype.getImmediatePose = function () {
    return {
      position: this.poseSensor_.getPosition(),
      orientation: this.poseSensor_.getOrientation(),
      linearVelocity: null,
      linearAcceleration: null,
      angularVelocity: null,
      angularAcceleration: null
    };
  };

  CardboardVRDisplay.prototype.resetPose = function () {
    this.poseSensor_.resetPose();
  };

  CardboardVRDisplay.prototype.getEyeParameters = function (whichEye) {
    var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
    var fieldOfView;

    // TODO: FoV can be a little expensive to compute. Cache when device params change.
    if (whichEye == Eye.LEFT) {
      offset[0] *= -1.0;
      fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
    } else if (whichEye == Eye.RIGHT) {
      fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
    } else {
      console.error('Invalid eye provided: %s', whichEye);
      return null;
    }

    return {
      fieldOfView: fieldOfView,
      offset: offset,
      // TODO: Should be able to provide better values than these.
      renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
      renderHeight: this.deviceInfo_.device.height * this.bufferScale_
    };
  };

  CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function (newParams) {
    console.log('DPDB reported that device params were updated.');
    this.deviceInfo_.updateDeviceParams(newParams);

    if (this.distorter_) {
      this.distorter_.updateDeviceInfo(this.deviceInfo_);
    }
  };

  CardboardVRDisplay.prototype.updateBounds_ = function () {
    if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
      this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
    }
  };

  CardboardVRDisplay.prototype.beginPresent_ = function () {
    var gl = this.layer_.source.getContext('webgl');
    if (!gl) gl = this.layer_.source.getContext('experimental-webgl');
    if (!gl) gl = this.layer_.source.getContext('webgl2');

    if (!gl) return; // Can't do distortion without a WebGL context.

    // Provides a way to opt out of distortion
    if (this.layer_.predistorted) {
      if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
        gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
        gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
        this.cardboardUI_ = new CardboardUI(gl);
      }
    } else {
      // Create a new distorter for the target context
      this.distorter_ = new CardboardDistorter(gl);
      this.distorter_.updateDeviceInfo(this.deviceInfo_);
      this.cardboardUI_ = this.distorter_.cardboardUI;
    }

    if (this.cardboardUI_) {
      this.cardboardUI_.listen(function (e) {
        // Options clicked.
        this.viewerSelector_.show(this.layer_.source.parentElement);
        e.stopPropagation();
        e.preventDefault();
      }.bind(this), function (e) {
        // Back clicked.
        this.exitPresent();
        e.stopPropagation();
        e.preventDefault();
      }.bind(this));
    }

    if (this.rotateInstructions_) {
      if (Util.isLandscapeMode() && Util.isMobile()) {
        // In landscape mode, temporarily show the "put into Cardboard"
        // interstitial. Otherwise, do the default thing.
        this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
      } else {
        this.rotateInstructions_.update();
      }
    }

    // Listen for orientation change events in order to show interstitial.
    this.orientationHandler = this.onOrientationChange_.bind(this);
    window.addEventListener('orientationchange', this.orientationHandler);

    // Listen for present display change events in order to update distorter dimensions
    this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
    window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);

    // Fire this event initially, to give geometry-distortion clients the chance
    // to do something custom.
    this.fireVRDisplayDeviceParamsChange_();
  };

  CardboardVRDisplay.prototype.endPresent_ = function () {
    if (this.distorter_) {
      this.distorter_.destroy();
      this.distorter_ = null;
    }
    if (this.cardboardUI_) {
      this.cardboardUI_.destroy();
      this.cardboardUI_ = null;
    }

    if (this.rotateInstructions_) {
      this.rotateInstructions_.hide();
    }
    this.viewerSelector_.hide();

    window.removeEventListener('orientationchange', this.orientationHandler);
    window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
  };

  CardboardVRDisplay.prototype.submitFrame = function (pose) {
    if (this.distorter_) {
      this.distorter_.submitFrame();
    } else if (this.cardboardUI_ && this.layer_) {
      // Hack for predistorted: true.
      var canvas = this.layer_.source.getContext('webgl').canvas;
      if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
        this.cardboardUI_.onResize();
      }
      this.lastWidth = canvas.width;
      this.lastHeight = canvas.height;

      // Render the Cardboard UI.
      this.cardboardUI_.render();
    }
  };

  CardboardVRDisplay.prototype.onOrientationChange_ = function (e) {
    console.log('onOrientationChange_');

    // Hide the viewer selector.
    this.viewerSelector_.hide();

    // Update the rotate instructions.
    if (this.rotateInstructions_) {
      this.rotateInstructions_.update();
    }

    this.onResize_();
  };

  CardboardVRDisplay.prototype.onResize_ = function (e) {
    if (this.layer_) {
      var gl = this.layer_.source.getContext('webgl');
      // Size the CSS canvas.
      // Added padding on right and bottom because iPhone 5 will not
      // hide the URL bar unless content is bigger than the screen.
      // This will not be visible as long as the container element (e.g. body)
      // is set to 'overflow: hidden'.
      var cssProperties = ['position: absolute', 'top: 0', 'left: 0', 'width: ' + Math.max(screen.width, screen.height) + 'px', 'height: ' + Math.min(screen.height, screen.width) + 'px', 'border: 0', 'margin: 0', 'padding: 0 10px 10px 0'];
      gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');

      Util.safariCssSizeWorkaround(gl.canvas);
    }
  };

  CardboardVRDisplay.prototype.onViewerChanged_ = function (viewer) {
    this.deviceInfo_.setViewer(viewer);

    if (this.distorter_) {
      // Update the distortion appropriately.
      this.distorter_.updateDeviceInfo(this.deviceInfo_);
    }

    // Fire a new event containing viewer and device parameters for clients that
    // want to implement their own geometry-based distortion.
    this.fireVRDisplayDeviceParamsChange_();
  };

  CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function () {
    var event = new CustomEvent('vrdisplaydeviceparamschange', {
      detail: {
        vrdisplay: this,
        deviceInfo: this.deviceInfo_
      }
    });
    window.dispatchEvent(event);
  };

  module.exports = CardboardVRDisplay;
  return module.exports;
});
$__System.registerDynamic("88", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MathUtil = window.MathUtil || {};

  MathUtil.degToRad = Math.PI / 180;
  MathUtil.radToDeg = 180 / Math.PI;

  // Some minimal math functionality borrowed from THREE.Math and stripped down
  // for the purposes of this library.


  MathUtil.Vector2 = function (x, y) {
    this.x = x || 0;
    this.y = y || 0;
  };

  MathUtil.Vector2.prototype = {
    constructor: MathUtil.Vector2,

    set: function (x, y) {
      this.x = x;
      this.y = y;

      return this;
    },

    copy: function (v) {
      this.x = v.x;
      this.y = v.y;

      return this;
    },

    subVectors: function (a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;

      return this;
    }
  };

  MathUtil.Vector3 = function (x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  };

  MathUtil.Vector3.prototype = {
    constructor: MathUtil.Vector3,

    set: function (x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;

      return this;
    },

    copy: function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;

      return this;
    },

    length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },

    normalize: function () {
      var scalar = this.length();

      if (scalar !== 0) {
        var invScalar = 1 / scalar;

        this.multiplyScalar(invScalar);
      } else {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      }

      return this;
    },

    multiplyScalar: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
    },

    applyQuaternion: function (q) {
      var x = this.x;
      var y = this.y;
      var z = this.z;

      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w;

      // calculate quat * vector
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;

      // calculate result * inverse quat
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return this;
    },

    dot: function (v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },

    crossVectors: function (a, b) {
      var ax = a.x,
          ay = a.y,
          az = a.z;
      var bx = b.x,
          by = b.y,
          bz = b.z;

      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;

      return this;
    }
  };

  MathUtil.Quaternion = function (x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
  };

  MathUtil.Quaternion.prototype = {
    constructor: MathUtil.Quaternion,

    set: function (x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;

      return this;
    },

    copy: function (quaternion) {
      this.x = quaternion.x;
      this.y = quaternion.y;
      this.z = quaternion.z;
      this.w = quaternion.w;

      return this;
    },

    setFromEulerXYZ: function (x, y, z) {
      var c1 = Math.cos(x / 2);
      var c2 = Math.cos(y / 2);
      var c3 = Math.cos(z / 2);
      var s1 = Math.sin(x / 2);
      var s2 = Math.sin(y / 2);
      var s3 = Math.sin(z / 2);

      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;

      return this;
    },

    setFromEulerYXZ: function (x, y, z) {
      var c1 = Math.cos(x / 2);
      var c2 = Math.cos(y / 2);
      var c3 = Math.cos(z / 2);
      var s1 = Math.sin(x / 2);
      var s2 = Math.sin(y / 2);
      var s3 = Math.sin(z / 2);

      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;

      return this;
    },

    setFromAxisAngle: function (axis, angle) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
      // assumes axis is normalized

      var halfAngle = angle / 2,
          s = Math.sin(halfAngle);

      this.x = axis.x * s;
      this.y = axis.y * s;
      this.z = axis.z * s;
      this.w = Math.cos(halfAngle);

      return this;
    },

    multiply: function (q) {
      return this.multiplyQuaternions(this, q);
    },

    multiplyQuaternions: function (a, b) {
      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

      var qax = a.x,
          qay = a.y,
          qaz = a.z,
          qaw = a.w;
      var qbx = b.x,
          qby = b.y,
          qbz = b.z,
          qbw = b.w;

      this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

      return this;
    },

    inverse: function () {
      this.x *= -1;
      this.y *= -1;
      this.z *= -1;

      this.normalize();

      return this;
    },

    normalize: function () {
      var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

      if (l === 0) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 1;
      } else {
        l = 1 / l;

        this.x = this.x * l;
        this.y = this.y * l;
        this.z = this.z * l;
        this.w = this.w * l;
      }

      return this;
    },

    slerp: function (qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);

      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;

      // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

      if (cosHalfTheta < 0) {
        this.w = -qb.w;
        this.x = -qb.x;
        this.y = -qb.y;
        this.z = -qb.z;

        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }

      if (cosHalfTheta >= 1.0) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;

        return this;
      }

      var halfTheta = Math.acos(cosHalfTheta);
      var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

      if (Math.abs(sinHalfTheta) < 0.001) {
        this.w = 0.5 * (w + this.w);
        this.x = 0.5 * (x + this.x);
        this.y = 0.5 * (y + this.y);
        this.z = 0.5 * (z + this.z);

        return this;
      }

      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

      this.w = w * ratioA + this.w * ratioB;
      this.x = x * ratioA + this.x * ratioB;
      this.y = y * ratioA + this.y * ratioB;
      this.z = z * ratioA + this.z * ratioB;

      return this;
    },

    setFromUnitVectors: function () {
      // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
      // assumes direction vectors vFrom and vTo are normalized

      var v1, r;
      var EPS = 0.000001;

      return function (vFrom, vTo) {
        if (v1 === undefined) v1 = new MathUtil.Vector3();

        r = vFrom.dot(vTo) + 1;

        if (r < EPS) {
          r = 0;

          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            v1.set(-vFrom.y, vFrom.x, 0);
          } else {
            v1.set(0, -vFrom.z, vFrom.y);
          }
        } else {
          v1.crossVectors(vFrom, vTo);
        }

        this.x = v1.x;
        this.y = v1.y;
        this.z = v1.z;
        this.w = r;

        this.normalize();

        return this;
      };
    }()
  };

  module.exports = MathUtil;
  return module.exports;
});
$__System.registerDynamic('93', ['92', '88', '82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var VRDisplay = $__require('92').VRDisplay;
  var MathUtil = $__require('88');
  var Util = $__require('82');

  // How much to rotate per key stroke.
  var KEY_SPEED = 0.15;
  var KEY_ANIMATION_DURATION = 80;

  // How much to rotate for mouse events.
  var MOUSE_SPEED_X = 0.5;
  var MOUSE_SPEED_Y = 0.3;

  /**
   * VRDisplay based on mouse and keyboard input. Designed for desktops/laptops
   * where orientation events aren't supported. Cannot present.
   */
  function MouseKeyboardVRDisplay() {
    this.displayName = 'Mouse and Keyboard VRDisplay (webvr-polyfill)';

    this.capabilities.hasOrientation = true;

    // Attach to mouse and keyboard events.
    window.addEventListener('keydown', this.onKeyDown_.bind(this));
    window.addEventListener('mousemove', this.onMouseMove_.bind(this));
    window.addEventListener('mousedown', this.onMouseDown_.bind(this));
    window.addEventListener('mouseup', this.onMouseUp_.bind(this));

    // "Private" members.
    this.phi_ = 0;
    this.theta_ = 0;

    // Variables for keyboard-based rotation animation.
    this.targetAngle_ = null;
    this.angleAnimation_ = null;

    // State variables for calculations.
    this.orientation_ = new MathUtil.Quaternion();

    // Variables for mouse-based rotation.
    this.rotateStart_ = new MathUtil.Vector2();
    this.rotateEnd_ = new MathUtil.Vector2();
    this.rotateDelta_ = new MathUtil.Vector2();
    this.isDragging_ = false;

    this.orientationOut_ = new Float32Array(4);
  }
  MouseKeyboardVRDisplay.prototype = new VRDisplay();

  MouseKeyboardVRDisplay.prototype.getImmediatePose = function () {
    this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);

    this.orientationOut_[0] = this.orientation_.x;
    this.orientationOut_[1] = this.orientation_.y;
    this.orientationOut_[2] = this.orientation_.z;
    this.orientationOut_[3] = this.orientation_.w;

    return {
      position: null,
      orientation: this.orientationOut_,
      linearVelocity: null,
      linearAcceleration: null,
      angularVelocity: null,
      angularAcceleration: null
    };
  };

  MouseKeyboardVRDisplay.prototype.onKeyDown_ = function (e) {
    // Track WASD and arrow keys.
    if (e.keyCode == 38) {
      // Up key.
      this.animatePhi_(this.phi_ + KEY_SPEED);
    } else if (e.keyCode == 39) {
      // Right key.
      this.animateTheta_(this.theta_ - KEY_SPEED);
    } else if (e.keyCode == 40) {
      // Down key.
      this.animatePhi_(this.phi_ - KEY_SPEED);
    } else if (e.keyCode == 37) {
      // Left key.
      this.animateTheta_(this.theta_ + KEY_SPEED);
    }
  };

  MouseKeyboardVRDisplay.prototype.animateTheta_ = function (targetAngle) {
    this.animateKeyTransitions_('theta_', targetAngle);
  };

  MouseKeyboardVRDisplay.prototype.animatePhi_ = function (targetAngle) {
    // Prevent looking too far up or down.
    targetAngle = Util.clamp(targetAngle, -Math.PI / 2, Math.PI / 2);
    this.animateKeyTransitions_('phi_', targetAngle);
  };

  /**
   * Start an animation to transition an angle from one value to another.
   */
  MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function (angleName, targetAngle) {
    // If an animation is currently running, cancel it.
    if (this.angleAnimation_) {
      cancelAnimationFrame(this.angleAnimation_);
    }
    var startAngle = this[angleName];
    var startTime = new Date();
    // Set up an interval timer to perform the animation.
    this.angleAnimation_ = requestAnimationFrame(function animate() {
      // Once we're finished the animation, we're done.
      var elapsed = new Date() - startTime;
      if (elapsed >= KEY_ANIMATION_DURATION) {
        this[angleName] = targetAngle;
        cancelAnimationFrame(this.angleAnimation_);
        return;
      }
      // loop with requestAnimationFrame
      this.angleAnimation_ = requestAnimationFrame(animate.bind(this));
      // Linearly interpolate the angle some amount.
      var percent = elapsed / KEY_ANIMATION_DURATION;
      this[angleName] = startAngle + (targetAngle - startAngle) * percent;
    }.bind(this));
  };

  MouseKeyboardVRDisplay.prototype.onMouseDown_ = function (e) {
    this.rotateStart_.set(e.clientX, e.clientY);
    this.isDragging_ = true;
  };

  // Very similar to https://gist.github.com/mrflix/8351020
  MouseKeyboardVRDisplay.prototype.onMouseMove_ = function (e) {
    if (!this.isDragging_ && !this.isPointerLocked_()) {
      return;
    }
    // Support pointer lock API.
    if (this.isPointerLocked_()) {
      var movementX = e.movementX || e.mozMovementX || 0;
      var movementY = e.movementY || e.mozMovementY || 0;
      this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
    } else {
      this.rotateEnd_.set(e.clientX, e.clientY);
    }
    // Calculate how much we moved in mouse space.
    this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
    this.rotateStart_.copy(this.rotateEnd_);

    // Keep track of the cumulative euler angles.
    this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
    this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;

    // Prevent looking too far up or down.
    this.phi_ = Util.clamp(this.phi_, -Math.PI / 2, Math.PI / 2);
  };

  MouseKeyboardVRDisplay.prototype.onMouseUp_ = function (e) {
    this.isDragging_ = false;
  };

  MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function () {
    var el = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
    return el !== undefined;
  };

  MouseKeyboardVRDisplay.prototype.resetPose = function () {
    this.phi_ = 0;
    this.theta_ = 0;
  };

  module.exports = MouseKeyboardVRDisplay;
  return module.exports;
});
$__System.registerDynamic('94', [], true, function ($__require, exports, module) {
	'use strict';
	/* eslint-disable no-unused-vars */

	var define,
	    global = this || self,
	    GLOBAL = global;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return module.exports;
});
$__System.registerDynamic('82', ['94'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var objectAssign = $__require('94');

  var Util = window.Util || {};

  Util.MIN_TIMESTEP = 0.001;
  Util.MAX_TIMESTEP = 1;

  Util.base64 = function (mimeType, base64) {
    return 'data:' + mimeType + ';base64,' + base64;
  };

  Util.clamp = function (value, min, max) {
    return Math.min(Math.max(min, value), max);
  };

  Util.lerp = function (a, b, t) {
    return a + (b - a) * t;
  };

  Util.isIOS = function () {
    var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
    return function () {
      return isIOS;
    };
  }();

  Util.isSafari = function () {
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return function () {
      return isSafari;
    };
  }();

  Util.isFirefoxAndroid = function () {
    var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
    return function () {
      return isFirefoxAndroid;
    };
  }();

  Util.isLandscapeMode = function () {
    return window.orientation == 90 || window.orientation == -90;
  };

  // Helper method to validate the time steps of sensor timestamps.
  Util.isTimestampDeltaValid = function (timestampDeltaS) {
    if (isNaN(timestampDeltaS)) {
      return false;
    }
    if (timestampDeltaS <= Util.MIN_TIMESTEP) {
      return false;
    }
    if (timestampDeltaS > Util.MAX_TIMESTEP) {
      return false;
    }
    return true;
  };

  Util.getScreenWidth = function () {
    return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
  };

  Util.getScreenHeight = function () {
    return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
  };

  Util.requestFullscreen = function (element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    } else {
      return false;
    }

    return true;
  };

  Util.exitFullscreen = function () {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else {
      return false;
    }

    return true;
  };

  Util.getFullscreenElement = function () {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  };

  Util.linkProgram = function (gl, vertexSource, fragmentSource, attribLocationMap) {
    // No error checking for brevity.
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    for (var attribName in attribLocationMap) gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

    gl.linkProgram(program);

    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);

    return program;
  };

  Util.getProgramUniforms = function (gl, program) {
    var uniforms = {};
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    var uniformName = '';
    for (var i = 0; i < uniformCount; i++) {
      var uniformInfo = gl.getActiveUniform(program, i);
      uniformName = uniformInfo.name.replace('[0]', '');
      uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
    }
    return uniforms;
  };

  Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  Util.isMobile = function () {
    var check = false;
    (function (a) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return check;
  };

  Util.extend = objectAssign;

  Util.safariCssSizeWorkaround = function (canvas) {
    // TODO(smus): Remove this workaround when Safari for iOS is fixed.
    // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
    //
    // "To the last I grapple with thee;
    //  from hell's heart I stab at thee;
    //  for hate's sake I spit my last breath at thee."
    // -- Moby Dick, by Herman Melville
    if (Util.isIOS()) {
      var width = canvas.style.width;
      var height = canvas.style.height;
      canvas.style.width = parseInt(width) + 1 + 'px';
      canvas.style.height = parseInt(height) + 'px';
      console.log('Resetting width to...', width);
      setTimeout(function () {
        console.log('Done. Width is now', width);
        canvas.style.width = width;
        canvas.style.height = height;
      }, 100);
    }

    // Debug only.
    window.Util = Util;
    window.canvas = canvas;
  };

  Util.frameDataFromPose = function () {
    var piOver180 = Math.PI / 180.0;
    var rad45 = Math.PI * 0.25;

    // Borrowed from glMatrix.
    function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
      var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45),
          downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45),
          leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45),
          rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45),
          xScale = 2.0 / (leftTan + rightTan),
          yScale = 2.0 / (upTan + downTan);

      out[0] = xScale;
      out[1] = 0.0;
      out[2] = 0.0;
      out[3] = 0.0;
      out[4] = 0.0;
      out[5] = yScale;
      out[6] = 0.0;
      out[7] = 0.0;
      out[8] = -((leftTan - rightTan) * xScale * 0.5);
      out[9] = (upTan - downTan) * yScale * 0.5;
      out[10] = far / (near - far);
      out[11] = -1.0;
      out[12] = 0.0;
      out[13] = 0.0;
      out[14] = far * near / (near - far);
      out[15] = 0.0;
      return out;
    }

    function mat4_fromRotationTranslation(out, q, v) {
      // Quaternion math
      var x = q[0],
          y = q[1],
          z = q[2],
          w = q[3],
          x2 = x + x,
          y2 = y + y,
          z2 = z + z,
          xx = x * x2,
          xy = x * y2,
          xz = x * z2,
          yy = y * y2,
          yz = y * z2,
          zz = z * z2,
          wx = w * x2,
          wy = w * y2,
          wz = w * z2;

      out[0] = 1 - (yy + zz);
      out[1] = xy + wz;
      out[2] = xz - wy;
      out[3] = 0;
      out[4] = xy - wz;
      out[5] = 1 - (xx + zz);
      out[6] = yz + wx;
      out[7] = 0;
      out[8] = xz + wy;
      out[9] = yz - wx;
      out[10] = 1 - (xx + yy);
      out[11] = 0;
      out[12] = v[0];
      out[13] = v[1];
      out[14] = v[2];
      out[15] = 1;

      return out;
    };

    function mat4_translate(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2],
          a00,
          a01,
          a02,
          a03,
          a10,
          a11,
          a12,
          a13,
          a20,
          a21,
          a22,
          a23;

      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
        a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
        a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

        out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
        out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
        out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }

      return out;
    };

    mat4_invert = function (out, a) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15],
          b00 = a00 * a11 - a01 * a10,
          b01 = a00 * a12 - a02 * a10,
          b02 = a00 * a13 - a03 * a10,
          b03 = a01 * a12 - a02 * a11,
          b04 = a01 * a13 - a03 * a11,
          b05 = a02 * a13 - a03 * a12,
          b06 = a20 * a31 - a21 * a30,
          b07 = a20 * a32 - a22 * a30,
          b08 = a20 * a33 - a23 * a30,
          b09 = a21 * a32 - a22 * a31,
          b10 = a21 * a33 - a23 * a31,
          b11 = a22 * a33 - a23 * a32,


      // Calculate the determinant
      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }
      det = 1.0 / det;

      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

      return out;
    };

    var defaultOrientation = new Float32Array([0, 0, 0, 1]);
    var defaultPosition = new Float32Array([0, 0, 0]);

    function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
      mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

      var orientation = pose.orientation || defaultOrientation;
      var position = pose.position || defaultPosition;

      mat4_fromRotationTranslation(view, orientation, position);
      if (parameters) mat4_translate(view, view, parameters.offset);
      mat4_invert(view, view);
    }

    return function (frameData, pose, vrDisplay) {
      if (!frameData || !pose) return false;

      frameData.pose = pose;
      frameData.timestamp = pose.timestamp;

      updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay.getEyeParameters("left"), vrDisplay);
      updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay.getEyeParameters("right"), vrDisplay);

      return true;
    };
  }();

  module.exports = Util;
  return module.exports;
});
$__System.registerDynamic('95', ['82'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Util = $__require('82');

  /**
   * Android and iOS compatible wakelock implementation.
   *
   * Refactored thanks to dkovalev@.
   */
  function AndroidWakeLock() {
    var video = document.createElement('video');

    video.addEventListener('ended', function () {
      video.play();
    });

    this.request = function () {
      if (video.paused) {
        // Base64 version of videos_src/no-sleep-120s.mp4.
        video.src = Util.base64('video/mp4', 'AAAAGGZ0eXBpc29tAAAAAG1wNDFhdmMxAAAIA21vb3YAAABsbXZoZAAAAADSa9v60mvb+gABX5AAlw/gAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAdkdHJhawAAAFx0a2hkAAAAAdJr2/rSa9v6AAAAAQAAAAAAlw/gAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAHAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAJcP4AAAAAAAAQAAAAAG3G1kaWEAAAAgbWRoZAAAAADSa9v60mvb+gAPQkAGjneAFccAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABodtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAZHc3RibAAAAJdzdHNkAAAAAAAAAAEAAACHYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAMABwASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADFhdmNDAWQAC//hABlnZAALrNlfllw4QAAAAwBAAAADAKPFCmWAAQAFaOvssiwAAAAYc3R0cwAAAAAAAAABAAAAbgAPQkAAAAAUc3RzcwAAAAAAAAABAAAAAQAAA4BjdHRzAAAAAAAAAG4AAAABAD0JAAAAAAEAehIAAAAAAQA9CQAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEALcbAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAABuAAAAAQAAAcxzdHN6AAAAAAAAAAAAAABuAAADCQAAABgAAAAOAAAADgAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABMAAAAUc3RjbwAAAAAAAAABAAAIKwAAACt1ZHRhAAAAI6llbmMAFwAAdmxjIDIuMi4xIHN0cmVhbSBvdXRwdXQAAAAId2lkZQAACRRtZGF0AAACrgX//6vcRem95tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTQyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVmPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6b25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1hYnIgbWJ0cmVlPTEgYml0cmF0ZT0xMDAgcmF0ZXRvbD0xLjAgcWNvbXA9MC42MCBxcG1pbj0xMCBxcG1heD01MSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAU2WIhAAQ/8ltlOe+cTZuGkKg+aRtuivcDZ0pBsfsEi9p/i1yU9DxS2lq4dXTinViF1URBKXgnzKBd/Uh1bkhHtMrwrRcOJslD01UB+fyaL6ef+DBAAAAFEGaJGxBD5B+v+a+4QqF3MgBXz9MAAAACkGeQniH/+94r6EAAAAKAZ5hdEN/8QytwAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFomUwIIf/+4QAAAApBnoZFESw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAOQZrwSahBbJlMCCH//uEAAAAKQZ8ORRUsP/++gQAAAAgBny10Q3/EgQAAAAgBny9qQ3/EgAAAAA5BmzRJqEFsmUwIIf/+4AAAAApBn1JFFSw//76BAAAACAGfcXRDf8SAAAAACAGfc2pDf8SAAAAADkGbeEmoQWyZTAgh//7hAAAACkGflkUVLD//voAAAAAIAZ+1dEN/xIEAAAAIAZ+3akN/xIEAAAAOQZu8SahBbJlMCCH//uAAAAAKQZ/aRRUsP/++gQAAAAgBn/l0Q3/EgAAAAAgBn/tqQ3/EgQAAAA5Bm+BJqEFsmUwIIf/+4QAAAApBnh5FFSw//76AAAAACAGePXRDf8SAAAAACAGeP2pDf8SBAAAADkGaJEmoQWyZTAgh//7gAAAACkGeQkUVLD//voEAAAAIAZ5hdEN/xIAAAAAIAZ5jakN/xIEAAAAOQZpoSahBbJlMCCH//uEAAAAKQZ6GRRUsP/++gQAAAAgBnqV0Q3/EgQAAAAgBnqdqQ3/EgAAAAA5BmqxJqEFsmUwIIf/+4AAAAApBnspFFSw//76BAAAACAGe6XRDf8SAAAAACAGe62pDf8SAAAAADkGa8EmoQWyZTAgh//7hAAAACkGfDkUVLD//voEAAAAIAZ8tdEN/xIEAAAAIAZ8vakN/xIAAAAAOQZs0SahBbJlMCCH//uAAAAAKQZ9SRRUsP/++gQAAAAgBn3F0Q3/EgAAAAAgBn3NqQ3/EgAAAAA5Bm3hJqEFsmUwIIf/+4QAAAApBn5ZFFSw//76AAAAACAGftXRDf8SBAAAACAGft2pDf8SBAAAADkGbvEmoQWyZTAgh//7gAAAACkGf2kUVLD//voEAAAAIAZ/5dEN/xIAAAAAIAZ/7akN/xIEAAAAOQZvgSahBbJlMCCH//uEAAAAKQZ4eRRUsP/++gAAAAAgBnj10Q3/EgAAAAAgBnj9qQ3/EgQAAAA5BmiRJqEFsmUwIIf/+4AAAAApBnkJFFSw//76BAAAACAGeYXRDf8SAAAAACAGeY2pDf8SBAAAADkGaaEmoQWyZTAgh//7hAAAACkGehkUVLD//voEAAAAIAZ6ldEN/xIEAAAAIAZ6nakN/xIAAAAAOQZqsSahBbJlMCCH//uAAAAAKQZ7KRRUsP/++gQAAAAgBnul0Q3/EgAAAAAgBnutqQ3/EgAAAAA5BmvBJqEFsmUwIIf/+4QAAAApBnw5FFSw//76BAAAACAGfLXRDf8SBAAAACAGfL2pDf8SAAAAADkGbNEmoQWyZTAgh//7gAAAACkGfUkUVLD//voEAAAAIAZ9xdEN/xIAAAAAIAZ9zakN/xIAAAAAOQZt4SahBbJlMCCH//uEAAAAKQZ+WRRUsP/++gAAAAAgBn7V0Q3/EgQAAAAgBn7dqQ3/EgQAAAA5Bm7xJqEFsmUwIIf/+4AAAAApBn9pFFSw//76BAAAACAGf+XRDf8SAAAAACAGf+2pDf8SBAAAADkGb4EmoQWyZTAgh//7hAAAACkGeHkUVLD//voAAAAAIAZ49dEN/xIAAAAAIAZ4/akN/xIEAAAAOQZokSahBbJlMCCH//uAAAAAKQZ5CRRUsP/++gQAAAAgBnmF0Q3/EgAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFsmUwIIf/+4QAAAApBnoZFFSw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAPQZruSahBbJlMFEw3//7B');
        video.play();
      }
    };

    this.release = function () {
      video.pause();
      video.src = '';
    };
  }

  function iOSWakeLock() {
    var timer = null;

    this.request = function () {
      if (!timer) {
        timer = setInterval(function () {
          window.location = window.location;
          setTimeout(window.stop, 0);
        }, 30000);
      }
    };

    this.release = function () {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    };
  }

  function getWakeLock() {
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
      return iOSWakeLock;
    } else {
      return AndroidWakeLock;
    }
  }

  module.exports = getWakeLock();
  return module.exports;
});
$__System.registerDynamic('92', ['82', '95'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Util = $__require('82');
  var WakeLock = $__require('95');

  // Start at a higher number to reduce chance of conflict.
  var nextDisplayId = 1000;
  var hasShowDeprecationWarning = false;

  var defaultLeftBounds = [0, 0, 0.5, 1];
  var defaultRightBounds = [0.5, 0, 0.5, 1];

  /**
   * The base class for all VR frame data.
   */

  function VRFrameData() {
    this.leftProjectionMatrix = new Float32Array(16);
    this.leftViewMatrix = new Float32Array(16);
    this.rightProjectionMatrix = new Float32Array(16);
    this.rightViewMatrix = new Float32Array(16);
    this.pose = null;
  };

  /**
   * The base class for all VR displays.
   */
  function VRDisplay() {
    this.isPolyfilled = true;
    this.displayId = nextDisplayId++;
    this.displayName = 'webvr-polyfill displayName';

    this.depthNear = 0.01;
    this.depthFar = 10000.0;

    this.isConnected = true;
    this.isPresenting = false;
    this.capabilities = {
      hasPosition: false,
      hasOrientation: false,
      hasExternalDisplay: false,
      canPresent: false,
      maxLayers: 1
    };
    this.stageParameters = null;

    // "Private" members.
    this.waitingForPresent_ = false;
    this.layer_ = null;

    this.fullscreenElement_ = null;
    this.fullscreenWrapper_ = null;
    this.fullscreenElementCachedStyle_ = null;

    this.fullscreenEventTarget_ = null;
    this.fullscreenChangeHandler_ = null;
    this.fullscreenErrorHandler_ = null;

    this.wakelock_ = new WakeLock();
  }

  VRDisplay.prototype.getFrameData = function (frameData) {
    // TODO: Technically this should retain it's value for the duration of a frame
    // but I doubt that's practical to do in javascript.
    return Util.frameDataFromPose(frameData, this.getPose(), this);
  };

  VRDisplay.prototype.getPose = function () {
    // TODO: Technically this should retain it's value for the duration of a frame
    // but I doubt that's practical to do in javascript.
    return this.getImmediatePose();
  };

  VRDisplay.prototype.requestAnimationFrame = function (callback) {
    return window.requestAnimationFrame(callback);
  };

  VRDisplay.prototype.cancelAnimationFrame = function (id) {
    return window.cancelAnimationFrame(id);
  };

  VRDisplay.prototype.wrapForFullscreen = function (element) {
    // Don't wrap in iOS.
    if (Util.isIOS()) {
      return element;
    }
    if (!this.fullscreenWrapper_) {
      this.fullscreenWrapper_ = document.createElement('div');
      var cssProperties = ['height: ' + Math.min(screen.height, screen.width) + 'px !important', 'top: 0 !important', 'left: 0 !important', 'right: 0 !important', 'border: 0', 'margin: 0', 'padding: 0', 'z-index: 999999 !important', 'position: fixed'];
      this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
      this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
    }

    if (this.fullscreenElement_ == element) {
      return this.fullscreenWrapper_;
    }

    // Remove any previously applied wrappers
    this.removeFullscreenWrapper();

    this.fullscreenElement_ = element;
    var parent = this.fullscreenElement_.parentElement;
    parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
    parent.removeChild(this.fullscreenElement_);
    this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
    this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');

    var self = this;
    function applyFullscreenElementStyle() {
      if (!self.fullscreenElement_) {
        return;
      }

      var cssProperties = ['position: absolute', 'top: 0', 'left: 0', 'width: ' + Math.max(screen.width, screen.height) + 'px', 'height: ' + Math.min(screen.height, screen.width) + 'px', 'border: 0', 'margin: 0', 'padding: 0'];
      self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
    }

    applyFullscreenElementStyle();

    return this.fullscreenWrapper_;
  };

  VRDisplay.prototype.removeFullscreenWrapper = function () {
    if (!this.fullscreenElement_) {
      return;
    }

    var element = this.fullscreenElement_;
    if (this.fullscreenElementCachedStyle_) {
      element.setAttribute('style', this.fullscreenElementCachedStyle_);
    } else {
      element.removeAttribute('style');
    }
    this.fullscreenElement_ = null;
    this.fullscreenElementCachedStyle_ = null;

    var parent = this.fullscreenWrapper_.parentElement;
    this.fullscreenWrapper_.removeChild(element);
    parent.insertBefore(element, this.fullscreenWrapper_);
    parent.removeChild(this.fullscreenWrapper_);

    return element;
  };

  VRDisplay.prototype.requestPresent = function (layers) {
    var wasPresenting = this.isPresenting;
    var self = this;

    if (!(layers instanceof Array)) {
      if (!hasShowDeprecationWarning) {
        console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
        hasShowDeprecationWarning = true;
      }
      layers = [layers];
    }

    return new Promise(function (resolve, reject) {
      if (!self.capabilities.canPresent) {
        reject(new Error('VRDisplay is not capable of presenting.'));
        return;
      }

      if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
        reject(new Error('Invalid number of layers.'));
        return;
      }

      var incomingLayer = layers[0];
      if (!incomingLayer.source) {
        /*
        todo: figure out the correct behavior if the source is not provided.
        see https://github.com/w3c/webvr/issues/58
        */
        resolve();
        return;
      }

      var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
      var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
      if (wasPresenting) {
        // Already presenting, just changing configuration
        var changed = false;
        var layer = self.layer_;
        if (layer.source !== incomingLayer.source) {
          layer.source = incomingLayer.source;
          changed = true;
        }

        for (var i = 0; i < 4; i++) {
          if (layer.leftBounds[i] !== leftBounds[i]) {
            layer.leftBounds[i] = leftBounds[i];
            changed = true;
          }
          if (layer.rightBounds[i] !== rightBounds[i]) {
            layer.rightBounds[i] = rightBounds[i];
            changed = true;
          }
        }

        if (changed) {
          self.fireVRDisplayPresentChange_();
        }
        resolve();
        return;
      }

      // Was not already presenting.
      self.layer_ = {
        predistorted: incomingLayer.predistorted,
        source: incomingLayer.source,
        leftBounds: leftBounds.slice(0),
        rightBounds: rightBounds.slice(0)
      };

      self.waitingForPresent_ = false;
      if (self.layer_ && self.layer_.source) {
        var fullscreenElement = self.wrapForFullscreen(self.layer_.source);

        function onFullscreenChange() {
          var actualFullscreenElement = Util.getFullscreenElement();

          self.isPresenting = fullscreenElement === actualFullscreenElement;
          if (self.isPresenting) {
            if (screen.orientation && screen.orientation.lock) {
              screen.orientation.lock('landscape-primary').catch(function (error) {
                console.error('screen.orientation.lock() failed due to', error.message);
              });
            }
            self.waitingForPresent_ = false;
            self.beginPresent_();
            resolve();
          } else {
            if (screen.orientation && screen.orientation.unlock) {
              screen.orientation.unlock();
            }
            self.removeFullscreenWrapper();
            self.wakelock_.release();
            self.endPresent_();
            self.removeFullscreenListeners_();
          }
          self.fireVRDisplayPresentChange_();
        }
        function onFullscreenError() {
          if (!self.waitingForPresent_) {
            return;
          }

          self.removeFullscreenWrapper();
          self.removeFullscreenListeners_();

          self.wakelock_.release();
          self.waitingForPresent_ = false;
          self.isPresenting = false;

          reject(new Error('Unable to present.'));
        }

        self.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);

        if (Util.requestFullscreen(fullscreenElement)) {
          self.wakelock_.request();
          self.waitingForPresent_ = true;
        } else if (Util.isIOS()) {
          // *sigh* Just fake it.
          self.wakelock_.request();
          self.isPresenting = true;
          self.beginPresent_();
          self.fireVRDisplayPresentChange_();
          resolve();
        }
      }

      if (!self.waitingForPresent_ && !Util.isIOS()) {
        Util.exitFullscreen();
        reject(new Error('Unable to present.'));
      }
    });
  };

  VRDisplay.prototype.exitPresent = function () {
    var wasPresenting = this.isPresenting;
    var self = this;
    this.isPresenting = false;
    this.layer_ = null;
    this.wakelock_.release();

    return new Promise(function (resolve, reject) {
      if (wasPresenting) {
        if (!Util.exitFullscreen() && Util.isIOS()) {
          self.endPresent_();
          self.fireVRDisplayPresentChange_();
        }

        resolve();
      } else {
        reject(new Error('Was not presenting to VRDisplay.'));
      }
    });
  };

  VRDisplay.prototype.getLayers = function () {
    if (this.layer_) {
      return [this.layer_];
    }
    return [];
  };

  VRDisplay.prototype.fireVRDisplayPresentChange_ = function () {
    var event = new CustomEvent('vrdisplaypresentchange', { detail: { vrdisplay: this } });
    window.dispatchEvent(event);
  };

  VRDisplay.prototype.addFullscreenListeners_ = function (element, changeHandler, errorHandler) {
    this.removeFullscreenListeners_();

    this.fullscreenEventTarget_ = element;
    this.fullscreenChangeHandler_ = changeHandler;
    this.fullscreenErrorHandler_ = errorHandler;

    if (changeHandler) {
      if (document.fullscreenEnabled) {
        element.addEventListener('fullscreenchange', changeHandler, false);
      } else if (document.webkitFullscreenEnabled) {
        element.addEventListener('webkitfullscreenchange', changeHandler, false);
      } else if (document.mozFullScreenEnabled) {
        document.addEventListener('mozfullscreenchange', changeHandler, false);
      } else if (document.msFullscreenEnabled) {
        element.addEventListener('msfullscreenchange', changeHandler, false);
      }
    }

    if (errorHandler) {
      if (document.fullscreenEnabled) {
        element.addEventListener('fullscreenerror', errorHandler, false);
      } else if (document.webkitFullscreenEnabled) {
        element.addEventListener('webkitfullscreenerror', errorHandler, false);
      } else if (document.mozFullScreenEnabled) {
        document.addEventListener('mozfullscreenerror', errorHandler, false);
      } else if (document.msFullscreenEnabled) {
        element.addEventListener('msfullscreenerror', errorHandler, false);
      }
    }
  };

  VRDisplay.prototype.removeFullscreenListeners_ = function () {
    if (!this.fullscreenEventTarget_) return;

    var element = this.fullscreenEventTarget_;

    if (this.fullscreenChangeHandler_) {
      var changeHandler = this.fullscreenChangeHandler_;
      element.removeEventListener('fullscreenchange', changeHandler, false);
      element.removeEventListener('webkitfullscreenchange', changeHandler, false);
      document.removeEventListener('mozfullscreenchange', changeHandler, false);
      element.removeEventListener('msfullscreenchange', changeHandler, false);
    }

    if (this.fullscreenErrorHandler_) {
      var errorHandler = this.fullscreenErrorHandler_;
      element.removeEventListener('fullscreenerror', errorHandler, false);
      element.removeEventListener('webkitfullscreenerror', errorHandler, false);
      document.removeEventListener('mozfullscreenerror', errorHandler, false);
      element.removeEventListener('msfullscreenerror', errorHandler, false);
    }

    this.fullscreenEventTarget_ = null;
    this.fullscreenChangeHandler_ = null;
    this.fullscreenErrorHandler_ = null;
  };

  VRDisplay.prototype.beginPresent_ = function () {
    // Override to add custom behavior when presentation begins.
  };

  VRDisplay.prototype.endPresent_ = function () {
    // Override to add custom behavior when presentation ends.
  };

  VRDisplay.prototype.submitFrame = function (pose) {
    // Override to add custom behavior for frame submission.
  };

  VRDisplay.prototype.getEyeParameters = function (whichEye) {
    // Override to return accurate eye parameters if canPresent is true.
    return null;
  };

  /*
   * Deprecated classes
   */

  /**
   * The base class for all VR devices. (Deprecated)
   */
  function VRDevice() {
    this.isPolyfilled = true;
    this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
    this.deviceId = 'webvr-polyfill deviceId';
    this.deviceName = 'webvr-polyfill deviceName';
  }

  /**
   * The base class for all VR HMD devices. (Deprecated)
   */
  function HMDVRDevice() {}
  HMDVRDevice.prototype = new VRDevice();

  /**
   * The base class for all VR position sensor devices. (Deprecated)
   */
  function PositionSensorVRDevice() {}
  PositionSensorVRDevice.prototype = new VRDevice();

  module.exports.VRFrameData = VRFrameData;
  module.exports.VRDisplay = VRDisplay;
  module.exports.VRDevice = VRDevice;
  module.exports.HMDVRDevice = HMDVRDevice;
  module.exports.PositionSensorVRDevice = PositionSensorVRDevice;
  return module.exports;
});
$__System.registerDynamic('96', ['92'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var VRDisplay = $__require('92').VRDisplay;
  var HMDVRDevice = $__require('92').HMDVRDevice;
  var PositionSensorVRDevice = $__require('92').PositionSensorVRDevice;

  /**
   * Wraps a VRDisplay and exposes it as a HMDVRDevice
   */
  function VRDisplayHMDDevice(display) {
    this.display = display;

    this.hardwareUnitId = display.displayId;
    this.deviceId = 'webvr-polyfill:HMD:' + display.displayId;
    this.deviceName = display.displayName + ' (HMD)';
  }
  VRDisplayHMDDevice.prototype = new HMDVRDevice();

  VRDisplayHMDDevice.prototype.getEyeParameters = function (whichEye) {
    var eyeParameters = this.display.getEyeParameters(whichEye);

    return {
      currentFieldOfView: eyeParameters.fieldOfView,
      maximumFieldOfView: eyeParameters.fieldOfView,
      minimumFieldOfView: eyeParameters.fieldOfView,
      recommendedFieldOfView: eyeParameters.fieldOfView,
      eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
      renderRect: {
        x: whichEye == 'right' ? eyeParameters.renderWidth : 0,
        y: 0,
        width: eyeParameters.renderWidth,
        height: eyeParameters.renderHeight
      }
    };
  };

  VRDisplayHMDDevice.prototype.setFieldOfView = function (opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
    // Not supported. getEyeParameters reports that the min, max, and recommended
    // FoV is all the same, so no adjustment can be made.
  };

  // TODO: Need to hook requestFullscreen to see if a wrapped VRDisplay was passed
  // in as an option. If so we should prevent the default fullscreen behavior and
  // call VRDisplay.requestPresent instead.

  /**
   * Wraps a VRDisplay and exposes it as a PositionSensorVRDevice
   */
  function VRDisplayPositionSensorDevice(display) {
    this.display = display;

    this.hardwareUnitId = display.displayId;
    this.deviceId = 'webvr-polyfill:PositionSensor: ' + display.displayId;
    this.deviceName = display.displayName + ' (PositionSensor)';
  }
  VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();

  VRDisplayPositionSensorDevice.prototype.getState = function () {
    var pose = this.display.getPose();
    return {
      position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
      orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
      linearVelocity: null,
      linearAcceleration: null,
      angularVelocity: null,
      angularAcceleration: null
    };
  };

  VRDisplayPositionSensorDevice.prototype.resetState = function () {
    return this.positionDevice.resetPose();
  };

  module.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
  module.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;
  return module.exports;
});
$__System.registerDynamic('97', ['82', '91', '93', '92', '96'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var Util = $__require('82');
  var CardboardVRDisplay = $__require('91');
  var MouseKeyboardVRDisplay = $__require('93');
  // Uncomment to add positional tracking via webcam.
  //var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
  var VRDisplay = $__require('92').VRDisplay;
  var VRFrameData = $__require('92').VRFrameData;
  var HMDVRDevice = $__require('92').HMDVRDevice;
  var PositionSensorVRDevice = $__require('92').PositionSensorVRDevice;
  var VRDisplayHMDDevice = $__require('96').VRDisplayHMDDevice;
  var VRDisplayPositionSensorDevice = $__require('96').VRDisplayPositionSensorDevice;

  function WebVRPolyfill() {
    this.displays = [];
    this.devices = []; // For deprecated objects
    this.devicesPopulated = false;
    this.nativeWebVRAvailable = this.isWebVRAvailable();
    this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();

    if (!this.nativeLegacyWebVRAvailable) {
      if (!this.nativeWebVRAvailable) {
        this.enablePolyfill();
      }
      if (WebVRConfig.ENABLE_DEPRECATED_API) {
        this.enableDeprecatedPolyfill();
      }
    }

    // Put a shim in place to update the API to 1.1 if needed.
    InstallWebVRSpecShim();
  }

  WebVRPolyfill.prototype.isWebVRAvailable = function () {
    return 'getVRDisplays' in navigator;
  };

  WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function () {
    return 'getVRDevices' in navigator || 'mozGetVRDevices' in navigator;
  };

  WebVRPolyfill.prototype.populateDevices = function () {
    if (this.devicesPopulated) {
      return;
    }

    // Initialize our virtual VR devices.
    var vrDisplay = null;

    // Add a Cardboard VRDisplay on compatible mobile devices
    if (this.isCardboardCompatible()) {
      vrDisplay = new CardboardVRDisplay();
      this.displays.push(vrDisplay);

      // For backwards compatibility
      if (WebVRConfig.ENABLE_DEPRECATED_API) {
        this.devices.push(new VRDisplayHMDDevice(vrDisplay));
        this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
      }
    }

    // Add a Mouse and Keyboard driven VRDisplay for desktops/laptops
    if (!this.isMobile() && !WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
      vrDisplay = new MouseKeyboardVRDisplay();
      this.displays.push(vrDisplay);

      // For backwards compatibility
      if (WebVRConfig.ENABLE_DEPRECATED_API) {
        this.devices.push(new VRDisplayHMDDevice(vrDisplay));
        this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
      }
    }

    // Uncomment to add positional tracking via webcam.
    //if (!this.isMobile() && WebVRConfig.ENABLE_DEPRECATED_API) {
    //  positionDevice = new WebcamPositionSensorVRDevice();
    //  this.devices.push(positionDevice);
    //}

    this.devicesPopulated = true;
  };

  WebVRPolyfill.prototype.enablePolyfill = function () {
    // Provide navigator.getVRDisplays.
    navigator.getVRDisplays = this.getVRDisplays.bind(this);

    // Provide the VRDisplay object.
    window.VRDisplay = VRDisplay;

    // Provide navigator.vrEnabled.
    var self = this;
    Object.defineProperty(navigator, 'vrEnabled', {
      get: function () {
        return self.isCardboardCompatible() && (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || false);
      }
    });

    // Provide the VRFrameData object.
    window.VRFrameData = VRFrameData;
  };

  WebVRPolyfill.prototype.enableDeprecatedPolyfill = function () {
    // Provide navigator.getVRDevices.
    navigator.getVRDevices = this.getVRDevices.bind(this);

    // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
    window.HMDVRDevice = HMDVRDevice;
    window.PositionSensorVRDevice = PositionSensorVRDevice;
  };

  WebVRPolyfill.prototype.getVRDisplays = function () {
    this.populateDevices();
    var displays = this.displays;
    return new Promise(function (resolve, reject) {
      try {
        resolve(displays);
      } catch (e) {
        reject(e);
      }
    });
  };

  WebVRPolyfill.prototype.getVRDevices = function () {
    console.warn('getVRDevices is deprecated. Please update your code to use getVRDisplays instead.');
    var self = this;
    return new Promise(function (resolve, reject) {
      try {
        if (!self.devicesPopulated) {
          if (self.nativeWebVRAvailable) {
            return navigator.getVRDisplays(function (displays) {
              for (var i = 0; i < displays.length; ++i) {
                self.devices.push(new VRDisplayHMDDevice(displays[i]));
                self.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
              }
              self.devicesPopulated = true;
              resolve(self.devices);
            }, reject);
          }

          if (self.nativeLegacyWebVRAvailable) {
            return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function (devices) {
              for (var i = 0; i < devices.length; ++i) {
                if (devices[i] instanceof HMDVRDevice) {
                  self.devices.push(devices[i]);
                }
                if (devices[i] instanceof PositionSensorVRDevice) {
                  self.devices.push(devices[i]);
                }
              }
              self.devicesPopulated = true;
              resolve(self.devices);
            }, reject);
          }
        }

        self.populateDevices();
        resolve(self.devices);
      } catch (e) {
        reject(e);
      }
    });
  };

  /**
   * Determine if a device is mobile.
   */
  WebVRPolyfill.prototype.isMobile = function () {
    return (/Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent)
    );
  };

  WebVRPolyfill.prototype.isCardboardCompatible = function () {
    // For now, support all iOS and Android devices.
    // Also enable the WebVRConfig.FORCE_VR flag for debugging.
    return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
  };

  // Installs a shim that updates a WebVR 1.0 spec implementation to WebVR 1.1
  function InstallWebVRSpecShim() {
    if ('VRDisplay' in window && !('VRFrameData' in window)) {
      // Provide the VRFrameData object.
      window.VRFrameData = VRFrameData;

      // A lot of Chrome builds don't have depthNear and depthFar, even
      // though they're in the WebVR 1.0 spec. Patch them in if they're not present.
      if (!('depthNear' in window.VRDisplay.prototype)) {
        window.VRDisplay.prototype.depthNear = 0.01;
      }

      if (!('depthFar' in window.VRDisplay.prototype)) {
        window.VRDisplay.prototype.depthFar = 10000.0;
      }

      window.VRDisplay.prototype.getFrameData = function (frameData) {
        return Util.frameDataFromPose(frameData, this.getPose(), this);
      };
    }
  };

  module.exports.WebVRPolyfill = WebVRPolyfill;
  return module.exports;
});
$__System.registerDynamic('98', ['82', '97'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*
   * Copyright 2015 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Util = $__require('82');
  var WebVRPolyfill = $__require('97').WebVRPolyfill;

  // Initialize a WebVRConfig just in case.
  window.WebVRConfig = Util.extend({
    // Forces availability of VR mode, even for non-mobile devices.
    FORCE_ENABLE_VR: false,

    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    K_FILTER: 0.98,

    // How far into the future to predict during fast motion (in seconds).
    PREDICTION_TIME_S: 0.040,

    // Flag to enable touch panner. In case you have your own touch controls.
    TOUCH_PANNER_DISABLED: true,

    // Flag to disabled the UI in VR Mode.
    CARDBOARD_UI_DISABLED: false, // Default: false

    // Flag to disable the instructions to rotate your device.
    ROTATE_INSTRUCTIONS_DISABLED: false, // Default: false.

    // Enable yaw panning only, disabling roll and pitch. This can be useful
    // for panoramas with nothing interesting above or below.
    YAW_ONLY: false,

    // To disable keyboard and mouse controls, if you want to use your own
    // implementation.
    MOUSE_KEYBOARD_CONTROLS_DISABLED: false,

    // Prevent the polyfill from initializing immediately. Requires the app
    // to call InitializeWebVRPolyfill() before it can be used.
    DEFER_INITIALIZATION: false,

    // Enable the deprecated version of the API (navigator.getVRDevices).
    ENABLE_DEPRECATED_API: false,

    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance.
    // UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
    // perform well on many mobile devices.
    BUFFER_SCALE: 0.5,

    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind its resources on the
    // next frame anyway. This has been seen to cause rendering glitches with
    // THREE.js.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0.
    DIRTY_SUBMIT_FRAME_BINDINGS: false
  }, window.WebVRConfig);

  if (!window.WebVRConfig.DEFER_INITIALIZATION) {
    new WebVRPolyfill();
  } else {
    window.InitializeWebVRPolyfill = function () {
      new WebVRPolyfill();
    };
  }
  return module.exports;
});
$__System.register('1', ['2', '3', '3b', '4', '9', '10', 'a', '1f', '32', '41', '13', '14', '18', '1e', '24', '15', '5', '7', '42', '1a', '1b', '8', '39', '3c', '51', '6e', '2d', '17', 'd', '27', '28', '2e', '2f', '30', '21', '26', '29', '35', '20', '36', '37', '38', 'e', 'f', '2a', '3d', '44', '7c', '46', '49', '4c', '4f', '7d', '7e', '7f', '81', '98'], function (_export, _context) {
    "use strict";

    var AggregateError, PLATFORM, binarySearch, cesium_Source_DataSources_CallbackProperty_js, CameraEventAggregator, CameraEventType, cesium_Source_Core_Cartesian2_js, Cartesian3, cesium_Source_Core_Cartesian4_js, Cartographic, cesium_Source_Core_Clock_js, cesium_Source_Core_ClockStep_js, cesium_Source_DataSources_CompositeEntityCollection_js, ConstantPositionProperty, ConstantProperty, defaultValue, defined, cesium_Source_Core_DeveloperError_js, Ellipsoid, Entity, EntityCollection, Event, cesium_Source_Core_ExtrapolationType_js, cesium_Source_Core_FeatureDetection_js, cesium_Source_Core_GeographicProjection_js, cesium_Source_Core_HeadingPitchRoll_js, cesium_Source_Core_HermitePolynomialApproximation_js, JulianDate, CesiumMath, Matrix3, Matrix4, OrientationProperty, PerspectiveFrustum, PerspectiveOffCenterFrustum, cesium_Source_DataSources_PositionProperty_js, cesium_Source_DataSources_Property_js, Quaternion, ReferenceEntity, ReferenceFrame, cesium_Source_DataSources_ReferenceProperty_js, SampledPositionProperty, SampledProperty, cesium_Source_Core_ScreenSpaceEventHandler_js, cesium_Source_Core_ScreenSpaceEventType_js, Transforms, cesium_Source_Core_Simon1994PlanetaryPositions_js, cesium_Source_Core_PolylinePipeline_js, TerrainProvider, throttleRequestByServer, loadImage, WebMercatorTilingScheme, getImagePixels, HeightmapTerrainData, Credit, sampleTerrain, CardboardUI, _extends, _typeof, metadata, originStorage, unknownOrigin, Origin, _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _dec5, _class9, _dec6, _class11, _dec7, _class13, _classInvokers, resolver, Lazy, All, Optional, Parent, StrategyResolver, Factory, NewInstance, FactoryInvoker, TransientRegistration, SingletonRegistration, _emptyParameters, resolverDecorates, InvocationHandler, classInvokers, Container, DI, after, lut, i, cesiumImports, kButtonWidthDp, kTouchSlopFactor, __extends$1, AVERAGE_EYE_HEIGHT, DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE, Role, Configuration, Viewport, CanvasViewport, SubviewType, SerializedEntityState, SerializedSubview, SerializedSubviewList, Event$1, CommandQueue, MessageChannelLike, SynchronousMessageChannel, MessageChannelFactory, eventSynthesizerFunction, getEventSynthesizier$1, cloneTouch, cloneTouches, eastUpSouthToFixedFrame, scratchAncestorCartesian, scratchAncestorQuaternion, getEntityPosition, getEntityOrientation, _scratchFramesArray, _entityStateCache, urlParser, scratchPerspectiveOffCenterFrustum, scratchCartesian, scratchOrientation, isIOS, lastTime, rAF, cAF, defaultTerrainProvider, version, __extends, __decorate$1, __metadata$1, emptyObject, SessionPort, SessionPortFactory, ConnectService, SessionService, LoopbackConnectService, DOMConnectService, DebugConnectService, SessionConnectService, WKWebViewConnectService, AndroidWebViewConnectService, _a$1, _b$1, __decorate$5, __metadata$5, PermissionNames, PermissionDescriptions, Permission, PermissionState, PermissionService, PermissionServiceProvider, _a$5, _b$5, __decorate$4, __metadata$4, EntityPose, PoseStatus, EntityService, EntityServiceProvider, _a$4, _b$4, _c$3, __decorate$7, __metadata$7, FocusService, FocusServiceProvider, _a$7, _b$7, __decorate$8, __metadata$8, VisibilityService, VisibilityServiceProvider, _a$8, _b$8, __decorate$6, __metadata$6, Subview, ViewportMode, ViewElement, ViewService, ViewServiceProvider, viewportMetaTag, argonMetaTag, style, sheet, _a$6, _b$6, _c$4, _d$3, _e$3, __decorate$3, __metadata$3, DeviceStableState$$1, DeviceFrameState$$1, DeviceService, DeviceServiceProvider, _a$3, _b$3, _c$2, _d$2, _e$2, _f$1, _g$1, _h$1, _j$1, _k$1, _l$1, __decorate$10, __metadata$10, ContextService, ContextServiceProvider, _a$10, _b$10, _c$6, _d$5, _e$5, _f$3, _g$3, _h$3, _j$2, _k$2, _l$2, _m$1, RealityViewer, __extends$2, __decorate$11, __metadata$11, EmptyRealityViewer, _a$11, _b$11, _c$7, __extends$3, __decorate$12, __metadata$12, LiveRealityViewer, _a$12, _b$12, _c$8, _d$6, __extends$4, __decorate$13, __metadata$13, HostedRealityViewer, _a$13, _b$13, __decorate$9, __metadata$9, RealityViewerFactory, RealityService, RealityServiceProvider, _a$9, _b$9, _c$5, _d$4, _e$4, _f$2, _g$2, _h$2, __decorate$2, __metadata$2, openIcon, eyeIcon, vrIcon, fullscreenIcon, argonAppIcon, DefaultUIService, _a$2, _b$2, _c$1, _d$1, _e$1, __extends$5, __decorate$14, __metadata$14, VuforiaServiceProvider, VuforiaService, VuforiaAPI, VuforiaTracker, VuforiaObjectTracker, DeprecatedVuforiaDataSet, _a$14, _b$14, __decorate, __metadata, ArgonSystemProvider, ArgonSystem, ArgonConfigurationManager, initReality, _a, _b, _c, _d, _e, _f, _g, _h, _j, ArgonSystem_1, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;

    function alwaysValid() {
        return true;
    }
    function noCompose() {}
    function ensureProtocolOptions(options) {
        if (options === undefined) {
            options = {};
        } else if (typeof options === 'function') {
            options = {
                validate: options
            };
        }
        if (!options.validate) {
            options.validate = alwaysValid;
        }
        if (!options.compose) {
            options.compose = noCompose;
        }
        return options;
    }
    function createProtocolValidator(validate) {
        return function (target) {
            var result = validate(target);
            return result === true;
        };
    }
    function createProtocolAsserter(name, validate) {
        return function (target) {
            var result = validate(target);
            if (result !== true) {
                throw new Error(result || name + ' was not correctly implemented.');
            }
        };
    }
    function protocol(name, options) {
        options = ensureProtocolOptions(options);
        var result = function result(target) {
            var resolvedTarget = typeof target === 'function' ? target.prototype : target;
            options.compose(resolvedTarget);
            result.assert(resolvedTarget);
            Object.defineProperty(resolvedTarget, 'protocol:' + name, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: true
            });
        };
        result.validate = createProtocolValidator(options.validate);
        result.assert = createProtocolAsserter(name, options.validate);
        return result;
    }

    function getDecoratorDependencies(target, name) {
        var dependencies = target.inject;
        if (typeof dependencies === 'function') {
            throw new Error('Decorator ' + name + ' cannot be used with "inject()".  Please use an array instead.');
        }
        if (!dependencies) {
            dependencies = metadata.getOwn(metadata.paramTypes, target).slice();
            target.inject = dependencies;
        }
        return dependencies;
    }
    function lazy(keyValue) {
        return function (target, key, index) {
            var params = getDecoratorDependencies(target, 'lazy');
            params[index] = Lazy.of(keyValue);
        };
    }
    function all(keyValue) {
        return function (target, key, index) {
            var params = getDecoratorDependencies(target, 'all');
            params[index] = All.of(keyValue);
        };
    }
    function optional() {
        var checkParentOrTarget = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
        var deco = function deco(checkParent) {
            return function (target, key, index) {
                var params = getDecoratorDependencies(target, 'optional');
                params[index] = Optional.of(params[index], checkParent);
            };
        };
        if (typeof checkParentOrTarget === 'boolean') {
            return deco(checkParentOrTarget);
        }
        return deco(true);
    }
    function parent(target, key, index) {
        var params = getDecoratorDependencies(target, 'parent');
        params[index] = Parent.of(params[index]);
    }
    function factory(keyValue, asValue) {
        return function (target, key, index) {
            var params = getDecoratorDependencies(target, 'factory');
            var factory = Factory.of(keyValue);
            params[index] = asValue ? factory.as(asValue) : factory;
        };
    }
    function newInstance(asKeyOrTarget) {
        for (var _len4 = arguments.length, dynamicDependencies = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            dynamicDependencies[_key4 - 1] = arguments[_key4];
        }
        var deco = function deco(asKey) {
            return function (target, key, index) {
                var params = getDecoratorDependencies(target, 'newInstance');
                params[index] = NewInstance.of.apply(NewInstance, [params[index]].concat(dynamicDependencies));
                if (!!asKey) {
                    params[index].as(asKey);
                }
            };
        };
        if (arguments.length >= 1) {
            return deco(asKeyOrTarget);
        }
        return deco();
    }
    function invoker(value) {
        return function (target) {
            metadata.define(metadata.invoker, value, target);
        };
    }
    function invokeAsFactory(potentialTarget) {
        var deco = function deco(target) {
            metadata.define(metadata.invoker, FactoryInvoker.instance, target);
        };
        return potentialTarget ? deco(potentialTarget) : deco;
    }

    function registration(value) {
        return function (target) {
            metadata.define(metadata.registration, value, target);
        };
    }
    function transient(key) {
        return registration(new TransientRegistration(key));
    }
    function singleton(keyOrRegisterInChild) {
        var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
        return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
    }

    function validateKey(key) {
        if (key === null || key === undefined) {
            throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
        }
    }

    function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
        var i = staticDependencies.length;
        var args = new Array(i);
        while (i--) {
            args[i] = container.get(staticDependencies[i]);
        }
        if (dynamicDependencies !== undefined) {
            args = args.concat(dynamicDependencies);
        }
        return Reflect.construct(fn, args);
    }

    function getDependencies(f) {
        if (!f.hasOwnProperty('inject')) {
            return [];
        }
        if (typeof f.inject === 'function') {
            return f.inject();
        }
        return f.inject;
    }

    function autoinject(potentialTarget) {
        var deco = function deco(target) {
            var previousInject = target.inject;
            var autoInject = metadata.getOwn(metadata.paramTypes, target) || _emptyParameters;
            if (!previousInject) {
                target.inject = autoInject;
            } else {
                for (var i = 0; i < autoInject.length; i++) {
                    if (previousInject[i] && previousInject[i] !== autoInject[i]) {
                        var prevIndex = previousInject.indexOf(autoInject[i]);
                        if (prevIndex > -1) {
                            previousInject.splice(prevIndex, 1);
                        }
                        previousInject.splice(prevIndex > -1 && prevIndex < i ? i - 1 : i, 0, autoInject[i]);
                    } else if (!previousInject[i]) {
                        previousInject[i] = autoInject[i];
                    }
                }
            }
        };
        return potentialTarget ? deco(potentialTarget) : deco;
    }
    function inject() {
        for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            rest[_key5] = arguments[_key5];
        }
        return function (target, key, descriptor) {
            if (typeof descriptor === 'number' && rest.length === 1) {
                var params = target.inject;
                if (typeof params === 'function') {
                    throw new Error('Decorator inject cannot be used with "inject()".  Please use an array instead.');
                }
                if (!params) {
                    params = metadata.getOwn(metadata.paramTypes, target).slice();
                    target.inject = params;
                }
                params[descriptor] = rest[0];
                return;
            }
            if (descriptor) {
                var _fn = descriptor.value;
                _fn.inject = rest;
            } else {
                target.inject = rest;
            }
        };
    }

    function removeBeforeDate(property, time) {
        var times = property._times;
        var index = ~binarySearch(times, time, JulianDate.compare);
        if (index > 0) {
            times.splice(0, index);
            property._values.splice(0, index * property._innerType.packedLength);
            property._updateTableLength = true;
            property._definitionChanged.raiseEvent(property);
        }
    }

    function removeOldSamples(property, maxNumSamples) {
        if (maxNumSamples === undefined) return;
        var removeCount = property._times.length - maxNumSamples;
        if (removeCount > 0) {
            property._times.splice(0, removeCount);
            property._values.splice(0, removeCount * property._innerType.packedLength);
            property._updateTableLength = true;
        }
    }

    function createGuid() {
        var d0 = Math.random() * 0xffffffff | 0;
        var d1 = Math.random() * 0xffffffff | 0;
        var d2 = Math.random() * 0xffffffff | 0;
        var d3 = Math.random() * 0xffffffff | 0;
        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    }

    // @author: YousefED
    // From https://github.com/YousefED/cesium/commit/3791582640b12753c7ebd09efe4d7a032fcbfeca
    /**
     * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
     * retrieved from Mapzen (which are publicly hosted on S3).
     *
     * @alias MapzenTerrariumTerrainProvider
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {String} options.url The base url, e.g.: https://s3.amazonaws.com/elevation-tiles-prod/terrarium/ .
     * @param {Object} [options.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
     * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the terrain
     *                       is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
     *                       is used.
     * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.
     *                    If neither parameter is specified, the WGS84 ellipsoid is used.
     * @param {Credit|String} [options.credit] The credit, which will is displayed on the canvas.
     *
     *
     * @example
     * var terrainProvider = new Cesium.MapzenTerrariumTerrainProvider({
     *   url : 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/',
     * });
     * viewer.terrainProvider = terrainProvider;
     *
     *  @see TerrainProvider
     */
    function MapzenTerrariumTerrainProvider(options) {
        //>>includeStart('debug', pragmas.debug);
        this._token = options.token;
        this._url = options.url;
        this._tilingScheme = options.tilingScheme;
        if (!defined(this._tilingScheme)) {
            /*this._tilingScheme = new GeographicTilingScheme({
                ellipsoid : defaultValue(options.ellipsoid, Ellipsoid.WGS84)
            });*/
            this._tilingScheme = new WebMercatorTilingScheme({
                numberOfLevelZeroTilesX: 1,
                numberOfLevelZeroTilesY: 1,
                ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84)
            });
        }
        this._heightmapWidth = 64;
        this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0));
        this._proxy = options.proxy;
        this._terrainDataStructure = {
            heightScale: 1.0 / 256.0,
            heightOffset: -32768.0,
            elementsPerHeight: 3,
            stride: 4,
            elementMultiplier: 256.0,
            isBigEndian: true,
            lowestEncodedHeight: 0,
            highestEncodedHeight: 256 * 256 * 256 - 1
        };
        this._errorEvent = new Event();
        var credit = options.credit;
        if (typeof credit === 'string') {
            credit = new Credit(credit);
        }
        this._credit = credit;
        this._readyPromise = Promise.resolve(true);
        this._terrainPromises = {};
    }

    function getEventSynthesizier() {
        if (eventSynthesizerFunction) return eventSynthesizerFunction;
        var currentMouseTarget;
        var fireMouseLeaveEvents = function (target, relatedTarget, uievent) {
            if (!target) return;
            var eventInit = {
                view: uievent.view,
                clientX: uievent.clientX,
                clientY: uievent.clientY,
                screenX: uievent.screenX,
                screenY: uievent.screenY,
                relatedTarget: relatedTarget
            };
            // fire mouseout
            eventInit.bubbles = true;
            target.dispatchEvent(new MouseEvent('mouseout', eventInit));
            // fire mouseleave events
            eventInit.bubbles = false;
            var el = target;
            do {
                el.dispatchEvent(new MouseEvent('mouseleave', eventInit));
                el = el['parentElement'];
            } while (el);
        };
        var fireMouseEnterEvents = function (target, relatedTarget, uievent) {
            var eventInit = {
                view: uievent.view,
                clientX: uievent.clientX,
                clientY: uievent.clientY,
                screenX: uievent.screenX,
                screenY: uievent.screenY,
                relatedTarget: relatedTarget
            };
            // fire mouseover
            eventInit.bubbles = true;
            target.dispatchEvent(new MouseEvent('mouseover', eventInit));
            // fire mouseenter events
            eventInit.bubbles = false;
            var el = target;
            do {
                el.dispatchEvent(new MouseEvent('mouseenter', eventInit));
                el = el['parentElement'];
            } while (el);
        };
        var firePointerEnterEvents = function (target, relatedTarget, uievent) {
            var bubbles = uievent.bubbles;
            // fire pointerover event
            uievent.bubbles = true;
            target.dispatchEvent(new PointerEvent('pointerover', uievent));
            // fire pointerenter events
            uievent.bubbles = false;
            var el = target;
            do {
                el.dispatchEvent(new PointerEvent('pointerenter', uievent));
                el = el['parentElement'];
            } while (el);
            uievent.bubbles = bubbles;
        };
        var firePointerLeaveEvents = function (target, relatedTarget, uievent) {
            if (!target) return;
            // fire pointerover event
            uievent.bubbles = true;
            target.dispatchEvent(new PointerEvent('pointerout', uievent));
            // fire pointerenter events
            uievent.bubbles = false;
            var el = target;
            do {
                el.dispatchEvent(new PointerEvent('pointerleave', uievent));
                el = el['parentElement'];
            } while (el);
        };
        var deserializeTouches = function (touches, target, uievent) {
            touches.forEach(function (t, i) {
                if (document.createTouch) {
                    touches[i] = document.createTouch(uievent.view, target, t.identifier, t.clientX, t.clientY, t.screenX, t.screenY);
                } else if (typeof Touch !== undefined) {
                    t.target = target;
                    touches[i] = new Touch(t);
                }
            });
            return touches;
        };
        var touchTargets = {};
        var touchStartTimes = {};
        var pointerTargets = {};
        var capturedPointerTargets = {};
        document.documentElement.addEventListener('gotpointercapture', function (e) {
            capturedPointerTargets[e.pointerId] = e.target;
        });
        document.documentElement.addEventListener('lostpointercapture', function (e) {
            delete capturedPointerTargets[e.pointerId];
        });
        Element.prototype.setPointerCapture = function (id) {
            capturedPointerTargets[id] = this;
        };
        Element.prototype.releasePointerCapture = function (id) {
            capturedPointerTargets[id] = null;
        };
        return eventSynthesizerFunction = function (uievent) {
            uievent.view = window;
            var target;
            switch (uievent.type) {
                case 'wheel':
                    target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                    target.dispatchEvent(new WheelEvent(uievent.type, uievent));
                    break;
                case 'mouseleave':
                    target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                    fireMouseLeaveEvents(currentMouseTarget, undefined, uievent);
                    currentMouseTarget = undefined;
                    break;
                case 'mouseenter':
                    target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                    fireMouseEnterEvents(target, undefined, uievent);
                    currentMouseTarget = target;
                    break;
                case 'mousemove':
                    target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                    if (target !== currentMouseTarget) {
                        fireMouseLeaveEvents(currentMouseTarget, target, uievent);
                        fireMouseEnterEvents(target, currentMouseTarget, uievent);
                        currentMouseTarget = target;
                    }
                    target.dispatchEvent(new MouseEvent(uievent.type, uievent));
                    break;
                case 'touchstart':
                    var primaryTouch = uievent.changedTouches[0];
                    target = document.elementFromPoint(primaryTouch.clientX, primaryTouch.clientY) || window;
                    for (var _i = 0, _a = uievent.changedTouches; _i < _a.length; _i++) {
                        var t = _a[_i];
                        touchTargets[t.identifier] = target;
                        touchStartTimes[t.identifier] = performance.now();
                    }
                case 'touchmove':
                case 'touchend':
                case 'touchcancel':
                    target = touchTargets[uievent.changedTouches[0].identifier];
                    var evt = document.createEvent('TouchEvent');
                    var touches = deserializeTouches(uievent.touches, target, uievent);
                    var targetTouches = deserializeTouches(uievent.targetTouches, target, uievent);
                    var changedTouches = deserializeTouches(uievent.changedTouches, target, uievent);
                    if (document.createTouchList) {
                        touches = document.createTouchList.apply(document, touches);
                        targetTouches = document.createTouchList.apply(document, targetTouches);
                        changedTouches = document.createTouchList.apply(document, changedTouches);
                    }
                    // Safari, Firefox: must use initTouchEvent.
                    if (typeof evt['initTouchEvent'] === "function") {
                        evt['initTouchEvent'](uievent.type, uievent.bubbles, uievent.cancelable, uievent.view, uievent.detail, uievent.screenX, uievent.screenY, uievent.clientX, uievent.clientY, uievent.ctrlKey, uievent.altKey, uievent.shiftKey, uievent.metaKey, touches, targetTouches, changedTouches, 1.0, 0.0);
                    } else if ('TouchEvent' in window && TouchEvent.length > 0) {
                        // Chrome: must use TouchEvent constructor.
                        evt = new TouchEvent(uievent.type, {
                            cancelable: uievent.cancelable,
                            bubbles: uievent.bubbles,
                            touches: touches,
                            targetTouches: targetTouches,
                            changedTouches: changedTouches
                        });
                    } else {
                        evt.initUIEvent(uievent.type, uievent.bubbles, uievent.cancelable, uievent.view, uievent.detail);
                        evt.touches = touches;
                        evt.targetTouches = targetTouches;
                        evt.changedTouches = changedTouches;
                    }
                    if (uievent.type === 'touchend' || uievent.type == 'touchcancel') {
                        target.dispatchEvent(evt);
                        var primaryTouch_1 = changedTouches[0];
                        uievent.clientX = primaryTouch_1.clientX;
                        uievent.clientY = primaryTouch_1.clientY;
                        uievent.screenX = primaryTouch_1.screenX;
                        uievent.screenY = primaryTouch_1.screenY;
                        uievent.button = 0;
                        uievent.detail = 1;
                        if (uievent.type === 'touchend') {
                            if (performance.now() - touchStartTimes[primaryTouch_1.identifier] < 300 && !evt.defaultPrevented) {
                                target.dispatchEvent(new MouseEvent('mousedown', uievent));
                                target.dispatchEvent(new MouseEvent('mouseup', uievent));
                                target.dispatchEvent(new MouseEvent('click', uievent));
                            }
                        } else {
                            target.dispatchEvent(new MouseEvent('mouseout', uievent));
                        }
                        for (var _b = 0, _c = uievent.changedTouches; _b < _c.length; _b++) {
                            var t = _c[_b];
                            delete touchTargets[t.identifier];
                            delete touchStartTimes[t.identifier];
                        }
                    } else {
                        target.dispatchEvent(evt);
                    }
                    break;
                case 'pointerenter':
                case 'pointerleave':
                case 'pointermove':
                case 'pointercancel':
                case 'pointerdown':
                case 'pointerup':
                    var previousTarget = pointerTargets[uievent.pointerId];
                    var capturedTarget = target = capturedPointerTargets[uievent.pointerId];
                    var isLeaving = uievent.type === 'pointerleave' || uievent.type === 'pointercancel';
                    var pointerEvent = new PointerEvent(uievent.type, uievent);
                    if (capturedTarget) {
                        capturedTarget.dispatchEvent(pointerEvent);
                    } else {
                        target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                        if (target !== previousTarget) {
                            firePointerLeaveEvents(previousTarget, target, uievent);
                            if (!isLeaving) firePointerEnterEvents(target, previousTarget, uievent);
                        }
                        target.dispatchEvent(pointerEvent);
                    }
                    if (isLeaving) {
                        delete pointerTargets[uievent.pointerId];
                    } else {
                        pointerTargets[uievent.pointerId] = target;
                    }
                    break;
                default:
                    target = document.elementFromPoint(uievent.clientX, uievent.clientY) || window;
                    target.dispatchEvent(new MouseEvent(uievent.type, uievent));
            }
        };
    }

    function createEventForwarder$$1(viewService, callback) {
        var forwardEvent = false;
        var eventData = {
            event: UIEvent = undefined,
            forwardEvent: function () {
                forwardEvent = true;
            }
        };
        var uievent = {};
        var handleEvent = function (e) {
            var target = e.target instanceof HTMLElement ? e.target : undefined;
            var width = target && target.clientWidth;
            var height = target && target.clientHeight;
            // prevent undesired default actions over the view element
            if (e.type === 'wheel' || isIOS && e.type === 'touchmove' && e.touches.length === 2) e.preventDefault();
            // contain our events within the viewelement
            e.stopPropagation();
            // if the target element is the view element or an element of similar size,
            // attempt to forward the event (webvr-polyfill makes the canvas 10px larger
            // in each dimension due to an issue with the iOS safari browser, which is why
            // we forward the event for any target that matches the viewport size up to 15px 
            // larger in either dimension)
            if (e.target === viewService.element || width && Math.abs(width - viewService.element.clientWidth) < 15 && height && Math.abs(height - viewService.element.clientHeight) < 15) {
                // If we have a uievent listener attached, then make sure the
                // app explictily asks for events to be forwarded. Otherwise,
                // automatically forward the uievents 
                if (viewService.uiEvent.numberOfListeners > 0) {
                    forwardEvent = false;
                    eventData.event = e;
                    viewService.uiEvent.raiseEvent(eventData);
                    if (!forwardEvent) {
                        // if the app doesn't want to forward the event, 
                        // stop the event propogation immediately so that even a locally-running 
                        // reality viewer cannot process the event
                        e.stopImmediatePropagation();
                        return;
                    }
                }
                // prevent undesired synthetic click
                if (e.type === 'touchstart') e.preventDefault();
                var boundingRect = viewService.element.getBoundingClientRect();
                var touches = cloneTouches(e.touches, boundingRect);
                var changedTouches = cloneTouches(e.changedTouches, boundingRect);
                var targetTouches = cloneTouches(e.targetTouches, boundingRect);
                // Event / UI Event
                uievent.timeStamp = e.timeStamp;
                uievent.type = e.type;
                uievent.bubbles = e.bubbles;
                uievent.cancelable = e.cancelable;
                uievent.which = e.which;
                uievent.detail = e.detail;
                uievent.composed = e['composed'];
                uievent.timeStamp = e.timeStamp;
                // Mouse Event
                uievent.altKey = e.altKey;
                uievent.ctrlKey = e.ctrlKey;
                uievent.metaKey = e.metaKey;
                uievent.button = e.button;
                uievent.buttons = e.buttons;
                uievent.clientX = e.clientX - boundingRect.left;
                uievent.clientY = e.clientY - boundingRect.top;
                uievent.screenX = e.screenX;
                uievent.screenY = e.screenY;
                uievent.movementX = e.movementX;
                uievent.movementY = e.movementY;
                // Wheel Event
                uievent.deltaX = e.deltaX;
                uievent.deltaY = e.deltaY;
                uievent.deltaZ = e.deltaZ;
                uievent.deltaMode = e.deltaMode;
                uievent.wheelDelta = e.wheelDelta;
                uievent.wheelDeltaX = e.wheelDeltaX;
                uievent.wheelDeltaY = e.wheelDeltaY;
                // Touch Event
                uievent.touches = touches;
                uievent.changedTouches = changedTouches;
                uievent.targetTouches = targetTouches;
                // Pointer Events
                uievent.pointerId = e.pointerId;
                uievent.pointerType = e.pointerType;
                uievent.width = e.width;
                uievent.height = e.height;
                uievent.pressure = e.pressure;
                uievent.tiltX = e.tiltX;
                uievent.tiltY = e.tiltY;
                uievent.isPrimary = e.isPrimary;
                callback(uievent);
            } else {
                // if this event is not forwardable, stop propogation immediately
                e.stopImmediatePropagation();
            }
        };
        var forwardedEvent = ['wheel', 'click', 'dblclick', 'contextmenu'];
        // if (FeatureDetection.supportsPointerEvents()) {
        forwardedEvent.push('pointerenter', 'pointerleave', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel');
        // } else {
        forwardedEvent.push('mouseenter', 'mouseleave', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchend', 'touchmove', 'touchcancel');
        // }
        forwardedEvent.forEach(function (type) {
            viewService.element.addEventListener(type, handleEvent, false);
        });
    }

    function stringIdentifierFromReferenceFrame(referenceFrame) {
        var rf = referenceFrame;
        return defined(rf.id) ? rf.id : '' + rf;
    }
    function jsonEquals(left, right) {
        return JSON.stringify(left) === JSON.stringify(right);
    }
    /**
     * Computes a 4x4 transformation matrix from a reference frame with an east-up-south axes centered at the provided origin to the provided ellipsoid's fixed reference frame. The local axes are defined as:
     * The x axis points in the local east direction.
     * The y axis points in the points in the direction of the ellipsoid surface normal which passes through the position..
     * The z axis points in the local south direction.
     */

    /**
     * Get array of ancestor reference frames of a Cesium Entity, ordered from
     * farthest ancestor to the passed frame, excluding the passed frame.
     * @param frame A Cesium Entity to get ancestor reference frames.
     * @param frames An array of reference frames of the Cesium Entity.
     */
    function getAncestorReferenceFrames(frame, result) {
        if (result === void 0) {
            result = [];
        }
        var frames = result;
        frames.length = 0;
        var f = frame;
        do {
            var position = f.position;
            f = position && position.referenceFrame;
            if (defined(f)) frames.unshift(f);
        } while (defined(f));
        return frames;
    }

    /**
     * Get array of ancestor reference frames of a Cesium Entity, ordered from
     * farthest ancestor which has a valid pose to the passed frame, excluding the passed frame.
     * @param frame A Cesium Entity to get ancestor reference frames.
     * @param frames An array of reference frames of the Cesium Entity.
     */
    function getReachableAncestorReferenceFrames(frame, time, result) {
        if (result === void 0) {
            result = [];
        }
        var frames = result;
        frames.length = 0;
        var f = frame;
        var isValid = false;
        do {
            var position = f.position;
            var orientation = f && f.orientation;
            f = position && position.referenceFrame;
            var hasParentFrame = defined(f);
            var pValue = hasParentFrame && position && position.getValueInReferenceFrame(time, f, scratchAncestorCartesian);
            var oValue = hasParentFrame && pValue && orientation && orientation.getValue(time, scratchAncestorQuaternion);
            isValid = pValue && oValue;
            if (isValid) frames.unshift(f);
        } while (isValid);
        return frames;
    }
    /**
     * Gets the value of the Position property at the provided time and in the provided reference frame.
     * @param entity The entity to get position.
     * @param time The time for which to retrieve the value.
     * @param referenceFrame The desired referenceFrame of the result.
     * @param result The object to store the value into.
     * @return The modified result parameter.
     */
    function getEntityPositionInReferenceFrame(entity, time, referenceFrame, result) {
        return entity.position && entity.position.getValueInReferenceFrame(time, referenceFrame, result);
    }
    /**
     * Alias of getEntityPositionInReferenceFrame
     */

    /**
     * Get the value of the Orientation property at the provided time and in the provided reference frame.
     * @param entity The entity to get position.
     * @param time The time for which to retrieve the value.
     * @param referenceFrame The desired referenceFrame of the result.
     * @param result The object to store the value into.
     * @return The modified result parameter.
     */
    function getEntityOrientationInReferenceFrame(entity, time, referenceFrame, result) {
        var entityFrame = entity.position && entity.position.referenceFrame;
        if (!defined(entityFrame)) return undefined;
        var orientation = entity.orientation && entity.orientation.getValue(time, result);
        if (!defined(orientation)) return undefined;
        return OrientationProperty.convertToReferenceFrame(time, orientation, entityFrame, referenceFrame, result);
    }
    /**
     * Alias of getEntityOrientationInReferenceFrame
     */

    /**
     * Create a SerializedEntityPose from a source entity.
     * @param entity The entity which the serialized pose represents.
     * @param time The time which to retrieve the pose.
     * @param referenceFrame The reference frame to use for generating the pose.
     * If a target reference frame is not provided, the entity pose will be
     * serialized according to the furthest ancestor frame that resolves to a valid pose.
     * @return An EntityPose object with orientation, position and referenceFrame.
     */
    function getSerializedEntityState(entity, time, frame) {
        var frames = undefined;
        if (!defined(frame)) {
            frames = getReachableAncestorReferenceFrames(entity, time, _scratchFramesArray);
            frame = frames[0];
        }
        if (!defined(frame)) return null;
        if (entity === frame) return null;
        var key = entity.id + '@' + (frame.id ? frame.id : frame);
        var result = _entityStateCache[key];
        if (!result) result = {}, _entityStateCache[key] = result;
        var p = getEntityPositionInReferenceFrame(entity, time, frame, result.p || {});
        if (!p) return null;
        var o = getEntityOrientationInReferenceFrame(entity, time, frame, result.o || {});
        if (!o) return null;
        if (p && o) {
            result.p = p;
            result.o = o;
            result.r = typeof frame === 'number' ? frame : frame.id, result.meta = entity['meta'];
            return result;
        }
        return null;
    }

    /**
     * If urlParser does not have a value, throw error message "resolveURL requires DOM api".
     * If inURL is undefined, throw error message "expected inURL".
     * Otherwise, assign value of inURL to urlParser.href.
     * @param inURL A URL needed to be resolved.
     * @returns A URL ready to be parsed.
     */
    function resolveURL(inURL) {
        if (!urlParser) throw new Error("resolveURL requires DOM api");
        if (inURL === undefined) throw new Error('Expected inURL');
        urlParser.href = '';
        urlParser.href = inURL;
        return urlParser.href;
    }
    /**
     * Parse URL to an object describing details of the URL with href, protocol,
     * hostname, port, pathname, search, hash, host.
     * @param inURL A URL needed to be parsed.
     * @return An object showing parsed URL with href, protocol,
     * hostname, port, pathname, search, hash, host.
     */
    function parseURL(inURL) {
        if (!urlParser) throw new Error("parseURL requires DOM api");
        if (inURL === undefined) throw new Error('Expected inURL');
        urlParser.href = '';
        urlParser.href = inURL;
        return {
            href: urlParser.href,
            protocol: urlParser.protocol,
            hostname: urlParser.hostname,
            port: urlParser.port,
            pathname: urlParser.pathname,
            search: urlParser.search,
            hash: urlParser.hash,
            host: urlParser.host
        };
    }
    function resolveElement(elementOrSelector) {
        if (elementOrSelector instanceof HTMLElement) {
            return Promise.resolve(elementOrSelector);
        } else {
            return new Promise(function (resolve, reject) {
                var resolveElement = function () {
                    var e = document.querySelector("" + elementOrSelector);
                    if (!e) reject(new Error("Unable to resolve element id " + elementOrSelector));else resolve(e);
                };
                if (document.readyState == 'loading') {
                    document.addEventListener('DOMContentLoaded', resolveElement);
                } else {
                    resolveElement();
                }
            });
        }
    }
    function decomposePerspectiveOffCenterProjectionMatrix(mat, result) {
        var m11 = mat[Matrix4.COLUMN0ROW0];
        // const m12 = mat[Matrix4.COLUMN0ROW1];
        var m22 = mat[Matrix4.COLUMN1ROW1];
        var m31 = mat[Matrix4.COLUMN2ROW0];
        var m32 = mat[Matrix4.COLUMN2ROW1];
        var m33 = mat[Matrix4.COLUMN2ROW2];
        var m43 = mat[Matrix4.COLUMN3ROW2];
        var near = result.near = m43 / (m33 - 1);
        result.far = m43 / (m33 + 1);
        result.bottom = near * (m32 - 1) / m22;
        result.top = near * (m32 + 1) / m22;
        result.left = near * (m31 - 1) / m11;
        result.right = near * (m31 + 1) / m11;
        return result;
    }

    function decomposePerspectiveProjectionMatrix(mat, result) {
        var f = decomposePerspectiveOffCenterProjectionMatrix(mat, scratchPerspectiveOffCenterFrustum);
        var xOffset = (f.left + f.right) / 2;
        var yOffset = (f.top + f.bottom) / 2;
        var near = f.near;
        var far = f.far;
        // const left = f.left - xOffset;
        var right = f.right - xOffset;
        var top = f.top - yOffset;
        // const bottom = f.bottom - yOffset;
        var aspectRatio = right / top;
        var fovy = 2 * Math.atan(top / near);
        var fov;
        if (aspectRatio < 1) {
            fov = fovy;
        } else {
            fov = Math.atan(Math.tan(fovy * 0.5) * aspectRatio) * 2.0;
        }
        result.near = near;
        result.far = far;
        result.fov = fov;
        result.aspectRatio = aspectRatio;
        result.xOffset = xOffset;
        result.yOffset = yOffset;
        return result;
    }

    /**
     * Convert an Entity's position and orientation properties to a new reference frame.
     * The properties must be constant properties.
     * @param entity The entity to convert.
     * @param time The time which to retrieve the pose up the reference chain.
     * @param referenceFrame The reference frame to convert the position and oriention to.
     * @return a boolean indicating success or failure.  Will be false if either property is
     * not constant, or if either property cannot be converted to the new frame.
     */
    function convertEntityReferenceFrame(entity, time, frame) {
        if (!entity.position || !(entity.position instanceof ConstantPositionProperty) || !entity.orientation || !(entity.orientation instanceof ConstantProperty)) {
            return false;
        }
        if (!getEntityPositionInReferenceFrame(entity, time, frame, scratchCartesian)) {
            return false;
        }
        if (!getEntityOrientationInReferenceFrame(entity, time, frame, scratchOrientation)) {
            return false;
        }
        entity.position.setValue(scratchCartesian, frame);
        entity.orientation.setValue(scratchOrientation);
        return true;
    }

    function installArgonApp() {
        if (isIOS) {
            window.location.href = "https://itunes.apple.com/us/app/argon4/id1089308600?mt=8";
        }
    }
    function openInArgonApp() {
        if (isIOS) {
            window.location.href = "argon4://open?url=" + encodeURIComponent(window.location.href);
        }
    }
    // requestAnimationFrame / cancelAnimationFrame polyfills

    function deprecated$1(alternative) {
        var didPrintWarning = false;
        var decorator = function (target, name, descriptor) {
            var original = descriptor.get || descriptor.value;
            var originalType = typeof descriptor.value === 'function' ? 'function' : 'property';
            var message = "The \"" + name + "\" " + originalType + " is deprecated. ";
            if (alternative) {
                var alternativeType = typeof target[alternative] === 'function' ? 'function' : 'property';
                message += "Please use the \"" + alternative + "\" " + alternativeType + " instead.";
            }
            var wrapped = function () {
                if (!didPrintWarning) {
                    console.warn(message);
                    didPrintWarning = true;
                }
                return original.apply(this, arguments);
            };
            if (descriptor.value) descriptor.value = wrapped;else descriptor.get = wrapped;
            return descriptor;
        };
        return decorator;
    }

    function updateHeightFromTerrain(cartographic) {
        return Promise.resolve(sampleTerrain(defaultTerrainProvider, 15, [cartographic]).then(_valueAtFirstIndex));
    }
    function _valueAtFirstIndex(array) {
        return array[0];
    }

    function extractVersion(versionString) {
        var parts = versionString.split('.');
        for (var i = 0, len = parts.length; i < len; ++i) {
            parts[i] = parseInt(parts[i], 10);
        }
        return parts;
    }
    /**
     * A service which connects this system to the [[REALITY_MANAGER]] via an Android WebView javascript interface.
     */

    function init(elementOrConfig, configurationOrDIContainer, dependencyInjectionContainer) {
        if (ArgonSystem.instance) throw new Error('A shared ArgonSystem instance already exists');
        var element;
        var configuration;
        if (configurationOrDIContainer instanceof Container) {
            configuration = elementOrConfig;
            dependencyInjectionContainer = configurationOrDIContainer;
        } else {
            element = elementOrConfig;
            configuration = configurationOrDIContainer;
        }
        // see if it is the old parameter interface
        if (element && (element['configuration'] || element['container'])) {
            var deprecatedParameters = element;
            if (!configuration && deprecatedParameters['configuration']) configuration = deprecatedParameters['configuration'];
            if (!configuration && deprecatedParameters['container']) dependencyInjectionContainer = deprecatedParameters['container'];
            element = undefined;
        }
        if (!configuration) configuration = {};
        if (!configuration.role) {
            var role = void 0;
            if (typeof HTMLElement === 'undefined') {
                role = Role.REALITY_MANAGER;
            } else if (navigator.userAgent.indexOf('Argon') > 0 || window.top !== window) {
                role = Role.APPLICATION; // TODO: switch to below after several argon-app releases
            } else {
                role = Role.REALITY_MANAGER;
            }
            configuration.role = role;
        }
        if (!dependencyInjectionContainer) dependencyInjectionContainer = new Container();
        dependencyInjectionContainer.registerInstance(ViewElement, element || null);
        return new ArgonConfigurationManager(configuration, dependencyInjectionContainer).container.get(ArgonSystem);
    }
    /**
     * Initialize an [[ArgonSystem]] with the [[REALITY_VIEWER]] role
     */
    function initRealityViewer(configuration, dependencyInjectionContainer) {
        if (configuration === void 0) {
            configuration = {};
        }
        if (dependencyInjectionContainer === void 0) {
            dependencyInjectionContainer = new Container();
        }
        if (ArgonSystem.instance) throw new Error('A shared ArgonSystem instance already exists');
        configuration.role = Role.REALITY_VIEW; // TODO: switch to below after several argon-app releases
        // configuration.role = Role.REALITY_VIEWER;
        configuration['supportsCustomProtocols'] = true;
        configuration['reality.supportsControlPort'] = true; // backwards compat for above
        configuration.protocols = configuration.protocols || [];
        configuration.protocols.push('ar.uievent');
        return new ArgonConfigurationManager(configuration, dependencyInjectionContainer).container.get(ArgonSystem);
    }
    /**
     * @private
     */
    return {
        setters: [function (_) {}, function (_2) {
            AggregateError = _2.AggregateError;
            PLATFORM = _2.PLATFORM;
        }, function (_b2) {
            binarySearch = _b2.default;
        }, function (_3) {
            cesium_Source_DataSources_CallbackProperty_js = _3.default;
        }, function (_4) {
            CameraEventAggregator = _4.default;
        }, function (_5) {
            CameraEventType = _5.default;
        }, function (_a2) {
            cesium_Source_Core_Cartesian2_js = _a2.default;
        }, function (_f2) {
            Cartesian3 = _f2.default;
        }, function (_6) {
            cesium_Source_Core_Cartesian4_js = _6.default;
        }, function (_7) {
            Cartographic = _7.default;
        }, function (_8) {
            cesium_Source_Core_Clock_js = _8.default;
        }, function (_9) {
            cesium_Source_Core_ClockStep_js = _9.default;
        }, function (_10) {
            cesium_Source_DataSources_CompositeEntityCollection_js = _10.default;
        }, function (_e2) {
            ConstantPositionProperty = _e2.default;
        }, function (_11) {
            ConstantProperty = _11.default;
        }, function (_12) {
            defaultValue = _12.default;
        }, function (_13) {
            defined = _13.default;
        }, function (_14) {
            cesium_Source_Core_DeveloperError_js = _14.default;
        }, function (_15) {
            Ellipsoid = _15.default;
        }, function (_a3) {
            Entity = _a3.default;
        }, function (_b3) {
            EntityCollection = _b3.default;
        }, function (_16) {
            Event = _16.default;
        }, function (_17) {
            cesium_Source_Core_ExtrapolationType_js = _17.default;
        }, function (_c2) {
            cesium_Source_Core_FeatureDetection_js = _c2.default;
        }, function (_18) {
            cesium_Source_Core_GeographicProjection_js = _18.default;
        }, function (_e3) {
            cesium_Source_Core_HeadingPitchRoll_js = _e3.default;
        }, function (_d2) {
            cesium_Source_Core_HermitePolynomialApproximation_js = _d2.default;
        }, function (_19) {
            JulianDate = _19.default;
        }, function (_d3) {
            CesiumMath = _d3.default;
        }, function (_20) {
            Matrix3 = _20.default;
        }, function (_21) {
            Matrix4 = _21.default;
        }, function (_e4) {
            OrientationProperty = _e4.default;
        }, function (_f3) {
            PerspectiveFrustum = _f3.default;
        }, function (_22) {
            PerspectiveOffCenterFrustum = _22.default;
        }, function (_23) {
            cesium_Source_DataSources_PositionProperty_js = _23.default;
        }, function (_24) {
            cesium_Source_DataSources_Property_js = _24.default;
        }, function (_25) {
            Quaternion = _25.default;
        }, function (_26) {
            ReferenceEntity = _26.default;
        }, function (_27) {
            ReferenceFrame = _27.default;
        }, function (_28) {
            cesium_Source_DataSources_ReferenceProperty_js = _28.default;
        }, function (_29) {
            SampledPositionProperty = _29.default;
        }, function (_30) {
            SampledProperty = _30.default;
        }, function (_e5) {
            cesium_Source_Core_ScreenSpaceEventHandler_js = _e5.default;
        }, function (_f4) {
            cesium_Source_Core_ScreenSpaceEventType_js = _f4.default;
        }, function (_a4) {
            Transforms = _a4.default;
        }, function (_d4) {
            cesium_Source_Core_Simon1994PlanetaryPositions_js = _d4.default;
        }, function (_31) {
            cesium_Source_Core_PolylinePipeline_js = _31.default;
        }, function (_c3) {
            TerrainProvider = _c3.default;
        }, function (_32) {
            throttleRequestByServer = _32.default;
        }, function (_33) {
            loadImage = _33.default;
        }, function (_c4) {
            WebMercatorTilingScheme = _c4.default;
        }, function (_f5) {
            getImagePixels = _f5.default;
        }, function (_d5) {
            HeightmapTerrainData = _d5.default;
        }, function (_e6) {
            Credit = _e6.default;
        }, function (_f6) {
            sampleTerrain = _f6.default;
        }, function (_34) {
            CardboardUI = _34.default;
        }, function (_35) {}],
        execute: function () {
            _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }return target;
            };

            _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                return typeof obj;
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
            };
            metadata = {
                resource: 'aurelia:resource',
                paramTypes: 'design:paramtypes',
                propertyType: 'design:type',
                properties: 'design:properties',
                get: function get(metadataKey, target, targetKey) {
                    if (!target) {
                        return undefined;
                    }
                    var result = metadata.getOwn(metadataKey, target, targetKey);
                    return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
                },
                getOwn: function getOwn(metadataKey, target, targetKey) {
                    if (!target) {
                        return undefined;
                    }
                    return Reflect.getOwnMetadata(metadataKey, target, targetKey);
                },
                define: function define(metadataKey, metadataValue, target, targetKey) {
                    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
                },
                getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
                    var result = metadata.getOwn(metadataKey, target, targetKey);
                    if (result === undefined) {
                        result = new Type();
                        Reflect.defineMetadata(metadataKey, result, target, targetKey);
                    }
                    return result;
                }
            };
            originStorage = new Map();
            unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

            Origin = function () {
                function Origin(moduleId, moduleMember) {
                    this.moduleId = moduleId;
                    this.moduleMember = moduleMember;
                }
                Origin.get = function get(fn) {
                    var origin = originStorage.get(fn);
                    if (origin === undefined) {
                        PLATFORM.eachModule(function (key, value) {
                            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                                for (var name in value) {
                                    var exp = value[name];
                                    if (exp === fn) {
                                        originStorage.set(fn, origin = new Origin(key, name));
                                        return true;
                                    }
                                }
                            }
                            if (value === fn) {
                                originStorage.set(fn, origin = new Origin(key, 'default'));
                                return true;
                            }
                            return false;
                        });
                    }
                    return origin || unknownOrigin;
                };
                Origin.set = function set(fn, origin) {
                    originStorage.set(fn, origin);
                };
                return Origin;
            }();

            protocol.create = function (name, options) {
                options = ensureProtocolOptions(options);
                var hidden = 'protocol:' + name;
                var result = function result(target) {
                    var decorator = protocol(name, options);
                    return target ? decorator(target) : decorator;
                };
                result.decorates = function (obj) {
                    return obj[hidden] === true;
                };
                result.validate = createProtocolValidator(options.validate);
                result.assert = createProtocolAsserter(name, options.validate);
                return result;
            };

            resolver = protocol.create('aurelia:resolver', function (target) {
                if (!(typeof target.get === 'function')) {
                    return 'Resolvers must implement: get(container: Container, key: any): any';
                }
                return true;
            });
            Lazy = (_dec = resolver(), _dec(_class = function () {
                function Lazy(key) {
                    this._key = key;
                }
                Lazy.prototype.get = function get(container) {
                    var _this = this;
                    return function () {
                        return container.get(_this._key);
                    };
                };
                Lazy.of = function of(key) {
                    return new Lazy(key);
                };
                return Lazy;
            }()) || _class);
            All = (_dec2 = resolver(), _dec2(_class3 = function () {
                function All(key) {
                    this._key = key;
                }
                All.prototype.get = function get(container) {
                    return container.getAll(this._key);
                };
                All.of = function of(key) {
                    return new All(key);
                };
                return All;
            }()) || _class3);
            Optional = (_dec3 = resolver(), _dec3(_class5 = function () {
                function Optional(key) {
                    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
                    this._key = key;
                    this._checkParent = checkParent;
                }
                Optional.prototype.get = function get(container) {
                    if (container.hasResolver(this._key, this._checkParent)) {
                        return container.get(this._key);
                    }
                    return null;
                };
                Optional.of = function of(key) {
                    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
                    return new Optional(key, checkParent);
                };
                return Optional;
            }()) || _class5);
            Parent = (_dec4 = resolver(), _dec4(_class7 = function () {
                function Parent(key) {
                    this._key = key;
                }
                Parent.prototype.get = function get(container) {
                    return container.parent ? container.parent.get(this._key) : null;
                };
                Parent.of = function of(key) {
                    return new Parent(key);
                };
                return Parent;
            }()) || _class7);
            StrategyResolver = (_dec5 = resolver(), _dec5(_class9 = function () {
                function StrategyResolver(strategy, state) {
                    this.strategy = strategy;
                    this.state = state;
                }
                StrategyResolver.prototype.get = function get(container, key) {
                    switch (this.strategy) {
                        case 0:
                            return this.state;
                        case 1:
                            var singleton = container.invoke(this.state);
                            this.state = singleton;
                            this.strategy = 0;
                            return singleton;
                        case 2:
                            return container.invoke(this.state);
                        case 3:
                            return this.state(container, key, this);
                        case 4:
                            return this.state[0].get(container, key);
                        case 5:
                            return container.get(this.state);
                        default:
                            throw new Error('Invalid strategy: ' + this.strategy);
                    }
                };
                return StrategyResolver;
            }()) || _class9);
            Factory = (_dec6 = resolver(), _dec6(_class11 = function () {
                function Factory(key) {
                    this._key = key;
                }
                Factory.prototype.get = function get(container) {
                    var _this2 = this;
                    return function () {
                        for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
                            rest[_key] = arguments[_key];
                        }
                        return container.invoke(_this2._key, rest);
                    };
                };
                Factory.of = function of(key) {
                    return new Factory(key);
                };
                return Factory;
            }()) || _class11);
            NewInstance = (_dec7 = resolver(), _dec7(_class13 = function () {
                function NewInstance(key) {
                    this.key = key;
                    this.asKey = key;
                    for (var _len2 = arguments.length, dynamicDependencies = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        dynamicDependencies[_key2 - 1] = arguments[_key2];
                    }
                    this.dynamicDependencies = dynamicDependencies;
                }
                NewInstance.prototype.get = function get(container) {
                    var dynamicDependencies = this.dynamicDependencies.length > 0 ? this.dynamicDependencies.map(function (dependency) {
                        return dependency['protocol:aurelia:resolver'] ? dependency.get(container) : container.get(dependency);
                    }) : undefined;
                    var instance = container.invoke(this.key, dynamicDependencies);
                    container.registerInstance(this.asKey, instance);
                    return instance;
                };
                NewInstance.prototype.as = function as(key) {
                    this.asKey = key;
                    return this;
                };
                NewInstance.of = function of(key) {
                    for (var _len3 = arguments.length, dynamicDependencies = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                        dynamicDependencies[_key3 - 1] = arguments[_key3];
                    }
                    return new (Function.prototype.bind.apply(NewInstance, [null].concat([key], dynamicDependencies)))();
                };
                return NewInstance;
            }()) || _class13);

            FactoryInvoker = function () {
                function FactoryInvoker() {}
                FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
                    var i = dependencies.length;
                    var args = new Array(i);
                    while (i--) {
                        args[i] = container.get(dependencies[i]);
                    }
                    return fn.apply(undefined, args);
                };
                FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
                    var i = staticDependencies.length;
                    var args = new Array(i);
                    while (i--) {
                        args[i] = container.get(staticDependencies[i]);
                    }
                    if (dynamicDependencies !== undefined) {
                        args = args.concat(dynamicDependencies);
                    }
                    return fn.apply(undefined, args);
                };
                return FactoryInvoker;
            }();

            FactoryInvoker.instance = new FactoryInvoker();
            TransientRegistration = function () {
                function TransientRegistration(key) {
                    this._key = key;
                }
                TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
                    return container.registerTransient(this._key || key, fn);
                };
                return TransientRegistration;
            }();

            SingletonRegistration = function () {
                function SingletonRegistration(keyOrRegisterInChild) {
                    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
                    if (typeof keyOrRegisterInChild === 'boolean') {
                        this._registerInChild = keyOrRegisterInChild;
                    } else {
                        this._key = keyOrRegisterInChild;
                        this._registerInChild = registerInChild;
                    }
                }
                SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
                    return this._registerInChild ? container.registerSingleton(this._key || key, fn) : container.root.registerSingleton(this._key || key, fn);
                };
                return SingletonRegistration;
            }();

            _emptyParameters = Object.freeze([]);

            metadata.registration = 'aurelia:registration';
            metadata.invoker = 'aurelia:invoker';
            resolverDecorates = resolver.decorates;

            InvocationHandler = function () {
                function InvocationHandler(fn, invoker, dependencies) {
                    this.fn = fn;
                    this.invoker = invoker;
                    this.dependencies = dependencies;
                }
                InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
                    return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
                };
                return InvocationHandler;
            }();

            classInvokers = (_classInvokers = {}, _classInvokers[0] = {
                invoke: function invoke(container, Type) {
                    return new Type();
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers[1] = {
                invoke: function invoke(container, Type, deps) {
                    return new Type(container.get(deps[0]));
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers[2] = {
                invoke: function invoke(container, Type, deps) {
                    return new Type(container.get(deps[0]), container.get(deps[1]));
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers[3] = {
                invoke: function invoke(container, Type, deps) {
                    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers[4] = {
                invoke: function invoke(container, Type, deps) {
                    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers[5] = {
                invoke: function invoke(container, Type, deps) {
                    return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
                },
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers.fallback = {
                invoke: invokeWithDynamicDependencies,
                invokeWithDynamicDependencies: invokeWithDynamicDependencies
            }, _classInvokers);

            Container = function () {
                function Container(configuration) {
                    if (configuration === undefined) {
                        configuration = {};
                    }
                    this._configuration = configuration;
                    this._onHandlerCreated = configuration.onHandlerCreated;
                    this._handlers = configuration.handlers || (configuration.handlers = new Map());
                    this._resolvers = new Map();
                    this.root = this;
                    this.parent = null;
                }
                Container.prototype.makeGlobal = function makeGlobal() {
                    Container.instance = this;
                    return this;
                };
                Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
                    this._onHandlerCreated = onHandlerCreated;
                    this._configuration.onHandlerCreated = onHandlerCreated;
                };
                Container.prototype.registerInstance = function registerInstance(key, instance) {
                    return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
                };
                Container.prototype.registerSingleton = function registerSingleton(key, fn) {
                    return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
                };
                Container.prototype.registerTransient = function registerTransient(key, fn) {
                    return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
                };
                Container.prototype.registerHandler = function registerHandler(key, handler) {
                    return this.registerResolver(key, new StrategyResolver(3, handler));
                };
                Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
                    return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
                };
                Container.prototype.registerResolver = function registerResolver(key, resolver) {
                    validateKey(key);
                    var allResolvers = this._resolvers;
                    var result = allResolvers.get(key);
                    if (result === undefined) {
                        allResolvers.set(key, resolver);
                    } else if (result.strategy === 4) {
                        result.state.push(resolver);
                    } else {
                        allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
                    }
                    return resolver;
                };
                Container.prototype.autoRegister = function autoRegister(key, fn) {
                    fn = fn === undefined ? key : fn;
                    if (typeof fn === 'function') {
                        var _registration = metadata.get(metadata.registration, fn);
                        if (_registration === undefined) {
                            return this.registerResolver(key, new StrategyResolver(1, fn));
                        }
                        return _registration.registerResolver(this, key, fn);
                    }
                    return this.registerResolver(key, new StrategyResolver(0, fn));
                };
                Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
                    var i = fns.length;
                    while (i--) {
                        this.autoRegister(fns[i]);
                    }
                };
                Container.prototype.unregister = function unregister(key) {
                    this._resolvers.delete(key);
                };
                Container.prototype.hasResolver = function hasResolver(key) {
                    var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
                    validateKey(key);
                    return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
                };
                Container.prototype.get = function get(key) {
                    validateKey(key);
                    if (key === Container) {
                        return this;
                    }
                    if (resolverDecorates(key)) {
                        return key.get(this, key);
                    }
                    var resolver = this._resolvers.get(key);
                    if (resolver === undefined) {
                        if (this.parent === null) {
                            return this.autoRegister(key).get(this, key);
                        }
                        return this.parent._get(key);
                    }
                    return resolver.get(this, key);
                };
                Container.prototype._get = function _get(key) {
                    var resolver = this._resolvers.get(key);
                    if (resolver === undefined) {
                        if (this.parent === null) {
                            return this.autoRegister(key).get(this, key);
                        }
                        return this.parent._get(key);
                    }
                    return resolver.get(this, key);
                };
                Container.prototype.getAll = function getAll(key) {
                    validateKey(key);
                    var resolver = this._resolvers.get(key);
                    if (resolver === undefined) {
                        if (this.parent === null) {
                            return _emptyParameters;
                        }
                        return this.parent.getAll(key);
                    }
                    if (resolver.strategy === 4) {
                        var state = resolver.state;
                        var i = state.length;
                        var results = new Array(i);
                        while (i--) {
                            results[i] = state[i].get(this, key);
                        }
                        return results;
                    }
                    return [resolver.get(this, key)];
                };
                Container.prototype.createChild = function createChild() {
                    var child = new Container(this._configuration);
                    child.root = this.root;
                    child.parent = this;
                    return child;
                };
                Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
                    try {
                        var _handler = this._handlers.get(fn);
                        if (_handler === undefined) {
                            _handler = this._createInvocationHandler(fn);
                            this._handlers.set(fn, _handler);
                        }
                        return _handler.invoke(this, dynamicDependencies);
                    } catch (e) {
                        throw new AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
                    }
                };
                Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
                    var dependencies = void 0;
                    if (fn.inject === undefined) {
                        dependencies = metadata.getOwn(metadata.paramTypes, fn) || _emptyParameters;
                    } else {
                        dependencies = [];
                        var ctor = fn;
                        while (typeof ctor === 'function') {
                            var _dependencies;
                            (_dependencies = dependencies).push.apply(_dependencies, getDependencies(ctor));
                            ctor = Object.getPrototypeOf(ctor);
                        }
                    }
                    var invoker = metadata.getOwn(metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;
                    var handler = new InvocationHandler(fn, invoker, dependencies);
                    return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
                };
                return Container;
            }();

            _export('DI', DI = Object.freeze({
                resolver: resolver,
                Lazy: Lazy,
                All: All,
                Optional: Optional,
                Parent: Parent,
                StrategyResolver: StrategyResolver,
                Factory: Factory,
                NewInstance: NewInstance,
                getDecoratorDependencies: getDecoratorDependencies,
                lazy: lazy,
                all: all,
                optional: optional,
                parent: parent,
                factory: factory,
                newInstance: newInstance,
                invoker: invoker,
                invokeAsFactory: invokeAsFactory,
                FactoryInvoker: FactoryInvoker,
                registration: registration,
                transient: transient,
                singleton: singleton,
                TransientRegistration: TransientRegistration,
                SingletonRegistration: SingletonRegistration,
                _emptyParameters: _emptyParameters,
                InvocationHandler: InvocationHandler,
                Container: Container,
                autoinject: autoinject,
                inject: inject
            }));

            after = function (fn, after) {
                return function () {
                    var result = fn.apply(this, arguments);
                    after.call(this, result);
                    return result;
                };
            };

            SampledProperty.prototype.removeSamplesBeforeDate = function (time) {
                removeBeforeDate(this, time);
            };
            SampledPositionProperty.prototype.removeSamplesBeforeDate = function (time) {
                removeBeforeDate(this._property, time);
            };SampledProperty.prototype.addSample = after(SampledProperty.prototype.addSample, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            SampledProperty.prototype.addSamples = after(SampledProperty.prototype.addSamples, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            SampledProperty.prototype.addSamplesPackedArray = after(SampledProperty.prototype.addSamplesPackedArray, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            SampledPositionProperty.prototype.addSample = after(SampledPositionProperty.prototype.addSample, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });
            SampledPositionProperty.prototype.addSamples = after(SampledPositionProperty.prototype.addSamples, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });
            SampledPositionProperty.prototype.addSamplesPackedArray = after(SampledPositionProperty.prototype.addSamplesPackedArray, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });

            lut = [];

            for (i = 0; i < 256; i++) {
                lut[i] = (i < 16 ? '0' : '') + i.toString(16);
            }
            _export('Cesium', cesiumImports = Object.freeze({
                createGuid: createGuid,
                binarySearch: binarySearch,
                CallbackProperty: cesium_Source_DataSources_CallbackProperty_js,
                CameraEventAggregator: CameraEventAggregator,
                CameraEventType: CameraEventType,
                Cartesian2: cesium_Source_Core_Cartesian2_js,
                Cartesian3: Cartesian3,
                Cartesian4: cesium_Source_Core_Cartesian4_js,
                Cartographic: Cartographic,
                Clock: cesium_Source_Core_Clock_js,
                ClockStep: cesium_Source_Core_ClockStep_js,
                CompositeEntityCollection: cesium_Source_DataSources_CompositeEntityCollection_js,
                ConstantPositionProperty: ConstantPositionProperty,
                ConstantProperty: ConstantProperty,
                defaultValue: defaultValue,
                defined: defined,
                DeveloperError: cesium_Source_Core_DeveloperError_js,
                Ellipsoid: Ellipsoid,
                Entity: Entity,
                EntityCollection: EntityCollection,
                Event: Event,
                ExtrapolationType: cesium_Source_Core_ExtrapolationType_js,
                FeatureDetection: cesium_Source_Core_FeatureDetection_js,
                GeographicProjection: cesium_Source_Core_GeographicProjection_js,
                HeadingPitchRoll: cesium_Source_Core_HeadingPitchRoll_js,
                HermitePolynomialApproximation: cesium_Source_Core_HermitePolynomialApproximation_js,
                JulianDate: JulianDate,
                CesiumMath: CesiumMath,
                Matrix3: Matrix3,
                Matrix4: Matrix4,
                OrientationProperty: OrientationProperty,
                PerspectiveFrustum: PerspectiveFrustum,
                PerspectiveOffCenterFrustum: PerspectiveOffCenterFrustum,
                PositionProperty: cesium_Source_DataSources_PositionProperty_js,
                Property: cesium_Source_DataSources_Property_js,
                Quaternion: Quaternion,
                ReferenceEntity: ReferenceEntity,
                ReferenceFrame: ReferenceFrame,
                ReferenceProperty: cesium_Source_DataSources_ReferenceProperty_js,
                SampledPositionProperty: SampledPositionProperty,
                SampledProperty: SampledProperty,
                ScreenSpaceEventHandler: cesium_Source_Core_ScreenSpaceEventHandler_js,
                ScreenSpaceEventType: cesium_Source_Core_ScreenSpaceEventType_js,
                Transforms: Transforms,
                Simon1994PlanetaryPositions: cesium_Source_Core_Simon1994PlanetaryPositions_js,
                PolylinePipeline: cesium_Source_Core_PolylinePipeline_js,
                TerrainProvider: TerrainProvider,
                throttleRequestByServer: throttleRequestByServer,
                loadImage: loadImage,
                WebMercatorTilingScheme: WebMercatorTilingScheme,
                getImagePixels: getImagePixels,
                HeightmapTerrainData: HeightmapTerrainData,
                Credit: Credit,
                sampleTerrain: sampleTerrain
            }));

            kButtonWidthDp = 28;
            kTouchSlopFactor = 1.5;

            CardboardUI.prototype.listen = function (optionsCallback, backCallback) {
                var canvas = this.gl.canvas;
                this.listener = function (event) {
                    var midline = canvas.clientWidth / 2;
                    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
                    // Check to see if the user clicked on (or around) the gear icon
                    var e = event instanceof TouchEvent ? event.changedTouches[0] : event;
                    if (e.clientX > midline - buttonSize && e.clientX < midline + buttonSize && e.clientY > canvas.clientHeight - buttonSize) {
                        optionsCallback(event);
                    } else if (e.clientX < buttonSize && e.clientY < buttonSize) {
                        backCallback(event);
                    }
                };
                canvas.addEventListener('click', this.listener, false);
                canvas.addEventListener('touchstart', this.listener, false); // for some reason, using `touchend` here breaks touch events in parent DOM elements, whereas touchstart works fine.... seems like a bug in WebKit
            };

            __extends$1 = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            _export('AVERAGE_EYE_HEIGHT', AVERAGE_EYE_HEIGHT = 1.6);

            _export('DEFAULT_NEAR_PLANE', DEFAULT_NEAR_PLANE = 0.01);

            _export('DEFAULT_FAR_PLANE', DEFAULT_FAR_PLANE = 10000);

            (function (Role) {
                /**
                 * A system with this role is responsible for augmenting an arbitrary view of reality,
                 * generally by overlaying computer generated graphics. A reality augmentor may also,
                 * if appropriate, be elevated to the role of a [[REALITY_MANAGER]].
                 */
                Role[Role["REALITY_AUGMENTER"] = "RealityAugmenter"] = "REALITY_AUGMENTER";
                /**
                 * A system with this role is responsible for (at minimum) describing (and providing,
                 * if necessary) a visual representation of the world and the 3D eye pose of the viewer.
                 */
                Role[Role["REALITY_VIEWER"] = "RealityViewer"] = "REALITY_VIEWER";
                /**
                 * A system with this role is responsible for mediating access to sensors/trackers
                 * and pose data for known entities in the world, selecting/configuring/loading
                 * [[REALITY_VIEWER]]s, and providing the mechanism by which any given [[REALITY_AUGMENTER]]
                 * can augment any given [[REALITY_VIEWER]].
                 */
                Role[Role["REALITY_MANAGER"] = "RealityManager"] = "REALITY_MANAGER";
                /**
                 * Deprecated. Use [[REALITY_AUGMENTER]].
                 * @private
                 */
                Role[Role["APPLICATION"] = "Application"] = "APPLICATION";
                /**
                 * Deprecated. Use [[REALITY_MANAGER]].
                 * @private
                 */
                Role[Role["MANAGER"] = "Manager"] = "MANAGER";
                /**
                 * Deprecated. Use [[REALITY_VIEWER]]
                 * @private
                 */
                Role[Role["REALITY_VIEW"] = "RealityView"] = "REALITY_VIEW";
            })(Role || _export('Role', Role = {}));
            (function (Role) {
                function isRealityViewer(r) {
                    return r === Role.REALITY_VIEWER || r === Role.REALITY_VIEW;
                }
                Role.isRealityViewer = isRealityViewer;
                function isRealityAugmenter(r) {
                    return r === Role.REALITY_AUGMENTER || r === Role.APPLICATION;
                }
                Role.isRealityAugmenter = isRealityAugmenter;
                function isRealityManager(r) {
                    return r === Role.REALITY_MANAGER || r === Role.MANAGER;
                }
                Role.isRealityManager = isRealityManager;
            })(Role || _export('Role', Role = {}));
            /**
             * Configuration options for an [[ArgonSystem]]
             */

            _export('Configuration', Configuration = function () {
                function Configuration() {}
                return Configuration;
            }());

            _export('Viewport', Viewport = function () {
                function Viewport() {
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                }
                Viewport.clone = function (viewport, result) {
                    if (result === void 0) {
                        result = new Viewport();
                    }
                    if (!viewport) return undefined;
                    result.x = viewport.x;
                    result.y = viewport.y;
                    result.width = viewport.width;
                    result.height = viewport.height;
                    return result;
                };
                Viewport.equals = function (viewportA, viewportB) {
                    return viewportA && viewportB && CesiumMath.equalsEpsilon(viewportA.x, viewportB.x, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(viewportA.y, viewportB.y, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(viewportA.width, viewportB.width, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(viewportA.height, viewportB.height, CesiumMath.EPSILON7);
                };
                return Viewport;
            }());

            _export('CanvasViewport', CanvasViewport = function (_super) {
                __extends$1(CanvasViewport, _super);
                function CanvasViewport() {
                    var _this = _super.apply(this, arguments) || this;
                    _this.pixelRatio = 1;
                    _this.renderWidthScaleFactor = 1;
                    _this.renderHeightScaleFactor = 1;
                    return _this;
                }
                CanvasViewport.clone = function (viewport, result) {
                    if (result === void 0) {
                        result = new CanvasViewport();
                    }
                    if (!viewport) return undefined;
                    Viewport.clone(viewport, result);
                    result.renderWidthScaleFactor = viewport.renderWidthScaleFactor;
                    result.renderHeightScaleFactor = viewport.renderHeightScaleFactor;
                    return result;
                };
                CanvasViewport.equals = function (viewportA, viewportB) {
                    return viewportA && viewportB && Viewport.equals(viewportA, viewportB) && CesiumMath.equalsEpsilon(viewportA.renderWidthScaleFactor, viewportB.renderWidthScaleFactor, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(viewportA.renderHeightScaleFactor, viewportB.renderHeightScaleFactor, CesiumMath.EPSILON7);
                };
                return CanvasViewport;
            }(Viewport));

            (function (SubviewType) {
                /*
                 * Identities a subview for a handheld display.
                 */
                SubviewType[SubviewType["SINGULAR"] = "Singular"] = "SINGULAR";
                /*
                 * Identifies a subview for the left eye (when the user is wearing an HMD or Viewer)
                 */
                SubviewType[SubviewType["LEFTEYE"] = "LeftEye"] = "LEFTEYE";
                /*
                 * Identifies a subview for the right eye (when the user is wearing an HMD or Viewer)
                 */
                SubviewType[SubviewType["RIGHTEYE"] = "RightEye"] = "RIGHTEYE";
                /*
                 * Identifies a subview for a custom view configuration
                 */
                SubviewType[SubviewType["OTHER"] = "Other"] = "OTHER";
            })(SubviewType || _export('SubviewType', SubviewType = {}));

            (function (SerializedEntityState) {
                function clone(state, result) {
                    if (!state) return null;
                    result = result || {};
                    result.p = Cartesian3.clone(state.p, result.p);
                    result.o = Quaternion.clone(state.o, result.o);
                    result.r = state.r;
                    result.meta = state.meta;
                    return result;
                }
                SerializedEntityState.clone = clone;
            })(SerializedEntityState || _export('SerializedEntityState', SerializedEntityState = {}));

            (function (SerializedSubview) {
                function clone(subview, result) {
                    result = result || {};
                    result.type = subview.type;
                    result.projectionMatrix = Matrix4.clone(subview.projectionMatrix, result.projectionMatrix);
                    result.viewport = Viewport.clone(subview.viewport, result.viewport);
                    // result.pose = subview.pose ? SerializedEntityState.clone(subview.pose, result.pose) : undefined;
                    return result;
                }
                SerializedSubview.clone = clone;
                function equals(left, right) {
                    return left && right && left.type === right.type && Viewport.equals(left.viewport, right.viewport) && Matrix4.equals(left.projectionMatrix, right.projectionMatrix);
                }
                SerializedSubview.equals = equals;
            })(SerializedSubview || _export('SerializedSubview', SerializedSubview = {}));
            // export interface PhysicalViewState {
            //     time: JulianDate,
            //     stagePose: SerializedEntityPose|undefined,
            //     stageHorizontalAccuracy: number|undefined,
            //     stageVerticalAccuracy: number|undefined,
            //     eyePose: SerializedEntityPose|undefined,
            //     eyeCompassAccuracy: number|undefined,
            //     subviews: SerializedSubviewList,
            //     strict:boolean;
            // }
            // export interface ViewState {
            //     /**
            //      * The viewing pose.
            //      */
            //     pose: SerializedEntityState|undefined,
            //     /**
            //      * The viewport to render into. In a DOM environment, 
            //      * the bottom left corner of the document element (document.documentElement) 
            //      * is the origin. 
            //      */
            //     viewport: Viewport,
            //     /**
            //      * The list of subviews to render.
            //      */
            //     subviews:SerializedSubviewList,
            //     /**
            //      * The current field of view (of each subview)
            //      */
            //     fovs: number[]
            // }

            _export('SerializedSubviewList', SerializedSubviewList = function (_super) {
                __extends$1(SerializedSubviewList, _super);
                function SerializedSubviewList() {
                    return _super.call(this) || this;
                }
                SerializedSubviewList.clone = function (subviews, result) {
                    if (!subviews) return undefined;
                    result = result || new SerializedSubviewList();
                    result.length = subviews.length;
                    for (var i = 0; i < subviews.length; i++) {
                        var s = subviews[i];
                        result[i] = SerializedSubview.clone(s, result[i]);
                    }
                    return result;
                };
                return SerializedSubviewList;
            }(Array));

            Object.defineProperties(MapzenTerrariumTerrainProvider.prototype, {
                /**
                 * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
                 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
                 * are passed an instance of {@link TileProviderError}.
                 * @memberof ArcGisImageServerTerrainProvider.prototype
                 * @type {Event}
                 */
                errorEvent: {
                    get: function () {
                        return this._errorEvent;
                    }
                },
                /**
                 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
                 * the source of the terrain.  This function should not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {Credit}
                 */
                credit: {
                    get: function () {
                        return this._credit;
                    }
                },
                /**
                 * Gets the tiling scheme used by this provider.  This function should
                 * not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {GeographicTilingScheme}
                 */
                tilingScheme: {
                    get: function () {
                        return this._tilingScheme;
                    }
                },
                /**
                 * Gets a value indicating whether or not the provider is ready for use.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {Boolean}
                 */
                ready: {
                    get: function () {
                        return true;
                    }
                },
                /**
                 * Gets a promise that resolves to true when the provider is ready for use.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {Promise.<Boolean>}
                 * @readonly
                 */
                readyPromise: {
                    get: function () {
                        return this._readyPromise;
                    }
                },
                /**
                 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
                 * indicates which areas of the globe are water rather than land, so they can be rendered
                 * as a reflective surface with animated waves.  This function should not be
                 * called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {Boolean}
                 */
                hasWaterMask: {
                    get: function () {
                        return false;
                    }
                },
                /**
                 * Gets a value indicating whether or not the requested tiles include vertex normals.
                 * This function should not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
                 * @memberof MapzenTerrariumTerrainProvider.prototype
                 * @type {Boolean}
                 */
                hasVertexNormals: {
                    get: function () {
                        return false;
                    }
                }
            });
            /**
             * Requests the geometry for a given tile.  This function should not be called before
             * {@link MapzenTerrariumTerrainProvider#ready} returns true.  The result includes terrain
             * data and indicates that all child tiles are available.
             *
             * @param {Number} x The X coordinate of the tile for which to request geometry.
             * @param {Number} y The Y coordinate of the tile for which to request geometry.
             * @param {Number} level The level of the tile for which to request geometry.
             * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
             *          returns undefined instead of a promise, it is an indication that too many requests are already
             *          pending and the request will be retried later.
             */
            MapzenTerrariumTerrainProvider.prototype.requestTileGeometry = function (x, y, level, throttleRequests) {
                var url = this._url + level + '/' + x + '/' + y + '.png';
                var proxy = this._proxy;
                if (defined(proxy)) {
                    url = proxy.getURL(url);
                }
                var promise = this._terrainPromises[url];
                if (!promise) {
                    throttleRequests = defaultValue(throttleRequests, true);
                    if (throttleRequests) {
                        promise = throttleRequestByServer(url, loadImage);
                        if (!defined(promise)) {
                            return undefined;
                        }
                    } else {
                        promise = loadImage(url);
                    }
                    this._terrainPromises[url] = promise;
                }
                var that = this;
                return promise.then(function (image) {
                    return new HeightmapTerrainData({
                        buffer: getImagePixels(image, that._heightmapWidth, that._heightmapWidth),
                        width: that._heightmapWidth,
                        height: that._heightmapWidth,
                        childTileMask: level < 16 ? 0 : 15,
                        structure: that._terrainDataStructure
                    });
                });
            };
            /**
             * Gets the maximum geometric error allowed in a tile at a given level.
             *
             * @param {Number} level The tile level for which to get the maximum geometric error.
             * @returns {Number} The maximum geometric error.
             */
            MapzenTerrariumTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {
                return this._levelZeroMaximumGeometricError / (1 << level);
            };
            /**
             * Determines whether data for a tile is available to be loaded.
             *
             * @param {Number} x The X coordinate of the tile for which to request geometry.
             * @param {Number} y The Y coordinate of the tile for which to request geometry.
             * @param {Number} level The level of the tile for which to request geometry.
             * @returns {Boolean} Undefined if not supported, otherwise true or false.
             */
            MapzenTerrariumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {
                return level < 16 ? true : undefined;
            };

            /**
             * Provides the ability raise and subscribe to an event.
             */

            _export('Event', Event$1 = function () {
                function Event$$1() {
                    this._event = new Event();
                    /**
                      * Add an event listener.
                      * @param The function to be executed when the event is raised.
                      * @return A convenience function which removes this event listener when called
                      */
                    this.addEventListener = this._event.addEventListener.bind(this._event);
                    /**
                     * Remove an event listener.
                     * @param The function to be unregistered.
                     * @return True if the listener was removed;
                     * false if the listener and scope are not registered with the event.
                     */
                    this.removeEventListener = this._event.removeEventListener.bind(this._event);
                    /**
                     * Raises the event by calling each registered listener with all supplied arguments.
                     * @param This method takes any number of parameters and passes them through to the listener functions.
                     */
                    this.raiseEvent = this._event.raiseEvent.bind(this._event);
                }
                Object.defineProperty(Event$$1.prototype, "numberOfListeners", {
                    /**
                     * Get the number of listeners currently subscribed to the event.
                     * @return Number of listeners currently subscribed to the event.
                     */
                    get: function () {
                        return this._event.numberOfListeners;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Event$$1;
            }());

            _export('CommandQueue', CommandQueue = function () {
                /**
                 * If errorEvent has 1 listener, outputs the error message to the web console.
                 */
                function CommandQueue() {
                    var _this = this;
                    this._queue = [];
                    this._paused = true;
                    /**
                     * An error event.
                     */
                    this.errorEvent = new Event$1();
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                }
                /**
                 * Push a command to the command queue.
                 * @param command Any command ready to be pushed into the command queue.
                 */
                CommandQueue.prototype.push = function (command, execute) {
                    var _this = this;
                    var result = new Promise(function (resolve, reject) {
                        _this._queue.push({
                            command: command,
                            reject: reject,
                            execute: function () {
                                // console.log('CommandQueue: Executing command ' + command.toString());
                                var result = Promise.resolve().then(command);
                                // result.then(() => { console.log('CommandQueue: DONE ' + command.toString()) });
                                resolve(result);
                                return result;
                            }
                        });
                    });
                    if (execute || !this._paused) this.execute();
                    return result;
                };
                /**
                 * Execute the command queue
                 */
                CommandQueue.prototype.execute = function () {
                    var _this = this;
                    this._paused = false;
                    Promise.resolve().then(function () {
                        if (_this._queue.length > 0 && !_this._currentCommandPending) {
                            _this._executeNextCommand();
                        }
                    });
                };
                /**
                 * Puase the command queue (currently executing commands will still complete)
                 */
                CommandQueue.prototype.pause = function () {
                    this._paused = true;
                };
                /**
                 * Clear commandQueue.
                 */
                CommandQueue.prototype.clear = function () {
                    this._queue.forEach(function (item) {
                        item.reject("Unable to execute.");
                    });
                    this._queue = [];
                };
                CommandQueue.prototype._executeNextCommand = function () {
                    var _this = this;
                    this._currentCommand = undefined;
                    this._currentCommandPending = undefined;
                    if (this._paused) return;
                    var item = this._queue.shift();
                    if (!item) return;
                    this._currentCommand = item.command;
                    this._currentCommandPending = item.execute().then(this._executeNextCommand.bind(this)).catch(function (e) {
                        _this.errorEvent.raiseEvent(e);
                        _this._executeNextCommand();
                    });
                };
                return CommandQueue;
            }());

            _export('MessageChannelLike', MessageChannelLike = function () {
                /**
                 * Create a MessageChannelLike instance.
                 */
                function MessageChannelLike() {
                    var messageChannel = this;
                    var _portsOpen = true;
                    var _port1ready;
                    var _port2ready;
                    var _port1onmessage;
                    _port1ready = new Promise(function (resolve) {
                        messageChannel.port1 = {
                            set onmessage(func) {
                                _port1onmessage = func;
                                resolve();
                            },
                            get onmessage() {
                                return _port1onmessage;
                            },
                            postMessage: function (data) {
                                if (_portsOpen) {
                                    _port2ready.then(function () {
                                        if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
                                    });
                                }
                            },
                            close: function () {
                                _portsOpen = false;
                            }
                        };
                    });
                    var _port2onmessage;
                    _port2ready = new Promise(function (resolve) {
                        messageChannel.port2 = {
                            set onmessage(func) {
                                _port2onmessage = func;
                                resolve();
                            },
                            get onmessage() {
                                return _port2onmessage;
                            },
                            postMessage: function (data) {
                                if (_portsOpen) {
                                    _port1ready.then(function () {
                                        if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
                                    });
                                }
                            },
                            close: function () {
                                _portsOpen = false;
                            }
                        };
                    });
                }
                return MessageChannelLike;
            }());

            _export('SynchronousMessageChannel', SynchronousMessageChannel = function () {
                /**
                 * Create a MessageChannelLike instance.
                 */
                function SynchronousMessageChannel() {
                    var messageChannel = this;
                    var pendingMessages1 = [];
                    var onmessage1 = function (message) {
                        pendingMessages1.push(message);
                    };
                    messageChannel.port1 = {
                        get onmessage() {
                            return onmessage1;
                        },
                        set onmessage(func) {
                            setTimeout(function () {
                                onmessage1 = func;
                                pendingMessages1.forEach(function (data) {
                                    return func(data);
                                });
                                pendingMessages1 = [];
                            }, 0);
                        },
                        postMessage: function (data) {
                            if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
                        },
                        close: function () {
                            messageChannel.port1.onmessage = undefined;
                            messageChannel.port2.onmessage = undefined;
                        }
                    };
                    var pendingMessages2 = [];
                    var onmessage2 = function (message) {
                        pendingMessages2.push(message);
                    };
                    messageChannel.port2 = {
                        get onmessage() {
                            return onmessage2;
                        },
                        set onmessage(func) {
                            onmessage2 = func;
                            pendingMessages2.forEach(function (data) {
                                return func(data);
                            });
                            pendingMessages2 = [];
                        },
                        postMessage: function (data) {
                            if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
                        },
                        close: function () {
                            messageChannel.port1.onmessage = undefined;
                            messageChannel.port2.onmessage = undefined;
                        }
                    };
                }
                return SynchronousMessageChannel;
            }());

            _export('MessageChannelFactory', MessageChannelFactory = function () {
                function MessageChannelFactory() {}
                /**
                 * Create a MessageChannel (or MessageChannelLike) instance.
                 */
                MessageChannelFactory.prototype.create = function () {
                    if (typeof MessageChannel !== 'undefined') return new MessageChannel();else return new MessageChannelLike();
                };
                /**
                 * Create a SynchronousMessageChannel instance.
                 */
                MessageChannelFactory.prototype.createSynchronous = function () {
                    return new SynchronousMessageChannel();
                };
                return MessageChannelFactory;
            }());

            _export('getEventSynthesizier', getEventSynthesizier$1 = typeof document !== 'undefined' && document.createElement ? getEventSynthesizier : function () {
                return undefined;
            });

            cloneTouch = function (touch, boundingRect) {
                return {
                    identifier: touch.identifier,
                    clientX: touch.clientX - boundingRect.left,
                    clientY: touch.clientY - boundingRect.top,
                    screenX: touch.screenX,
                    screenY: touch.screenY
                };
            };

            cloneTouches = function (touches, boundingRect) {
                if (!touches) return undefined;
                var touchList = [];
                for (var i = 0; i < touches.length; i++) {
                    var touch = touches.item(i);
                    touchList[i] = cloneTouch(touch, boundingRect);
                }
                return touchList;
            };

            _export('eastUpSouthToFixedFrame', eastUpSouthToFixedFrame = Transforms.localFrameToFixedFrameGenerator('east', 'up'));

            scratchAncestorCartesian = new Cartesian3();
            scratchAncestorQuaternion = new Quaternion();

            _export('getEntityPosition', getEntityPosition = getEntityPositionInReferenceFrame);

            _export('getEntityOrientation', getEntityOrientation = getEntityOrientationInReferenceFrame);

            _scratchFramesArray = [];
            _entityStateCache = {};
            urlParser = typeof document !== 'undefined' ? document.createElement("a") : undefined;
            scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();
            scratchCartesian = new Cartesian3();
            scratchOrientation = new Quaternion();

            _export('isIOS', isIOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream']);

            lastTime = 0;

            _export('requestAnimationFrame', rAF = typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (callback) {
                var currTime = performance.now();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = setTimeout(function () {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            });

            _export('cancelAnimationFrame', cAF = typeof window !== 'undefined' ? window.cancelAnimationFrame.bind(window) : clearTimeout);

            _export('defaultTerrainProvider', defaultTerrainProvider = new MapzenTerrariumTerrainProvider({
                url: 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/',
                requestWaterMask: true,
                requestVertexNormals: true
            }));

            _export('version', version = "1.2.1");

            __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$1 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            emptyObject = Object.freeze({});

            _export('SessionPort', SessionPort = function () {
                function SessionPort(uri) {
                    var _this = this;
                    this.uri = uri;
                    this.id = createGuid();
                    this._connectEvent = new Event$1();
                    /**
                     * An event which fires when this port has closed
                     */
                    this.closeEvent = new Event$1();
                    /**
                     * An error which fires when an error occurs.
                     */
                    this.errorEvent = new Event$1();
                    /**
                     * A map from topic to message handler.
                     */
                    this.on = {};
                    /**
                     * If true, don't raise an error when receiving a message for an unknown topic
                     */
                    this.suppressErrorOnUnknownTopic = false;
                    this._isOpened = false;
                    this._isConnected = false;
                    this._isClosed = false;
                    this.on[SessionPort.OPEN] = function (info) {
                        if (!info) throw new Error("Session did not provide a configuration (" + _this.uri + ")");
                        if (_this._isConnected) throw new Error("Session has already connected! (" + _this.uri + ")");
                        _this._info = info;
                        _this._version = info.version || [0];
                        _this._isConnected = true;
                        _this._connectEvent.raiseEvent(undefined);
                    };
                    this.on[SessionPort.CLOSE] = function () {
                        _this._isClosed = true;
                        _this._isConnected = false;
                        if (_this.messagePort && _this.messagePort.close) _this.messagePort.close();
                        _this.closeEvent.raiseEvent(undefined);
                    };
                    this.on[SessionPort.ERROR] = function (error) {
                        var e = new Error("Session Error: " + error.message);
                        if (error.stack) e['stack'] = error.stack;
                        _this.errorEvent.raiseEvent(e);
                    };
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                }
                Object.defineProperty(SessionPort.prototype, "connectEvent", {
                    /**
                     * An event which fires when a connection has been
                     * established to the other [[SessionPort]].
                     */
                    get: function () {
                        if (this._isConnected) throw new Error('The connectEvent only fires once and the session is already connected.');
                        return this._connectEvent;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(SessionPort.prototype, "info", {
                    /**
                     * Describes the configuration of the connected session.
                     */
                    get: function () {
                        if (!this.isConnected) {
                            throw new Error('info is not available until the session is connected.');
                        }
                        return this._info;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionPort.prototype, "version", {
                    /**
                     * The version of argon.js which is used by the connecting session.
                     * This property is an empty array until the session connects.
                     */
                    get: function () {
                        if (!defined(this._version)) {
                            throw new Error('version is not available until the session is opened.');
                        }
                        return this._version;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Check if a protocol is supported by this session.
                 */
                SessionPort.prototype.supportsProtocol = function (name$$1, versions) {
                    if (!this._isConnected) throw new Error('Session has not yet connected');
                    var protocols = this.info.protocols;
                    if (!protocols) return false;
                    var supported = false;
                    var foundVersions = new Set();
                    protocols.forEach(function (p) {
                        if (p.indexOf(name$$1) !== -1) {
                            var v = +p.split('@v')[1] || 0;
                            foundVersions.add(v);
                        }
                    });
                    if (versions) {
                        if (Array.isArray(versions)) {
                            versions.forEach(function (v) {
                                if (foundVersions.has(v)) {
                                    supported = true;
                                }
                            });
                        } else {
                            if (foundVersions.has(versions)) {
                                supported = true;
                            }
                        }
                    } else if (!versions) {
                        supported = true;
                    }
                    return supported;
                };
                SessionPort.prototype.whenConnected = function () {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        if (_this.isConnected) resolve();
                        var remove = _this._connectEvent.addEventListener(function () {
                            remove();
                            resolve();
                        });
                    });
                };
                /**
                 * Establish a connection to another [[SessionPort]] via the provided [[MessagePort]] instance.
                 * @param messagePort the message port to post and receive messages.
                 * @param options the configuration which describes this [[ArgonSystem]].
                 */
                SessionPort.prototype.open = function (messagePort, options) {
                    var _this = this;
                    if (this._isClosed) return;
                    if (this._isOpened) throw new Error('Session can only be opened once');
                    if (!options) throw new Error('Session options must be provided');
                    this.messagePort = messagePort;
                    this._isOpened = true;
                    this.messagePort.onmessage = function (evt) {
                        if (_this._isClosed) return;
                        var data = typeof evt.data === 'string' ? JSON.parse(evt.data) : evt.data;
                        var id = data[0];
                        var topic = data[1];
                        var message = data[2] || emptyObject;
                        var expectsResponse = data[3];
                        var handler = _this.on[topic];
                        if (handler && !expectsResponse) {
                            try {
                                var response = handler(message, evt);
                                if (response) console.warn("Handler for " + topic + " returned an unexpected response");
                            } catch (e) {
                                _this.sendError(e);
                                _this.errorEvent.raiseEvent(e);
                            }
                        } else if (handler) {
                            var response = new Promise(function (resolve) {
                                return resolve(handler(message, evt));
                            });
                            Promise.resolve(response).then(function (response) {
                                if (_this._isClosed) return;
                                _this.send(topic + ':resolve:' + id, response);
                            }).catch(function (error) {
                                if (_this._isClosed) return;
                                var errorMessage;
                                if (typeof error === 'string') errorMessage = error;else if (typeof error.message === 'string') errorMessage = error.message;
                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
                            });
                        } else if (!_this.suppressErrorOnUnknownTopic) {
                            var errorMessage = 'Unable to handle message for topic ' + topic + ' (' + _this.uri + ')';
                            if (expectsResponse) {
                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
                            }
                            _this.errorEvent.raiseEvent(new Error(errorMessage));
                        }
                    };
                    this.send(SessionPort.OPEN, options);
                };
                /**
                 * Send a message
                 * @param topic the message topic.
                 * @param message the message to be sent.
                 * @return Return true if the message is posted successfully,
                 * return false if the session is closed.
                 */
                SessionPort.prototype.send = function (topic, message) {
                    if (!this._isOpened) throw new Error('Session must be open to send messages');
                    if (this._isClosed) return false;
                    var id = createGuid();
                    var packet = [id, topic, message];
                    this.messagePort.postMessage(isIOS ? packet : JSON.stringify(packet)); // http://blog.runspired.com/2016/03/15/webworker-performance-benchmarks/
                    return true;
                };
                /**
                 * Send an error message.
                 * @param errorMessage An error message.
                 * @return Return true if the error message is sent successfully,
                 * otherwise, return false.
                 */
                SessionPort.prototype.sendError = function (e) {
                    var errorMessage = e;
                    if (errorMessage instanceof Error) {
                        errorMessage = {
                            message: errorMessage.message,
                            stack: errorMessage['stack']
                        };
                    }
                    return this.send(SessionPort.ERROR, errorMessage);
                };
                /**
                 * Send a request and return a promise for the result.
                 * @param topic the message topic.
                 * @param message the message to be sent.
                 * @return if the session is not opened or is closed, return a rejected promise,
                 * Otherwise, the returned promise is resolved or rejected based on the response.
                 */
                SessionPort.prototype.request = function (topic, message) {
                    var _this = this;
                    if (!this._isOpened || this._isClosed) throw new Error('Session must be open to make requests');
                    var id = createGuid();
                    var resolveTopic = topic + ':resolve:' + id;
                    var rejectTopic = topic + ':reject:' + id;
                    var result = new Promise(function (resolve, reject) {
                        _this.on[resolveTopic] = function (message) {
                            delete _this.on[resolveTopic];
                            delete _this.on[rejectTopic];
                            resolve(message);
                        };
                        _this.on[rejectTopic] = function (message) {
                            delete _this.on[resolveTopic];
                            delete _this.on[rejectTopic];
                            console.warn("Request '" + topic + "' rejected with reason:\n" + message.reason);
                            reject(new Error(message.reason));
                        };
                    });
                    var packet = [id, topic, message, true];
                    this.messagePort.postMessage(isIOS ? packet : JSON.stringify(packet)); // http://blog.runspired.com/2016/03/15/webworker-performance-benchmarks/
                    return result;
                };
                /**
                 * Close the connection to the remote session.
                 */
                SessionPort.prototype.close = function () {
                    if (this._isClosed) return;
                    if (this._isOpened) {
                        this.send(SessionPort.CLOSE);
                    }
                    this._isClosed = true;
                    this._isConnected = false;
                    if (this.messagePort && this.messagePort.close) this.messagePort.close();
                    this.closeEvent.raiseEvent(undefined);
                };
                Object.defineProperty(SessionPort.prototype, "isConnected", {
                    get: function () {
                        return this._isConnected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionPort.prototype, "isClosed", {
                    get: function () {
                        return this._isClosed;
                    },
                    enumerable: true,
                    configurable: true
                });
                return SessionPort;
            }());

            SessionPort.OPEN = 'ar.session.open';
            SessionPort.CLOSE = 'ar.session.close';
            SessionPort.ERROR = 'ar.session.error';
            /**
             * A factory for creating [[SessionPort]] instances.
             */

            _export('SessionPortFactory', SessionPortFactory = function () {
                function SessionPortFactory() {}
                SessionPortFactory.prototype.create = function (uri) {
                    return new SessionPort(uri);
                };
                return SessionPortFactory;
            }());

            _export('ConnectService', ConnectService = function () {
                function ConnectService() {}
                return ConnectService;
            }());

            _export('SessionService', SessionService = function () {
                function SessionService(
                /**
                 * The configuration of this [[ArgonSystem]]
                 */
                configuration, connectService, sessionPortFactory, messageChannelFactory) {
                    var _this = this;
                    this.configuration = configuration;
                    this.connectService = connectService;
                    this.sessionPortFactory = sessionPortFactory;
                    this.messageChannelFactory = messageChannelFactory;
                    /**
                     * The port which handles communication between this session and the manager session.
                     */
                    this.manager = this.createSessionPort('argon:manager');
                    /**
                     * An event that is raised when an error occurs.
                     */
                    this.errorEvent = new Event$1();
                    this._connectEvent = new Event$1();
                    this._managedSessions = [];
                    configuration.version = extractVersion(version);
                    configuration.uri = typeof window !== 'undefined' && window.location ? window.location.href : undefined;
                    configuration.title = typeof document !== 'undefined' ? document.title : undefined;
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                    this.manager.errorEvent.addEventListener(function (error) {
                        _this.errorEvent.raiseEvent(error);
                    });
                    this.manager.closeEvent.addEventListener(function () {
                        _this.managedSessions.forEach(function (s) {
                            s.close();
                        });
                    });
                    Object.freeze(this);
                }
                Object.defineProperty(SessionService.prototype, "connectEvent", {
                    /**
                     * An event that is raised when a managed session is opened.
                     */
                    get: function () {
                        return this._connectEvent;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(SessionService.prototype, "managedSessions", {
                    /**
                     * Manager-only. A collection of ports for each managed session.
                     */
                    get: function () {
                        return this._managedSessions;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Establishes a connection with the [[REALITY_MANAGER]].
                 * Called internally by the composition root ([[ArgonSystem]]).
                 */
                SessionService.prototype.connect = function () {
                    if (this.connectService && this.connectService.connect) {
                        this.connectService.connect(this);
                    } else {
                        console.warn('Argon: Unable to connect to a manager session; a connect service is not available');
                    }
                };
                /**
                 * Manager-only. Creates a [[SessionPort]] that is managed by the current [[ArgonSystem]].
                 * Session ports that are managed will automatically forward open events to
                 * [[SessionService#sessionConnectEvent]] and error events to [[SessionService#errorEvent]].
                 * Other services that are part of the current [[ArgonSystem]] are likely to
                 * add message handlers to a newly connected [[SessionPort]].
                 * @return a new [[SessionPort]] instance
                 */
                SessionService.prototype.addManagedSessionPort = function (uri) {
                    var _this = this;
                    this.ensureIsRealityManager();
                    var session = this.sessionPortFactory.create(uri);
                    session.errorEvent.addEventListener(function (error) {
                        _this.errorEvent.raiseEvent(error);
                    });
                    session.connectEvent.addEventListener(function () {
                        _this.managedSessions.push(session);
                        _this.connectEvent.raiseEvent(session);
                    });
                    session.closeEvent.addEventListener(function () {
                        var index = _this.managedSessions.indexOf(session);
                        if (index > -1) _this.managedSessions.splice(index, 1);
                    });
                    return session;
                };
                /**
                 * Creates a [[SessionPort]] that is not managed by the current [[ArgonSystem]].
                 * Unmanaged session ports will not forward open events or error events
                 * to this [[ArgonSystem]].
                 * @return a new SessionPort instance
                 */
                SessionService.prototype.createSessionPort = function (uri) {
                    return this.sessionPortFactory.create(uri);
                };
                /**
                 * Creates a message channel which asyncrhonously sends and receives messages.
                 */
                SessionService.prototype.createMessageChannel = function () {
                    return this.messageChannelFactory.create();
                };
                /**
                 * Creates a message channel which syncrhonously sends and receives messages.
                 */
                SessionService.prototype.createSynchronousMessageChannel = function () {
                    return this.messageChannelFactory.createSynchronous();
                };
                Object.defineProperty(SessionService.prototype, "isRealityManager", {
                    /**
                     * Returns true if this system represents a [[REALITY_MANAGER]]
                     */
                    get: function () {
                        return Role.isRealityManager(this.configuration && this.configuration.role);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isRealityAugmenter", {
                    /**
                     * Returns true if this system represents a [[REALITY_AUGMENTER]], meaning,
                     * it is running within a [[REALITY_MANAGER]]
                     */
                    get: function () {
                        return Role.isRealityAugmenter(this.configuration && this.configuration.role);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isRealityViewer", {
                    /**
                     * Returns true if this system is a [[REALITY_VIEWER]]
                     */
                    get: function () {
                        return Role.isRealityViewer(this.configuration && this.configuration.role);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isManager", {
                    /**
                     * @private
                     */
                    get: function () {
                        return this.isRealityManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isApplication", {
                    /**
                     * @private
                     */
                    get: function () {
                        return this.isRealityAugmenter;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isRealityView", {
                    /**
                     * @private
                     */
                    get: function () {
                        return this.isRealityViewer;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Throws an error if this system is not a [[REALITY_MANAGER]]
                 */
                SessionService.prototype.ensureIsRealityManager = function () {
                    if (!this.isRealityManager) throw new Error('An reality-manager only API was accessed from a non reality-manager.');
                };
                /**
                 * Throws an error if this session is not a [[REALITY_VIEWER]]
                 */
                SessionService.prototype.ensureIsRealityViewer = function () {
                    if (!this.isRealityViewer) throw new Error('An reality-viewer only API was accessed from a non reality-viewer.');
                };
                /**
                 * Throws an error if this session is a [[REALITY_VIEWER]]
                 */
                SessionService.prototype.ensureNotRealityViewer = function () {
                    if (this.isRealityViewer) throw new Error('An non-permitted API was accessed from a reality-viewer.');
                };
                /**
                 * Throws an error if this session is a [[REALITY_AUGMENTER]]
                 */
                SessionService.prototype.ensureNotRealityAugmenter = function () {
                    if (this.isRealityAugmenter) throw new Error('An non-permitted API was accessed from a reality-viewer.');
                };
                /**
                 * Throws an error if the connection to the manager is closed
                 */
                SessionService.prototype.ensureConnected = function () {
                    if (!this.manager.isConnected) throw new Error('Session is not connected to manager');
                };
                return SessionService;
            }());

            __decorate$1([deprecated$1('isRealityManager'), __metadata$1("design:type", Object), __metadata$1("design:paramtypes", [])], SessionService.prototype, "isManager", null);
            __decorate$1([deprecated$1('isRealityAugmenter'), __metadata$1("design:type", Object), __metadata$1("design:paramtypes", [])], SessionService.prototype, "isApplication", null);
            __decorate$1([deprecated$1('isRealityViewer'), __metadata$1("design:type", Object), __metadata$1("design:paramtypes", [])], SessionService.prototype, "isRealityView", null);
            _export('SessionService', SessionService = __decorate$1([autoinject, __metadata$1("design:paramtypes", [typeof (_a$1 = typeof Configuration !== "undefined" && Configuration) === "function" && _a$1 || Object, ConnectService, SessionPortFactory, typeof (_b$1 = typeof MessageChannelFactory !== "undefined" && MessageChannelFactory) === "function" && _b$1 || Object])], SessionService));
            /**
             * Connect the current [[ArgonSystem]] to itself as the [[REALITY_MANAGER]].
             */

            _export('LoopbackConnectService', LoopbackConnectService = function (_super) {
                __extends(LoopbackConnectService, _super);
                function LoopbackConnectService() {
                    return _super.apply(this, arguments) || this;
                }
                /**
                 * Create a loopback connection.
                 */
                LoopbackConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    var messagePort = messageChannel.port1;
                    messageChannel.port2.onmessage = function (evt) {
                        messageChannel.port2.postMessage(evt.data);
                    };
                    sessionService.manager.connectEvent.addEventListener(function () {
                        sessionService.connectEvent.raiseEvent(sessionService.manager);
                    });
                    sessionService.manager.open(messagePort, sessionService.configuration);
                };
                return LoopbackConnectService;
            }(ConnectService));

            _export('DOMConnectService', DOMConnectService = function (_super) {
                __extends(DOMConnectService, _super);
                function DOMConnectService() {
                    return _super.apply(this, arguments) || this;
                }
                /**
                  * Check whether this connect method is available or not.
                  */
                DOMConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && typeof window.parent !== 'undefined';
                };
                /**
                 * Connect to the manager.
                 */
                DOMConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createMessageChannel();
                    window.parent.postMessage({ type: 'ARGON_SESSION', name: window.name }, '*', [messageChannel.port1]);
                    sessionService.manager.open(messageChannel.port2, sessionService.configuration);
                };
                return DOMConnectService;
            }(ConnectService));

            _export('DebugConnectService', DebugConnectService = function (_super) {
                __extends(DebugConnectService, _super);
                function DebugConnectService() {
                    return _super.apply(this, arguments) || this;
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                DebugConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && !!window['__ARGON_DEBUG_PORT__'];
                };
                /**
                 * Connect to the manager.
                 */
                DebugConnectService.prototype.connect = function (_a) {
                    var manager = _a.manager,
                        configuration = _a.configuration;
                    manager.open(window['__ARGON_DEBUG_PORT__'], configuration);
                };
                return DebugConnectService;
            }(ConnectService));

            _export('SessionConnectService', SessionConnectService = function (_super) {
                __extends(SessionConnectService, _super);
                function SessionConnectService(session, parentConfiguration) {
                    var _this = _super.call(this) || this;
                    _this.session = session;
                    _this.parentConfiguration = parentConfiguration;
                    return _this;
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                SessionConnectService.isAvailable = function () {
                    return true;
                };
                /**
                 * Connect to the manager.
                 */
                SessionConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    this.session.open(messageChannel.port1, this.parentConfiguration);
                    sessionService.manager.open(messageChannel.port2, sessionService.configuration);
                };
                return SessionConnectService;
            }(ConnectService));

            _export('WKWebViewConnectService', WKWebViewConnectService = function (_super) {
                __extends(WKWebViewConnectService, _super);
                function WKWebViewConnectService() {
                    return _super.apply(this, arguments) || this;
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                WKWebViewConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && window['webkit'] && window['webkit'].messageHandlers;
                };
                /**
                 * Connect to the manager.
                 */
                WKWebViewConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    messageChannel.port2.onmessage = function (event) {
                        webkit.messageHandlers.argon.postMessage(JSON.stringify(event.data));
                    };
                    window['__ARGON_PORT__'] = messageChannel.port2;
                    sessionService.manager.open(messageChannel.port1, sessionService.configuration);
                    window.addEventListener("beforeunload", function () {
                        sessionService.manager.close();
                    });
                };
                return WKWebViewConnectService;
            }(ConnectService));

            _export('AndroidWebViewConnectService', AndroidWebViewConnectService = function (_super) {
                __extends(AndroidWebViewConnectService, _super);
                function AndroidWebViewConnectService() {
                    return _super.apply(this, arguments) || this;
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                AndroidWebViewConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && window["__argon_android__"];
                };
                /**
                 * Connect to the manager.
                 */
                AndroidWebViewConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    messageChannel.port2.onmessage = function (event) {
                        window["__argon_android__"].emit("argon", JSON.stringify(event.data));
                    };
                    window['__ARGON_PORT__'] = messageChannel.port2;
                    sessionService.manager.open(messageChannel.port1, sessionService.configuration);
                    window.addEventListener("beforeunload", function () {
                        sessionService.manager.close();
                    });
                };
                return AndroidWebViewConnectService;
            }(ConnectService));

            __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$5 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('PermissionNames', PermissionNames = {
                'ar.stage': 'Location',
                'ar.camera': 'Camera',
                'ar.3dmesh': 'Structural mesh'
            });

            PermissionDescriptions = {
                'ar.stage': 'your location',
                'ar.camera': 'your camera',
                'ar.3dmesh': 'the structure of your surroundings'
            };

            _export('Permission', Permission = function () {
                function Permission(type, state) {
                    this.type = type;
                    this.state = state || PermissionState.NOT_REQUIRED;
                }
                Object.defineProperty(Permission.prototype, "name", {
                    get: function () {
                        return PermissionNames[this.type];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Permission.prototype, "description", {
                    get: function () {
                        return PermissionDescriptions[this.type];
                    },
                    enumerable: true,
                    configurable: true
                });
                return Permission;
            }());

            (function (PermissionState) {
                PermissionState[PermissionState["NOT_REQUIRED"] = 'not_required'] = "NOT_REQUIRED";
                PermissionState[PermissionState["PROMPT"] = 'prompt'] = "PROMPT";
                PermissionState[PermissionState["GRANTED"] = 'granted'] = "GRANTED";
                PermissionState[PermissionState["DENIED"] = 'denied'] = "DENIED";
            })(PermissionState || _export('PermissionState', PermissionState = {}));
            /**
             * Access permission states
             */

            _export('PermissionService', PermissionService = function () {
                function PermissionService(sessionService) {
                    this.sessionService = sessionService;
                }
                /**
                 * Query current state of permission
                 *
                 * @returns A Promise that resolves to the current state of the permission
                 */
                // public query() : Promise<Permission[]>;
                PermissionService.prototype.query = function (type, session) {
                    if (session === void 0) {
                        session = this.sessionService.manager;
                    }
                    // let permissionMaps: Permission[] = [];
                    return session.request('ar.permission.query', { type: type }).then(function (_a) {
                        var state = _a.state;
                        return state || PermissionState.NOT_REQUIRED;
                    });
                };
                /**
                 * Revoke permissions
                 *
                 * @returns A promise that resolves to the state of requested permission after revoking.
                 * Should be PermissionState.Denied on success.
                 */
                PermissionService.prototype.revoke = function (type) {
                    var session = this.sessionService.manager;
                    return session.request('ar.permission.revoke', { type: type }).then(function (_a) {
                        var state = _a.state;
                        return state;
                    });
                };
                return PermissionService;
            }());

            _export('PermissionService', PermissionService = __decorate$5([autoinject(), __metadata$5("design:paramtypes", [typeof (_a$5 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$5 || Object])], PermissionService));
            /**
             * Manage permissions
             */

            _export('PermissionServiceProvider', PermissionServiceProvider = function () {
                function PermissionServiceProvider(sessionService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.sessionService.ensureIsRealityManager();
                    this.sessionService.connectEvent.addEventListener(function (session) {
                        session.on['ar.permission.query'] = function (_a) {
                            var type = _a.type;
                            return Promise.resolve({ state: _this.getPermissionState(session, type) });
                        };
                        /**
                         * Browswer should override this if they want to allow revoking permissions.
                         * @param type
                         * @returns A promise that resolves to the state of the permission after revoking
                         */
                        session.on['ar.permission.revoke'] = function (_a) {
                            var type = _a.type;
                            return Promise.reject(new Error("Revoking permission is not supported on this browser."));
                        };
                    });
                }
                /**
                 * Browsers should override this and ask the users via their own UI.
                 * The permissions should be stored locally based on the host name and id(=type).
                 * @param session Used to acquire hostname from the uri.
                 * @param id Can be used as a type of permission. Also can be random id's on Vuforia requests.
                 * @returns A resolved promise if subscription is permitted.
                 * @returns A rejected promise if subscription is not permitted.
                 */
                PermissionServiceProvider.prototype.handlePermissionRequest = function (session, id, options) {
                    return Promise.resolve();
                };
                /**
                 * Browsers should override this to check their locally stored permissions.
                 * @param type
                 * @returns The current state of the permission
                 */
                PermissionServiceProvider.prototype.getPermissionState = function (session, type) {
                    return PermissionState.GRANTED;
                };
                return PermissionServiceProvider;
            }());

            _export('PermissionServiceProvider', PermissionServiceProvider = __decorate$5([autoinject(), __metadata$5("design:paramtypes", [typeof (_b$5 = typeof SessionService !== "undefined" && SessionService) === "function" && _b$5 || Object])], PermissionServiceProvider));

            __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$4 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('EntityPose', EntityPose = function () {
                function EntityPose(_collection, entityOrId, referenceFrameId) {
                    this._collection = _collection;
                    /**
                     * The status of this pose, as a bitmask.
                     *
                     * If the current pose is known, then the KNOWN bit is 1.
                     * If the current pose is not known, then the KNOWN bit is 0.
                     *
                     * If the previous pose was known and the current pose is unknown,
                     * then the LOST bit is 1.
                     * If the previous pose was unknown and the current pose status is known,
                     * then the FOUND bit is 1.
                     * In all other cases, both the LOST bit and the FOUND bit are 0.
                     */
                    this.status = 0;
                    this.position = new Cartesian3();
                    this.orientation = new Quaternion();
                    this.time = new JulianDate(0, 0);
                    this._previousStatus = 0;
                    this._getEntityPositionInReferenceFrame = getEntityPositionInReferenceFrame;
                    this._getEntityOrientationInReferenceFrame = getEntityOrientationInReferenceFrame;
                    if (typeof entityOrId === 'string') {
                        var entity = this._collection.getById(entityOrId);
                        if (!entity) entity = new ReferenceEntity(this._collection, entityOrId);
                        this._entity = entity;
                    } else {
                        this._entity = entityOrId;
                    }
                    if (typeof referenceFrameId === 'string') {
                        var referenceFrame = this._collection.getById(referenceFrameId);
                        if (!defined(referenceFrame)) referenceFrame = new ReferenceEntity(this._collection, referenceFrameId);
                        this._referenceFrame = referenceFrame;
                    } else {
                        this._referenceFrame = referenceFrameId;
                    }
                }
                Object.defineProperty(EntityPose.prototype, "entity", {
                    get: function () {
                        return this._entity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityPose.prototype, "referenceFrame", {
                    get: function () {
                        return this._referenceFrame;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityPose.prototype, "poseStatus", {
                    /**
                     * alias for status
                     */
                    get: function () {
                        return this.status;
                    },
                    enumerable: true,
                    configurable: true
                });

                EntityPose.prototype.update = function (time) {
                    var _JulianDate = JulianDate;
                    var _PoseStatus = PoseStatus;
                    _JulianDate.clone(time, this.time);
                    if (!_JulianDate.equals(this._previousTime, time)) {
                        this._previousStatus = this.status;
                        this._previousTime = _JulianDate.clone(time, this._previousTime);
                    }
                    var entity = this.entity;
                    var referenceFrame = this.referenceFrame;
                    var position = this._getEntityPositionInReferenceFrame(entity, time, referenceFrame, this.position);
                    var orientation = this._getEntityOrientationInReferenceFrame(entity, time, referenceFrame, this.orientation);
                    var hasPose = position && orientation;
                    var currentStatus = 0;
                    var previousStatus = this._previousStatus;
                    if (hasPose) {
                        currentStatus |= _PoseStatus.KNOWN;
                    }
                    if (hasPose && !(previousStatus & _PoseStatus.KNOWN)) {
                        currentStatus |= _PoseStatus.FOUND;
                    } else if (!hasPose && previousStatus & _PoseStatus.KNOWN) {
                        currentStatus |= _PoseStatus.LOST;
                    }
                    this.status = currentStatus;
                };
                return EntityPose;
            }());

            (function (PoseStatus) {
                PoseStatus[PoseStatus["KNOWN"] = 1] = "KNOWN";
                PoseStatus[PoseStatus["FOUND"] = 2] = "FOUND";
                PoseStatus[PoseStatus["LOST"] = 4] = "LOST";
            })(PoseStatus || _export('PoseStatus', PoseStatus = {}));
            /**
             * A service for subscribing/unsubscribing to entities
             */

            _export('EntityService', EntityService = function () {
                function EntityService(sessionService) {
                    this.sessionService = sessionService;
                    this.collection = new EntityCollection();
                    this.subscribedEvent = new Event$1();
                    this.unsubscribedEvent = new Event$1();
                    this.subscriptions = new Map();
                    this._scratchCartesian = new Cartesian3();
                    this._scratchQuaternion = new Quaternion();
                    this._scratchMatrix3 = new Matrix3();
                    this._scratchMatrix4 = new Matrix4();
                    this._getEntityPositionInReferenceFrame = getEntityPositionInReferenceFrame;
                }
                EntityService.prototype._handleSubscribed = function (evt) {
                    var s = this.subscriptions.get(evt.id);
                    var stringifiedOptions = evt.options && JSON.stringify(evt.options);
                    if (!s || JSON.stringify(s) === stringifiedOptions) {
                        if (s) this._handleUnsubscribed(evt.id);
                        this.subscriptions.set(evt.id, stringifiedOptions && JSON.parse(stringifiedOptions));
                        this.subscribedEvent.raiseEvent(evt);
                    }
                };
                EntityService.prototype._handleUnsubscribed = function (id) {
                    if (this.subscriptions.has(id)) {
                        this.subscriptions.delete(id);
                        this.unsubscribedEvent.raiseEvent({ id: id });
                    }
                };
                /**
                 * Get the cartographic position of an Entity at the given time
                 */
                EntityService.prototype.getCartographic = function (entity, time, result) {
                    var fixedPosition = this._getEntityPositionInReferenceFrame(entity, time, ReferenceFrame.FIXED, this._scratchCartesian);
                    if (fixedPosition) {
                        result = result || new Cartographic();
                        return Cartographic.fromCartesian(fixedPosition, undefined, result);
                    }
                    return undefined;
                };
                /**
                * Create an entity that is positioned at the given cartographic location,
                * with an orientation computed according to the provided `localToFixed` transform function.
                *
                * For the `localToFixed` parameter, you can pass any of the following:
                *
                * ```
                * Argon.Cesium.Transforms.eastNorthUpToFixedFrame
                * Argon.Cesium.Transforms.northEastDownToFixedFrame
                * Argon.Cesium.Transforms.northUpEastToFixedFrame
                * Argon.Cesium.Transforms.northWestUpToFixedFrame
                * ```
                *
                * Additionally, argon.js provides:
                *
                * ```
                * Argon.eastUpSouthToFixedFrame
                * ```
                *
                * Alternative transform functions can be created with:
                *
                * ```
                * Argon.Cesium.Transforms.localFrameToFixedFrameGenerator
                * ```
                */
                EntityService.prototype.createFixed = function (cartographic, localToFixed) {
                    // Convert the cartographic location to an ECEF position
                    var position = Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, undefined, this._scratchCartesian);
                    // compute an appropriate orientation on the surface of the earth
                    var transformMatrix = localToFixed(position, undefined, this._scratchMatrix4);
                    var rotationMatrix = Matrix4.getRotation(transformMatrix, this._scratchMatrix3);
                    var orientation = Quaternion.fromRotationMatrix(rotationMatrix, this._scratchQuaternion);
                    // create the entity
                    var entity = new Entity({
                        position: position,
                        orientation: orientation
                    });
                    return entity;
                };
                EntityService.prototype.subscribe = function (idOrEntity, options, session) {
                    var _this = this;
                    if (session === void 0) {
                        session = this.sessionService.manager;
                    }
                    var id = idOrEntity.id || idOrEntity;
                    var evt = { id: id, options: options };
                    return session.whenConnected().then(function () {
                        if (session.version[0] === 0 && session.version[1] < 2) return session.request('ar.context.subscribe', evt);else return session.request('ar.entity.subscribe', evt);
                    }).then(function () {
                        var entity = _this.collection.getOrCreateEntity(id);
                        _this._handleSubscribed(evt);
                        return entity;
                    });
                };
                EntityService.prototype.unsubscribe = function (idOrEntity, session) {
                    var _this = this;
                    if (session === void 0) {
                        session = this.sessionService.manager;
                    }
                    var id = idOrEntity.id || idOrEntity;
                    session.whenConnected().then(function () {
                        if (session.version[0] === 0 && session.version[1] < 2) session.send('ar.context.unsubscribe', { id: id });else session.send('ar.entity.unsubscribe', { id: id });
                    }).then(function () {
                        _this._handleUnsubscribed(id);
                    });
                };
                /**
                 * Create a new EntityPose instance to represent the pose of an entity
                 * relative to a given reference frame. If no reference frame is specified,
                 * then the pose is based on the context's defaultReferenceFrame.
                 *
                 * @param entity - the entity to track
                 * @param referenceFrameOrId - the reference frame to use
                 */
                EntityService.prototype.createEntityPose = function (entityOrId, referenceFrameOrId) {
                    return new EntityPose(this.collection, entityOrId, referenceFrameOrId);
                };
                /**
                 *
                 * @param id
                 * @param entityState
                 */
                EntityService.prototype.updateEntityFromSerializedState = function (id, entityState) {
                    var entity = this.collection.getOrCreateEntity(id);
                    if (!entityState) {
                        if (entity.position) {
                            entity.position.setValue(undefined);
                        }
                        if (entity.orientation) {
                            entity.orientation.setValue(undefined);
                        }
                        entity['meta'] = undefined;
                        return entity;
                    }
                    var positionValue = entityState.p;
                    var orientationValue = Quaternion.clone(entityState.o, this._scratchQuaternion); // workaround for https://github.com/AnalyticalGraphicsInc/cesium/issues/5031
                    var referenceFrame = typeof entityState.r === 'number' ? entityState.r : this.collection.getOrCreateEntity(entityState.r);
                    var entityPosition = entity.position;
                    var entityOrientation = entity.orientation;
                    if (entityPosition instanceof ConstantPositionProperty) {
                        entityPosition.setValue(positionValue, referenceFrame);
                    } else {
                        entity.position = new ConstantPositionProperty(positionValue, referenceFrame);
                    }
                    if (entityOrientation instanceof ConstantProperty) {
                        entityOrientation.setValue(orientationValue);
                    } else {
                        entity.orientation = new ConstantProperty(orientationValue);
                    }
                    entity['meta'] = entityState.meta;
                    return entity;
                };
                return EntityService;
            }());

            _export('EntityService', EntityService = __decorate$4([autoinject(), __metadata$4("design:paramtypes", [typeof (_a$4 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$4 || Object])], EntityService));
            /**
             * A service for publishing entity states to managed sessions
             */

            _export('EntityServiceProvider', EntityServiceProvider = function () {
                function EntityServiceProvider(sessionService, entityService, permissionServiceProvider) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.entityService = entityService;
                    this.permissionServiceProvider = permissionServiceProvider;
                    this.subscriptionsBySubscriber = new WeakMap();
                    this.subscribersByEntity = new Map();
                    this.sessionSubscribedEvent = new Event$1();
                    this.sessionUnsubscribedEvent = new Event$1();
                    this.targetReferenceFrameMap = new Map();
                    this._cacheTime = new JulianDate(0, 0);
                    this._entityPoseCache = {};
                    this._getSerializedEntityState = getSerializedEntityState;
                    this.sessionService.ensureIsRealityManager();
                    this.sessionService.connectEvent.addEventListener(function (session) {
                        var subscriptions = new Map();
                        _this.subscriptionsBySubscriber.set(session, subscriptions);
                        session.on['ar.entity.subscribe'] = session.on['ar.context.subscribe'] = function (_a) {
                            var id = _a.id,
                                options = _a.options;
                            var currentOptions = subscriptions.get(id);
                            if (currentOptions && jsonEquals(currentOptions, options)) return;
                            var subscribers = _this.subscribersByEntity.get(id) || new Set();
                            _this.subscribersByEntity.set(id, subscribers);
                            subscribers.add(session);
                            subscriptions.set(id, options);
                            _this.sessionSubscribedEvent.raiseEvent({ session: session, id: id, options: options });
                            return _this.permissionServiceProvider.handlePermissionRequest(session, id, options).then(function () {});
                        };
                        session.on['ar.entity.unsubscribe'] = session.on['ar.context.unsubscribe'] = function (_a) {
                            var id = _a.id;
                            if (!subscriptions.has(id)) return;
                            var subscribers = _this.subscribersByEntity.get(id);
                            subscribers && subscribers.delete(session);
                            subscriptions.delete(id);
                            _this.sessionUnsubscribedEvent.raiseEvent({ id: id, session: session });
                        };
                        session.closeEvent.addEventListener(function () {
                            _this.subscriptionsBySubscriber.delete(session);
                            subscriptions.forEach(function (options, id) {
                                var subscribers = _this.subscribersByEntity.get(id);
                                subscribers && subscribers.delete(session);
                                _this.sessionUnsubscribedEvent.raiseEvent({ id: id, session: session });
                            });
                        });
                    });
                }
                EntityServiceProvider.prototype.fillEntityStateMapForSession = function (session, time, entities) {
                    var subscriptions = this.subscriptionsBySubscriber.get(session);
                    if (!subscriptions) return;
                    var iter = subscriptions.keys();
                    var item;
                    while (item = iter.next(), !item.done) {
                        var id = item.value;
                        var entity = this.entityService.collection.getById(id);
                        entities[id] = entity ? this.getCachedSerializedEntityState(entity, time) : null;
                    }
                };
                EntityServiceProvider.prototype.getCachedSerializedEntityState = function (entity, time) {
                    if (!entity) return null;
                    var id = entity.id;
                    if (!defined(this._entityPoseCache[id]) || !this._cacheTime.equalsEpsilon(time, 0.000001)) {
                        var referenceFrameId = this.targetReferenceFrameMap.get(id);
                        var referenceFrame = defined(referenceFrameId) && typeof referenceFrameId === 'string' ? this.entityService.collection.getById(referenceFrameId) : defined(referenceFrameId) ? referenceFrameId : this.entityService.collection.getById('ar.stage');
                        this._entityPoseCache[id] = this._getSerializedEntityState(entity, time, referenceFrame);
                    }
                    return this._entityPoseCache[id];
                };
                return EntityServiceProvider;
            }());

            _export('EntityServiceProvider', EntityServiceProvider = __decorate$4([autoinject, __metadata$4("design:paramtypes", [typeof (_b$4 = typeof SessionService !== "undefined" && SessionService) === "function" && _b$4 || Object, EntityService, typeof (_c$3 = typeof PermissionServiceProvider !== "undefined" && PermissionServiceProvider) === "function" && _c$3 || Object])], EntityServiceProvider));

            __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$7 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('FocusService', FocusService = function () {
                function FocusService(sessionService) {
                    var _this = this;
                    /**
                     * An event that is raised when this app has gained focus
                     */
                    this.focusEvent = new Event$1();
                    /**
                     * An event that is raised when this app has lost focus
                     */
                    this.blurEvent = new Event$1();
                    this._hasFocus = false;
                    sessionService.manager.on['ar.focus.state'] = function (_a) {
                        var state = _a.state;
                        if (_this._hasFocus !== state) {
                            _this._hasFocus = state;
                            if (state) {
                                _this.focusEvent.raiseEvent(undefined);
                            } else {
                                _this.blurEvent.raiseEvent(undefined);
                            }
                        }
                    };
                }
                Object.defineProperty(FocusService.prototype, "hasFocus", {
                    /**
                     * True if this app has focus
                     */
                    get: function () {
                        return this._hasFocus;
                    },
                    enumerable: true,
                    configurable: true
                });
                return FocusService;
            }());

            _export('FocusService', FocusService = __decorate$7([inject(SessionService), __metadata$7("design:paramtypes", [typeof (_a$7 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$7 || Object])], FocusService));
            /**
             * Manage focus state
             */

            _export('FocusServiceProvider', FocusServiceProvider = function () {
                function FocusServiceProvider(sessionService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.sessionFocusEvent = new Event$1();
                    sessionService.ensureIsRealityManager();
                    sessionService.manager.connectEvent.addEventListener(function () {
                        setTimeout(function () {
                            if (!_this._session && _this.sessionService.manager.isConnected) _this.session = _this.sessionService.manager;
                        });
                    });
                }
                Object.defineProperty(FocusServiceProvider.prototype, "session", {
                    get: function () {
                        return this._session;
                    },
                    set: function (session) {
                        if (session && !session.isConnected) throw new Error('Only a connected session can be granted focus');
                        var previousFocussedSession = this._session;
                        if (previousFocussedSession !== session) {
                            if (previousFocussedSession) previousFocussedSession.send('ar.focus.state', { state: false });
                            if (session) session.send('ar.focus.state', { state: true });
                            this._session = session;
                            this.sessionFocusEvent.raiseEvent({
                                previous: previousFocussedSession,
                                current: session
                            });
                        }
                    },
                    enumerable: true,
                    configurable: true
                });

                return FocusServiceProvider;
            }());

            _export('FocusServiceProvider', FocusServiceProvider = __decorate$7([inject(SessionService, FocusService), __metadata$7("design:paramtypes", [typeof (_b$7 = typeof SessionService !== "undefined" && SessionService) === "function" && _b$7 || Object])], FocusServiceProvider));

            __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$8 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('VisibilityService', VisibilityService = function () {
                function VisibilityService(sessionService) {
                    var _this = this;
                    /**
                     * An event that is raised when the app becomes visible
                     */
                    this.showEvent = new Event$1();
                    /**
                     * An event that is raised when the app becomes hidden
                     */
                    this.hideEvent = new Event$1();
                    this._isVisible = false;
                    sessionService.manager.on['ar.visibility.state'] = function (_a) {
                        var state = _a.state;
                        if (_this._isVisible !== state) {
                            _this._isVisible = state;
                            if (state) _this.showEvent.raiseEvent(undefined);else _this.hideEvent.raiseEvent(undefined);
                        }
                    };
                    sessionService.manager.closeEvent.addEventListener(function () {
                        if (_this._isVisible) {
                            _this._isVisible = false;
                            _this.hideEvent.raiseEvent(undefined);
                        }
                    });
                    // if running in an old manager, assume we are visible
                    sessionService.manager.connectEvent.addEventListener(function () {
                        if (sessionService.manager.version[0] === 0) {
                            _this._isVisible = true;
                            _this.showEvent.raiseEvent(undefined);
                        }
                    });
                }
                Object.defineProperty(VisibilityService.prototype, "isVisible", {
                    /**
                     * True if this app has focus
                     */
                    get: function () {
                        return this._isVisible;
                    },
                    enumerable: true,
                    configurable: true
                });
                return VisibilityService;
            }());

            _export('VisibilityService', VisibilityService = __decorate$8([inject(SessionService), __metadata$8("design:paramtypes", [typeof (_a$8 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$8 || Object])], VisibilityService));
            /**
             * Manage visibility state
             */

            _export('VisibilityServiceProvider', VisibilityServiceProvider = function () {
                function VisibilityServiceProvider(sessionService) {
                    var _this = this;
                    this.visibleSessions = new Set();
                    this.sessionChangeEvent = new Event$1();
                    sessionService.ensureIsRealityManager();
                    this.sessionChangeEvent.addEventListener(function (session) {
                        session.send('ar.visibility.state', { state: _this.visibleSessions.has(session) });
                    });
                    sessionService.manager.connectEvent.addEventListener(function () {
                        _this.set(sessionService.manager, true);
                    });
                }
                VisibilityServiceProvider.prototype.set = function (session, visibility) {
                    if (visibility) {
                        if (!this.visibleSessions.has(session)) {
                            this.visibleSessions.add(session);
                            this.sessionChangeEvent.raiseEvent(session);
                        }
                    } else {
                        if (this.visibleSessions.has(session)) {
                            this.visibleSessions.delete(session);
                            this.sessionChangeEvent.raiseEvent(session);
                        }
                    }
                };
                return VisibilityServiceProvider;
            }());

            _export('VisibilityServiceProvider', VisibilityServiceProvider = __decorate$8([inject(SessionService, VisibilityService), __metadata$8("design:paramtypes", [typeof (_b$8 = typeof SessionService !== "undefined" && SessionService) === "function" && _b$8 || Object])], VisibilityServiceProvider));

            __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$6 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('Subview', Subview = function () {
                function Subview() {}
                return Subview;
            }());

            (function (ViewportMode) {
                ViewportMode[ViewportMode["EMBEDDED"] = 0] = "EMBEDDED";
                ViewportMode[ViewportMode["PAGE"] = 0] = "PAGE";
                ViewportMode[ViewportMode["IMMERSIVE"] = 1] = "IMMERSIVE";
            })(ViewportMode || _export('ViewportMode', ViewportMode = {}));

            _export('ViewElement', ViewElement = function () {
                function ViewElement() {}
                return ViewElement;
            }());

            _export('ViewService', ViewService = function () {
                function ViewService(sessionService, focusService, elementOrSelector) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.focusService = focusService;
                    /**
                     * UI events that occur within this view. To handle an event (and prevent it from
                     * being forwarded to another layer) call event.stopImmediatePropagation().
                     */
                    this.uiEvent = new Event$1();
                    /**
                     * An event that is raised when the viewport has changed
                     */
                    this.viewportChangeEvent = new Event$1();
                    /**
                     * An event that is raised when the viewport mode has changed
                     */
                    this.viewportModeChangeEvent = new Event$1();
                    this._mode = ViewportMode.EMBEDDED;
                    this._viewport = new Viewport();
                    this._renderWidth = 0;
                    this._renderHeight = 0;
                    /**
                     * Automatically layout the element to match the immersive viewport during PresentationMode.IMMERSIVE
                     */
                    this.autoLayoutImmersiveMode = true;
                    /**
                     * Automatically style layer elements
                     */
                    this.autoStyleLayerElements = true;
                    /**
                     * Automatically publish the viewport of the element during PresentationMode.EMBEDDED
                     */
                    this.autoPublishEmbeddedMode = true;
                    this._layers = [];
                    this._subviews = [];
                    this._subviewPose = [];
                    this._subviewFrustum = [];
                    this._desiredViewportMode = this.viewportMode;
                    this._embeddedViewport = new Viewport();
                    if (typeof document !== 'undefined' && document.createElement) {
                        var element = elementOrSelector;
                        if (!element || typeof element === 'string') {
                            var selector = element;
                            element = selector ? document.querySelector(selector) : undefined;
                            if (!element && !selector) {
                                element = document.querySelector('#argon');
                                if (!element) {
                                    element = document.createElement('div');
                                    element.id = 'argon';
                                    document.body.appendChild(element);
                                }
                            } else if (!element) {
                                throw new Error('Unable to find element with selector: ' + selector);
                            }
                        }
                        this.element = element;
                        element.classList.add('argon-view');
                        // prevent pinch-zoom of the page in ios 10.
                        if (isIOS) {
                            var touchMoveListener_1 = function (event) {
                                if (event.touches.length > 1) event.preventDefault();
                            };
                            this.element.addEventListener('touchmove', touchMoveListener_1, true);
                            this.sessionService.manager.closeEvent.addEventListener(function () {
                                _this.element.removeEventListener('touchmove', touchMoveListener_1);
                            });
                        }
                        this.focusService.focusEvent.addEventListener(function () {
                            document.documentElement.classList.remove('argon-no-focus');
                            document.documentElement.classList.remove('argon-blur');
                            document.documentElement.classList.add('argon-focus');
                        });
                        this.focusService.blurEvent.addEventListener(function () {
                            document.documentElement.classList.remove('argon-focus');
                            document.documentElement.classList.add('argon-blur');
                            document.documentElement.classList.add('argon-no-focus');
                        });
                        this.viewportModeChangeEvent.addEventListener(function (mode) {
                            switch (mode) {
                                case ViewportMode.EMBEDDED:
                                    document.documentElement.classList.remove('argon-immersive');
                                    break;
                                case ViewportMode.IMMERSIVE:
                                    document.documentElement.classList.add('argon-immersive');
                                    break;
                            }
                        });
                        if (this.sessionService.isRealityViewer) {
                            this.sessionService.manager.on['ar.view.uievent'] = getEventSynthesizier$1();
                        }
                        if (!this.sessionService.isRealityViewer) {
                            createEventForwarder$$1(this, function (event) {
                                if (_this.sessionService.manager.isConnected && _this.sessionService.manager.version[0] >= 1) _this.sessionService.manager.send('ar.view.forwardUIEvent', event);
                            });
                            this._watchEmbeddedViewport();
                        }
                    }
                    sessionService.manager.on['ar.view.viewportMode'] = function (_a) {
                        var mode = _a.mode;
                        _this._updateViewportMode(mode);
                    };
                    // if we are not the manager, we must start in immersive mode
                    if (!sessionService.isRealityManager) this._updateViewportMode(ViewportMode.IMMERSIVE);
                    // if we are loaded in an older manager which does not support embedded mode,
                    // then switch to immersive mode
                    sessionService.manager.connectEvent.addEventListener(function () {
                        if (sessionService.manager.version[0] === 0 || !sessionService.isRealityManager) {
                            _this._updateViewportMode(ViewportMode.IMMERSIVE);
                        }
                    });
                }
                Object.defineProperty(ViewService.prototype, "viewportMode", {
                    /**
                     * The current viewport mode
                     */
                    get: function () {
                        return this._mode;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ViewService.prototype, "presentationMode", {
                    get: function () {
                        return this.viewportMode;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ViewService.prototype, "viewport", {
                    /**
                     * The current viewport
                     */
                    get: function () {
                        return this._viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ViewService.prototype, "renderWidth", {
                    /**
                     * The width which should be used for the render buffer
                     */
                    get: function () {
                        return this._renderWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ViewService.prototype, "renderHeight", {
                    /**
                     * The height which should be used for the render buffer
                     */
                    get: function () {
                        return this._renderHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                ViewService.prototype.getViewport = function () {
                    return this.viewport;
                };
                ViewService.prototype.setLayers = function (layers) {
                    if (this._layers) {
                        for (var _i = 0, _a = this._layers; _i < _a.length; _i++) {
                            var l = _a[_i];
                            this.element.removeChild(l.source);
                        }
                    }
                    this._layers = layers;
                    for (var _b = 0, layers_1 = layers; _b < layers_1.length; _b++) {
                        var l = layers_1[_b];
                        this.element.appendChild(l.source);
                    }
                };
                Object.defineProperty(ViewService.prototype, "layers", {
                    get: function () {
                        return this._layers;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ViewService.prototype, "subviews", {
                    get: function () {
                        return this._subviews;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 */
                ViewService.prototype.getSubviews = function () {
                    return this.subviews;
                };
                // Kind of hacky that we are passing the ContextService here.
                // Might be better to bring this logic into the ContextService
                ViewService.prototype._processContextFrameState = function (state, contextService) {
                    var renderWidthScaleFactor = state.viewport.renderWidthScaleFactor || 1;
                    var renderHeightScaleFactor = state.viewport.renderHeightScaleFactor || 1;
                    this._renderWidth = state.viewport.width * renderWidthScaleFactor;
                    this._renderHeight = state.viewport.height * renderHeightScaleFactor;
                    var serializedSubviewList = state.subviews;
                    var subviews = this._subviews;
                    subviews.length = serializedSubviewList.length;
                    var index = 0;
                    for (var _i = 0, serializedSubviewList_1 = serializedSubviewList; _i < serializedSubviewList_1.length; _i++) {
                        var serializedSubview = serializedSubviewList_1[_i];
                        var subview = subviews[index] = subviews[index] || {};
                        subview.index = index;
                        subview.type = serializedSubview.type;
                        subview.viewport = subview.viewport || {};
                        subview.viewport.x = serializedSubview.viewport.x;
                        subview.viewport.y = serializedSubview.viewport.y;
                        subview.viewport.width = serializedSubview.viewport.width;
                        subview.viewport.height = serializedSubview.viewport.height;
                        subview.renderViewport = subview.renderViewport || {};
                        subview.renderViewport.x = serializedSubview.viewport.x * renderWidthScaleFactor;
                        subview.renderViewport.y = serializedSubview.viewport.y * renderHeightScaleFactor;
                        subview.renderViewport.width = serializedSubview.viewport.width * renderWidthScaleFactor;
                        subview.renderViewport.height = serializedSubview.viewport.height * renderHeightScaleFactor;
                        subview.frustum = this._subviewFrustum[index] = this._subviewFrustum[index] || new PerspectiveFrustum();
                        decomposePerspectiveProjectionMatrix(serializedSubview.projectionMatrix, subview.frustum);
                        subview['projectionMatrix'] = subview.frustum.projectionMatrix;
                        subview.pose = this._subviewPose[index] = this._subviewPose[index] || contextService.createEntityPose(contextService.getSubviewEntity(index));
                        subview.pose.update(state.time);
                        index++;
                    }
                    this._updateViewport(state.viewport);
                };
                ViewService.prototype.requestPresentationMode = function (mode) {
                    return this.sessionService.manager.request('ar.view.desiredViewportMode', { mode: mode });
                };
                Object.defineProperty(ViewService.prototype, "desiredViewportMode", {
                    get: function () {
                        return this._desiredViewportMode;
                    },
                    set: function (mode) {
                        var _this = this;
                        this._desiredViewportMode = mode;
                        this.sessionService.manager.whenConnected().then(function () {
                            if (_this.sessionService.manager.version[0] > 0) _this.sessionService.manager.send('ar.view.desiredViewportMode', { mode: mode });
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                ViewService.prototype._updateViewportMode = function (mode) {
                    var currentMode = this.viewportMode;
                    if (currentMode !== mode) {
                        this._mode = mode;
                        this.viewportModeChangeEvent.raiseEvent(mode);
                    }
                };
                /**
                 * Publish the viewport being used in [[PresentationMode.EMBEDDED]]
                 * so that the manager knows what our embedded viewport is
                 */
                ViewService.prototype.publishEmbeddedViewport = function (viewport) {
                    if (this.sessionService.manager.isConnected && this.sessionService.manager.version[0] >= 1) this.sessionService.manager.send('ar.view.embeddedViewport', { viewport: viewport });
                };
                // Updates the element, if necessary, and raise a view change event
                ViewService.prototype._updateViewport = function (viewport) {
                    var _this = this;
                    var viewportJSON = JSON.stringify(viewport);
                    if (this._layers.length && this.autoStyleLayerElements) {
                        requestAnimationFrame(function () {
                            var zIndex = -_this._layers.length;
                            for (var _i = 0, _a = _this._layers; _i < _a.length; _i++) {
                                var layer = _a[_i];
                                var layerStyle = layer.source.style;
                                layerStyle.position = 'absolute';
                                layerStyle.left = viewport.x + 'px';
                                layerStyle.bottom = viewport.y + 'px';
                                layerStyle.width = viewport.width + 'px';
                                layerStyle.height = viewport.height + 'px';
                                layerStyle.zIndex = '' + zIndex;
                                zIndex++;
                            }
                        });
                    }
                    if (!this._currentViewportJSON || this._currentViewportJSON !== viewportJSON) {
                        this._currentViewportJSON = viewportJSON;
                        this._viewport = Viewport.clone(viewport, this._viewport);
                        if (this.element && !this.sessionService.isRealityManager && this.autoLayoutImmersiveMode && this.viewportMode === ViewportMode.IMMERSIVE) {
                            requestAnimationFrame(function () {
                                var elementStyle = _this.element.style;
                                elementStyle.position = 'fixed';
                                elementStyle.left = viewport.x + 'px';
                                elementStyle.bottom = viewport.y + 'px';
                                elementStyle.width = viewport.width + 'px';
                                elementStyle.height = viewport.height + 'px';
                            });
                        }
                        this.viewportChangeEvent.raiseEvent(viewport);
                    }
                };
                ViewService.prototype.sendUIEventToSession = function (uievent, session) {
                    if (session && session.isConnected) session.send('ar.view.uievent', uievent);
                };
                ViewService.prototype._watchEmbeddedViewport = function () {
                    var _this = this;
                    var publish = function () {
                        if (_this.element && _this.autoPublishEmbeddedMode) {
                            var parentElement = _this.element.parentElement;
                            var rect = parentElement && parentElement.getBoundingClientRect();
                            if (rect) {
                                var x = rect.left;
                                var y = window.innerHeight - rect.bottom;
                                var width = rect.width;
                                var height = rect.height;
                                var embeddedViewport = _this._embeddedViewport;
                                if (embeddedViewport.x !== x || embeddedViewport.y !== y || embeddedViewport.width !== width || embeddedViewport.height !== height) {
                                    embeddedViewport.x = x;
                                    embeddedViewport.y = y;
                                    embeddedViewport.width = width;
                                    embeddedViewport.height = height;
                                    _this.publishEmbeddedViewport(_this._embeddedViewport);
                                }
                            }
                        }
                    };
                    setInterval(function () {
                        if (!_this.focusService.hasFocus) publish();
                    }, 500);
                    // this.contextService.renderEvent.addEventListener(()=>{
                    //     if (this.focusService.hasFocus) publish();
                    // });
                    if (typeof window !== 'undefined' && window.addEventListener) {
                        window.addEventListener('orientationchange', publish);
                        window.addEventListener('scroll', publish);
                        this.sessionService.manager.closeEvent.addEventListener(function () {
                            window.removeEventListener('orientationchange', publish);
                            window.removeEventListener('scroll', publish);
                        });
                    }
                };
                return ViewService;
            }());

            __decorate$6([deprecated$1('viewportMode'), __metadata$6("design:type", Object), __metadata$6("design:paramtypes", [])], ViewService.prototype, "presentationMode", null);
            __decorate$6([deprecated$1('viewport'), __metadata$6("design:type", Function), __metadata$6("design:paramtypes", []), __metadata$6("design:returntype", void 0)], ViewService.prototype, "getViewport", null);
            __decorate$6([deprecated$1('subviews'), __metadata$6("design:type", Function), __metadata$6("design:paramtypes", []), __metadata$6("design:returntype", void 0)], ViewService.prototype, "getSubviews", null);
            __decorate$6([deprecated$1('desiredViewportMode'), __metadata$6("design:type", Function), __metadata$6("design:paramtypes", [Number]), __metadata$6("design:returntype", Object)], ViewService.prototype, "requestPresentationMode", null);
            _export('ViewService', ViewService = __decorate$6([inject(SessionService, FocusService, Optional.of(ViewElement)), __metadata$6("design:paramtypes", [typeof (_a$6 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$6 || Object, typeof (_b$6 = typeof FocusService !== "undefined" && FocusService) === "function" && _b$6 || Object, Object])], ViewService));

            _export('ViewServiceProvider', ViewServiceProvider = function () {
                function ViewServiceProvider(sessionService, viewService, focusServiceProvider, visibilityServiceProvider) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.viewService = viewService;
                    this.focusServiceProvider = focusServiceProvider;
                    this.sessionViewportMode = new WeakMap();
                    /**
                     * The embedded viewports for each managed session.
                     */
                    this.sessionEmbeddedViewport = new WeakMap();
                    /**
                     * A UI event being forwarded from a managed session
                     */
                    this.forwardedUIEvent = new Event$1();
                    sessionService.ensureIsRealityManager();
                    sessionService.connectEvent.addEventListener(function (session) {
                        _this.sessionViewportMode.set(session, session === _this.sessionService.manager ? _this.viewService.desiredViewportMode : ViewportMode.IMMERSIVE);
                        // forward ui events to the visible reality viewer
                        session.on['ar.view.forwardUIEvent'] = function (uievent) {
                            _this.forwardedUIEvent.raiseEvent(uievent);
                        };
                        session.on['ar.view.desiredViewportMode'] = function (_a) {
                            var mode = _a.mode;
                            _this.sessionViewportMode.set(session, mode);
                            _this._publishViewportModes();
                        };
                        session.on['ar.view.embeddedViewport'] = function (viewport) {
                            _this.sessionEmbeddedViewport.set(session, viewport);
                        };
                        _this._publishViewportModes();
                    });
                    focusServiceProvider.sessionFocusEvent.addEventListener(function () {
                        _this._publishViewportModes();
                    });
                }
                ViewServiceProvider.prototype.sendUIEventToSession = function (uievent, session) {
                    session.send('ar.view.uievent', uievent);
                };
                ViewServiceProvider.prototype._publishViewportModes = function () {
                    this.sessionService.manager.send('ar.view.viewportMode', {
                        mode: this.sessionViewportMode.get(this.sessionService.manager)
                    });
                    for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
                        var session = _a[_i];
                        var mode = session === this.focusServiceProvider.session ? this.sessionViewportMode.get(session) : ViewportMode.IMMERSIVE;
                        if (session.version[0] > 0) session.send('ar.view.viewportMode', { mode: mode });
                    }
                };
                return ViewServiceProvider;
            }());

            _export('ViewServiceProvider', ViewServiceProvider = __decorate$6([autoinject(), __metadata$6("design:paramtypes", [typeof (_c$4 = typeof SessionService !== "undefined" && SessionService) === "function" && _c$4 || Object, ViewService, typeof (_d$3 = typeof FocusServiceProvider !== "undefined" && FocusServiceProvider) === "function" && _d$3 || Object, typeof (_e$3 = typeof VisibilityServiceProvider !== "undefined" && VisibilityServiceProvider) === "function" && _e$3 || Object])], ViewServiceProvider));
            // setup our DOM environment
            if (typeof document !== 'undefined' && document.createElement) {
                viewportMetaTag = document.querySelector('meta[name=viewport]');

                if (!viewportMetaTag) viewportMetaTag = document.createElement('meta');
                viewportMetaTag.name = 'viewport';
                viewportMetaTag.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
                document.head.appendChild(viewportMetaTag);
                argonMetaTag = document.querySelector('meta[name=argon]');

                if (!argonMetaTag) argonMetaTag = document.createElement('meta');
                argonMetaTag.name = 'argon';
                document.head.appendChild(argonMetaTag);
                style = document.createElement("style");

                style.type = 'text/css';
                document.head.insertBefore(style, document.head.firstChild);
                sheet = style.sheet;

                sheet.insertRule("\n        #argon {\n            position: fixed;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            bottom: 0;\n            margin: 0;\n            border: 0;\n            padding: 0;\n        }\n    ", sheet.cssRules.length);
                sheet.insertRule("\n        .argon-view {\n            -webkit-tap-highlight-color: transparent;\n            -webkit-user-select: none;\n            user-select: none;\n        }\n    ", sheet.cssRules.length);
                sheet.insertRule("\n        .argon-immersive .argon-view {\n            position: fixed !important;\n            width: 100% !important;\n            height: 100% !important;\n            max-width: 100% !important;\n            max-height: 100% !important;\n            left: 0;\n            bottom: 0;\n            margin: 0;\n            border: 0;\n            padding: 0;\n            visibility: visible;\n        }\n    ", sheet.cssRules.length);
                sheet.insertRule("\n        .argon-immersive body {\n            visibility: hidden;\n        }\n    ", sheet.cssRules.length);
                sheet.insertRule("\n        .argon-interactive {\n            pointer-events: auto;\n        }\n    ", sheet.cssRules.length);
            }

            __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$3 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('DeviceStableState', DeviceStableState$$1 = function () {
                function DeviceStableState$$1() {
                    this.entities = {};
                    this.suggestedGeolocationSubscription = undefined;
                    this.suggestedUserHeight = AVERAGE_EYE_HEIGHT;
                    this.geolocationDesired = false;
                    this.geolocationOptions = {};
                    this.isPresentingHMD = false;
                    this.isPresentingRealityHMD = false;
                    this.strict = false;
                }
                return DeviceStableState$$1;
            }());

            _export('DeviceFrameState', DeviceFrameState$$1 = function () {
                function DeviceFrameState$$1() {
                    this._scratchFrustum = new PerspectiveFrustum();
                    this.time = JulianDate.now();
                    this.viewport = new CanvasViewport();
                    this.subviews = [{
                        type: SubviewType.SINGULAR,
                        viewport: new Viewport(),
                        projectionMatrix: (this._scratchFrustum.near = DEFAULT_NEAR_PLANE, this._scratchFrustum.far = DEFAULT_FAR_PLANE, this._scratchFrustum.fov = CesiumMath.PI_OVER_THREE, this._scratchFrustum.aspectRatio = 1, Matrix4.clone(this._scratchFrustum.projectionMatrix))
                    }];
                }
                return DeviceFrameState$$1;
            }());

            _export('DeviceService', DeviceService = function () {
                function DeviceService$$1(sessionService, entityService, viewService, visibilityService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.entityService = entityService;
                    this.viewService = viewService;
                    this.visibilityService = visibilityService;
                    /**
                     * If this is true (and we are presenting via webvr api), then
                     * vrDisplay.submitFrame is called after the frameState event
                     */
                    this.autoSubmitFrame = true;
                    /**
                     * Device state for the current frame. This
                     * is not updated unless the view is visible.
                     */
                    this.frameState = new DeviceFrameState$$1();
                    /**
                     * An event that fires every time the device frameState is updated.
                     */
                    this.frameStateEvent = new Event$1();
                    /**
                     * An even that fires when the view starts or stops presenting to an HMD
                     */
                    this.presentHMDChangeEvent = new Event$1();
                    /*
                     * An event that fires when the screen orientation changes
                     */
                    this.screenOrientationChangeEvent = new Event$1();
                    /*
                     * An event that fires when the screen orientation changes
                     */
                    this.suggestedGeolocationSubscriptionChangeEvent = new Event$1();
                    /**
                     * A coordinate system representing the physical space in which the user is free to
                     * move around, positioned on the surface the user is standing on,
                     * where +X is east, +Y is up, and +Z is south (East-Up-South), if geolocation is known.
                     * If the stage is not geolocated, then the +X and +Z directions are arbitrary.
                     */
                    this.stage = this.entityService.collection.add(new Entity({
                        id: 'ar.device.stage',
                        name: 'Device Stage',
                        position: undefined,
                        orientation: undefined
                    }));
                    /**
                     * An entity representing the origin of the device coordinate system, +Y up.
                     */
                    this.origin = this.entityService.collection.add(new Entity({
                        id: 'ar.device.origin',
                        name: 'Device Origin',
                        position: new ConstantPositionProperty(Cartesian3.ZERO, this.stage),
                        orientation: new ConstantProperty(Quaternion.IDENTITY)
                    }));
                    /**
                     * An entity representing the physical pose of the user,
                     * where +X is right, +Y is up, and -Z is forward
                     */
                    this.user = this.entityService.collection.add(new Entity({
                        id: 'ar.device.user',
                        name: 'Device User',
                        position: undefined,
                        orientation: undefined
                    }));
                    this._geolocationDesired = false;
                    this.defaultUserHeight = AVERAGE_EYE_HEIGHT;
                    this._scratchCartesian = new Cartesian3();
                    this._scratchFrustum = new PerspectiveFrustum();
                    this._updatingFrameState = false;
                    this._updateFrameState = function () {
                        if (!_this._updatingFrameState) return;
                        _this.requestAnimationFrame(_this._updateFrameState);
                        var state = _this.frameState;
                        JulianDate.now(state.time);
                        state['strict'] = _this.strict; // backwards-compat
                        _this.onUpdateFrameState();
                        try {
                            _this.frameStateEvent.raiseEvent(state);
                        } catch (e) {
                            _this.sessionService.manager.sendError(e);
                            _this.sessionService.errorEvent.raiseEvent(e);
                        }
                    };
                    /**
                     * Request an animation frame callback for the current view.
                     */
                    this.requestAnimationFrame = function (callback) {
                        if (_this._vrDisplay && _this.isPresentingHMD) {
                            return _this._vrDisplay.requestAnimationFrame(callback);
                        } else {
                            return rAF(callback);
                        }
                    };
                    /**
                     * Cancel an animation frame callback for the current view.
                     */
                    this.cancelAnimationFrame = function (id) {
                        if (_this._vrDisplay && _this.isPresentingHMD) {
                            _this._vrDisplay.cancelAnimationFrame(id);
                        } else {
                            cAF(id);
                        }
                    };
                    this._stringIdentifierFromReferenceFrame = stringIdentifierFromReferenceFrame;
                    this._getReachableAncestorReferenceFrames = getReachableAncestorReferenceFrames;
                    this._scratchArray = [];
                    this._originPose = this.entityService.createEntityPose(this.origin, this.stage);
                    this._scratchQuaternion = new Quaternion();
                    this._scratchQuaternion2 = new Quaternion();
                    this._scratchMatrix3 = new Matrix3();
                    this._scratchMatrix4 = new Matrix4();
                    this._defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
                    this._defaultRightBounds = [0.5, 0.0, 0.5, 1.0];
                    this._negX90 = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, -CesiumMath.PI_OVER_TWO);
                    this.visibilityService.showEvent.addEventListener(function () {
                        return _this._startUpdates();
                    });
                    this.visibilityService.hideEvent.addEventListener(function () {
                        return _this._stopUpdates();
                    });
                    if (typeof navigator !== 'undefined' && navigator.getVRDisplays && navigator.userAgent.indexOf('Argon') > 0 === false) {
                        this._setupVRPresentChangeHandler();
                        navigator.getVRDisplays().then(function (displays) {
                            _this._vrDisplays = displays;
                            _this._vrDisplay = displays[0];
                        });
                    }
                    if (typeof window !== 'undefined' && window.addEventListener) {
                        var orientationChangeListener_1 = function () {
                            _this.screenOrientationChangeEvent.raiseEvent(undefined);
                        };
                        window.addEventListener('orientationchange', orientationChangeListener_1);
                        sessionService.manager.closeEvent.addEventListener(function () {
                            window.removeEventListener('orientationchange', orientationChangeListener_1);
                        });
                    }
                    if (this.sessionService.isRealityManager) {
                        this.entityService.subscribedEvent.addEventListener(function (evt) {
                            if (evt.id === 'ar.stage') _this._setSuggestedGeolocationSubscription(evt.options || {});
                        });
                        this.entityService.unsubscribedEvent.addEventListener(function (evt) {
                            if (evt.id === 'ar.stage') _this._setSuggestedGeolocationSubscription(undefined);
                        });
                    } else {
                        sessionService.manager.on['ar.device.state'] = sessionService.manager.on['ar.device.frameState'] = function (stableState) {
                            var entities = stableState.entities;
                            var entityService = _this.entityService;
                            if (entities) for (var id in entities) {
                                entityService.updateEntityFromSerializedState(id, entities[id]);
                            }
                            _this._setSuggestedGeolocationSubscription(stableState.geolocationOptions || stableState.suggestedGeolocationSubscription);

                            if (_this._parentState && _this._parentState.isPresentingHMD !== stableState.isPresentingHMD || _this._parentState && _this._parentState.isPresentingRealityHMD !== stableState.isPresentingRealityHMD) {
                                _this.presentHMDChangeEvent.raiseEvent(undefined);
                            }
                            _this._parentState = stableState;
                        };
                    }
                }
                Object.defineProperty(DeviceService$$1.prototype, "geoHeadingAccuracy", {
                    get: function () {
                        return this.user['meta'] ? this.user['meta'].geoHeadingAccuracy : undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "geoHorizontalAccuracy", {
                    get: function () {
                        return this.stage['meta'] ? this.stage['meta'].geoHorizonatalAccuracy : undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "geoVerticalAccuracy", {
                    get: function () {
                        return this.stage['meta'] ? this.stage['meta'].geoVerticalAccuracy : undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "geolocationDesired", {
                    get: function () {
                        return this._parentState ? this._parentState.suggestedGeolocationSubscription || this._parentState.geolocationDesired : this._geolocationDesired;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "geolocationOptions", {
                    get: function () {
                        return this._parentState ? this._parentState.suggestedGeolocationSubscription || this._parentState.geolocationOptions : this._geolocationOptions;
                    },
                    enumerable: true,
                    configurable: true
                });
                DeviceService$$1.prototype._setSuggestedGeolocationSubscription = function (options) {
                    if (!jsonEquals(this._suggestedGeolocationSubscription, options)) {
                        this._suggestedGeolocationSubscription = options;
                        this.suggestedGeolocationSubscriptionChangeEvent.raiseEvent(undefined);
                    }
                };
                Object.defineProperty(DeviceService$$1.prototype, "suggestedGeolocationSubscription", {
                    get: function () {
                        return this._suggestedGeolocationSubscription;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "suggestedUserHeight", {
                    get: function () {
                        return this._parentState && this._parentState.suggestedUserHeight || this.isPresentingHMD ? this.defaultUserHeight : this.defaultUserHeight / 2;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "strict", {
                    get: function () {
                        return !!(this._parentState && this._parentState.strict) || this.isPresentingHMD && !this._hasPolyfillWebVRDisplay() || false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "vrDisplay", {
                    get: function () {
                        return this._vrDisplay;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "screenOrientationDegrees", {
                    get: function () {
                        return typeof window !== 'undefined' ? screen['orientation'] && -screen['orientation'].angle || -window.orientation || 0 : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                DeviceService$$1.prototype.getScreenOrientationDegrees = function () {
                    return this.getScreenOrientationDegrees;
                };
                /**
                 * Start emmitting frameState events
                 */
                DeviceService$$1.prototype._startUpdates = function () {
                    var _this = this;
                    if (!this._updatingFrameState) this.requestAnimationFrame(this._updateFrameState);
                    this._updatingFrameState = true;
                    this.sessionService.manager.whenConnected().then(function () {
                        if (_this.sessionService.manager.version[0] > 0) {
                            _this.sessionService.manager.send('ar.device.startUpdates');
                        }
                    });
                };
                /**
                 * Stop emitting frameState events
                 */
                DeviceService$$1.prototype._stopUpdates = function () {
                    var _this = this;
                    this._updatingFrameState = false;
                    this.sessionService.manager.whenConnected().then(function () {
                        if (_this.sessionService.manager.version[0] > 0) {
                            _this.sessionService.manager.send('ar.device.stopUpdates');
                        }
                    });
                };
                DeviceService$$1.prototype.onUpdateFrameState = function () {
                    this._updateViewport();
                    if (this._vrDisplay && this._vrDisplay.isPresenting) {
                        this._updateForWebVR();
                    } else {
                        this._updateDefault();
                    }
                };
                DeviceService$$1.prototype._updateViewport = function () {
                    var parentState = this._parentState;
                    var state = this.frameState;
                    var viewport = state.viewport;
                    if (parentState && parentState.viewport) {
                        CanvasViewport.clone(parentState.viewport, viewport);
                    } else {
                        var element = this.viewService.element;
                        viewport.x = 0;
                        viewport.y = 0;
                        viewport.width = element && element.clientWidth || 0;
                        viewport.height = element && element.clientHeight || 0;
                        var vrDisplay = this._vrDisplay;
                        if (vrDisplay && vrDisplay.isPresenting) {
                            var leftEye = vrDisplay.getEyeParameters("left");
                            var rightEye = vrDisplay.getEyeParameters("right");
                            var viewport_1 = state.viewport;
                            viewport_1.renderWidthScaleFactor = 2 * Math.max(leftEye.renderWidth, rightEye.renderWidth) / viewport_1.width;
                            viewport_1.renderHeightScaleFactor = Math.max(leftEye.renderHeight, rightEye.renderHeight) / viewport_1.height;
                        } else {
                            viewport.renderHeightScaleFactor = 1;
                            viewport.renderWidthScaleFactor = 1;
                        }
                    }
                };
                DeviceService$$1.prototype._updateDefault = function () {
                    this._updateDefaultOrigin();
                    this._updateDefaultUser();
                    var parentState = this._parentState;
                    var frameState = this.frameState;
                    var viewport = frameState.viewport;
                    if (parentState && parentState.viewport) {
                        CanvasViewport.clone(parentState.viewport, viewport);
                    }
                    var subviews = frameState.subviews;
                    if (parentState && parentState.subviews) {
                        SerializedSubviewList.clone(parentState.subviews, subviews);
                    } else {
                        subviews.length = 1;
                        var subview = subviews[0] || {};
                        subview.type = SubviewType.SINGULAR;
                        subview.viewport.x = 0;
                        subview.viewport.y = 0;
                        subview.viewport.width = viewport.width;
                        subview.viewport.height = viewport.height;
                        var aspect = viewport.width / viewport.height;
                        var frustum = this._scratchFrustum;
                        frustum.near = DEFAULT_NEAR_PLANE;
                        frustum.far = DEFAULT_FAR_PLANE;
                        frustum.fov = CesiumMath.PI_OVER_THREE;
                        frustum.aspectRatio = isFinite(aspect) && aspect !== 0 ? aspect : 1;
                        subview.projectionMatrix = Matrix4.clone(frustum.projectionMatrix, subview.projectionMatrix);
                        var subviewEntity = this.getSubviewEntity(0);
                        subviewEntity.position.setValue(Cartesian3.ZERO, this.user);
                        subviewEntity.orientation.setValue(Quaternion.IDENTITY);
                    }
                };
                DeviceService$$1.prototype._updateDefaultOrigin = function () {
                    var origin = this.origin;
                    var stage = this.stage;
                    var originPose = this._originPose;
                    var time = this.frameState.time;
                    originPose.update(time);
                    if ((originPose.status & PoseStatus.KNOWN) === 0 || Cartesian3.magnitudeSquared(originPose.position) > 10000) {
                        var stageFrame = this._getReachableAncestorReferenceFrames(stage, time, this._scratchArray)[0];
                        if (defined(stageFrame)) {
                            var stagePositionValue = stage.position.getValueInReferenceFrame(time, stageFrame, this._scratchCartesian);
                            var stageOrientationValue = stage.orientation.getValue(time, this._scratchQuaternion);
                            if (stagePositionValue && stageOrientationValue) {
                                origin.position.setValue(stagePositionValue, stageFrame);
                                origin.orientation.setValue(stageOrientationValue);
                                console.log('Updated device origin to ' + JSON.stringify(stagePositionValue) + " at " + this._stringIdentifierFromReferenceFrame(stageFrame));
                                return;
                            }
                        }
                    } else {
                        return;
                    }
                    origin.position.setValue(Cartesian3.ZERO, stage);
                    origin.orientation.setValue(Quaternion.IDENTITY);
                };
                DeviceService$$1.prototype._updateDefaultUser = function () {
                    var deviceUser = this.user;
                    var deviceStage = this.stage;
                    var deviceOrientation = this._deviceOrientation;
                    this._tryOrientationUpdates();
                    if (!deviceOrientation) {
                        deviceUser.position = undefined;
                        deviceUser.orientation = undefined;
                        return;
                    }
                    var screenOrientation = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, this.screenOrientationDegrees * CesiumMath.RADIANS_PER_DEGREE, this._scratchQuaternion);
                    if (!deviceUser.position) deviceUser.position = new ConstantPositionProperty();
                    if (!deviceUser.orientation) deviceUser.orientation = new ConstantProperty();
                    deviceUser.position.setValue(Cartesian3.fromElements(0, 0, this.suggestedUserHeight, this._scratchCartesian), deviceStage);
                    deviceUser.orientation.setValue(Quaternion.multiply(deviceOrientation, screenOrientation, this._scratchQuaternion));
                    deviceUser['meta'] = deviceUser['meta'] || {};
                    deviceUser['meta'].geoHeadingAccuracy = this._deviceOrientationHeadingAccuracy;
                };
                DeviceService$$1.prototype._updateForWebVR = function () {
                    var vrDisplay = this._vrDisplay;
                    if (!vrDisplay) throw new Error('No vr display!');
                    var frameState = this.frameState;
                    var vrFrameData = this._vrFrameData = this._vrFrameData || new VRFrameData();
                    if (!vrDisplay['getFrameData'](vrFrameData)) return this.frameState;
                    var layer = vrDisplay.getLayers()[0];
                    var leftBounds = layer && layer.leftBounds;
                    var rightBounds = layer && layer.rightBounds;
                    if (layer) {
                        leftBounds = layer.leftBounds && layer.leftBounds.length === 4 ? layer.leftBounds : this._defaultLeftBounds;
                        rightBounds = layer.rightBounds && layer.rightBounds.length === 4 ? layer.rightBounds : this._defaultRightBounds;
                    } else {
                        leftBounds = this._defaultLeftBounds;
                        rightBounds = this._defaultRightBounds;
                    }
                    var viewport = frameState.viewport;
                    var subviews = frameState.subviews = frameState.subviews || [];
                    subviews.length = 2;
                    var leftSubview = subviews[0] = subviews[0] || {};
                    var rightSubview = subviews[1] = subviews[1] || {};
                    leftSubview.type = SubviewType.LEFTEYE;
                    rightSubview.type = SubviewType.RIGHTEYE;
                    var leftViewport = leftSubview.viewport = leftSubview.viewport || {};
                    leftViewport.x = leftBounds[0] * viewport.width;
                    leftViewport.y = leftBounds[1] * viewport.height;
                    leftViewport.width = leftBounds[2] * viewport.width;
                    leftViewport.height = leftBounds[3] * viewport.height;
                    var rightViewport = rightSubview.viewport = rightSubview.viewport || {};
                    rightViewport.x = rightBounds[0] * viewport.width;
                    rightViewport.y = rightBounds[1] * viewport.height;
                    rightViewport.width = rightBounds[2] * viewport.width;
                    rightViewport.height = rightBounds[3] * viewport.height;
                    leftSubview.projectionMatrix = Matrix4.clone(vrFrameData.leftProjectionMatrix, leftSubview.projectionMatrix);
                    rightSubview.projectionMatrix = Matrix4.clone(vrFrameData.rightProjectionMatrix, rightSubview.projectionMatrix);
                    var sittingToStandingTransform = vrDisplay.stageParameters ? vrDisplay.stageParameters.sittingToStandingTransform : Matrix4.IDENTITY;
                    var sittingToStandingRotation = Matrix4.getRotation(sittingToStandingTransform, this._scratchMatrix3);
                    var sittingToStandingQuaternion = Quaternion.fromRotationMatrix(sittingToStandingRotation, this._scratchQuaternion);
                    var user = this.user;
                    var origin = this.origin;
                    var sittingUserPosition = vrFrameData.pose.position ? Cartesian3.unpack(vrFrameData.pose.position, 0, this._scratchCartesian) : undefined;
                    var standingUserPosition = sittingUserPosition ? Matrix4.multiplyByPoint(sittingToStandingTransform, sittingUserPosition, this._scratchCartesian) : undefined;
                    var sittingUserOrientation = vrFrameData.pose.orientation ? Quaternion.unpack(vrFrameData.pose.orientation, 0, this._scratchQuaternion2) : undefined;
                    var standingUserOrientation = sittingUserOrientation ? Quaternion.multiply(sittingToStandingQuaternion, sittingUserOrientation, this._scratchQuaternion) : undefined;
                    if (!user.position) user.position = new ConstantPositionProperty();
                    if (!user.orientation) user.orientation = new ConstantProperty();
                    user.position.setValue(standingUserPosition, origin);
                    user.orientation.setValue(standingUserOrientation);
                    if (standingUserPosition && standingUserOrientation) {
                        var leftEyeSittingSpaceTransform = Matrix4.inverseTransformation(vrFrameData.leftViewMatrix, this._scratchMatrix4);
                        var leftEyeStandingSpaceTransform = Matrix4.multiplyTransformation(sittingToStandingTransform, leftEyeSittingSpaceTransform, this._scratchMatrix4);
                        var leftEye = this.getSubviewEntity(0);
                        var leftEyePosition = Matrix4.getTranslation(leftEyeStandingSpaceTransform, this._scratchCartesian);
                        var leftEyeRotation = Matrix4.getRotation(leftEyeStandingSpaceTransform, this._scratchMatrix3);
                        var leftEyeOrientation = Quaternion.fromRotationMatrix(leftEyeRotation, this._scratchQuaternion);
                        leftEye.position.setValue(leftEyePosition, origin);
                        leftEye.orientation.setValue(leftEyeOrientation);
                        var rightEyeSittingSpaceTransform = Matrix4.inverseTransformation(vrFrameData.rightViewMatrix, this._scratchMatrix4);
                        var rightEyeStandingSpaceTransform = Matrix4.multiplyTransformation(sittingToStandingTransform, rightEyeSittingSpaceTransform, this._scratchMatrix4);
                        var rightEye = this.getSubviewEntity(1);
                        var rightEyePosition = Matrix4.getTranslation(rightEyeStandingSpaceTransform, this._scratchCartesian);
                        var rightEyeRotation = Matrix4.getRotation(rightEyeStandingSpaceTransform, this._scratchMatrix3);
                        var rightEyeOrientation = Quaternion.fromRotationMatrix(rightEyeRotation, this._scratchQuaternion);
                        rightEye.position.setValue(rightEyePosition, origin);
                        rightEye.orientation.setValue(rightEyeOrientation);
                    }
                    if (vrDisplay.displayName.match(/polyfill/g)) {
                        // for the polyfill, the origin is placed using the default strategy of updating
                        // only when the stage has moved a large distance
                        this._updateDefaultOrigin();
                        // the polyfill does not support reporting an absolute orientation (yet), 
                        // so fall back to the default orientation calculation
                        user.position.setValue(undefined, undefined);
                        user.orientation.setValue(undefined);
                        this._updateDefaultUser();
                    } else {
                        // for real webvr, the origin is always at the stage
                        this.origin.position.setValue(Cartesian3.ZERO, this.stage);
                        this.origin.orientation.setValue(Quaternion.IDENTITY);
                    }
                };
                DeviceService$$1.prototype._hasPolyfillWebVRDisplay = function () {
                    return !!this._vrDisplay && !!this._vrDisplay.displayName.match(/polyfill/g);
                };
                DeviceService$$1.prototype.onRequestPresentHMD = function () {
                    if (this._vrDisplay) {
                        var element = this.viewService.element;
                        var layers = [{
                            source: this.viewService.layers[0] && this.viewService.layers[0].source || element.querySelector('canvas') || element.lastElementChild
                        }];
                        return this._vrDisplay.requestPresent(layers).catch(function (e) {
                            throw e;
                        });
                    }
                    throw new Error('No HMD available');
                };
                DeviceService$$1.prototype.onExitPresentHMD = function () {
                    if (this._vrDisplay && this._vrDisplay.isPresenting) {
                        return this._vrDisplay.exitPresent();
                    }
                    return Promise.resolve();
                };
                DeviceService$$1.prototype.createContextFrameState = function (time, viewport, subviewList, options) {
                    return ArgonSystem.instance.context.createFrameState(time, viewport, subviewList, options);
                };
                DeviceService$$1.prototype.getSubviewEntity = function (index) {
                    var subviewEntity = this.entityService.collection.getOrCreateEntity('ar.device.view_' + index);
                    if (!subviewEntity.position) {
                        subviewEntity.position = new ConstantPositionProperty(Cartesian3.ZERO, this.user);
                    }
                    if (!subviewEntity.orientation) {
                        subviewEntity.orientation = new ConstantProperty(Quaternion.IDENTITY);
                    }
                    return subviewEntity;
                };
                DeviceService$$1.prototype.subscribeGeolocation = function (options, session) {
                    if (session === void 0) {
                        session = this.sessionService.manager;
                    }
                    return this.entityService.subscribe(this.stage.id, options, session).then(function () {});
                };
                DeviceService$$1.prototype.unsubscribeGeolocation = function (session) {
                    if (session === void 0) {
                        session = this.sessionService.manager;
                    }
                    this.entityService.unsubscribe(this.stage.id, session);
                };
                Object.defineProperty(DeviceService$$1.prototype, "isPresentingHMD", {
                    /**
                     * Is the view presenting to an HMD
                     */
                    get: function () {
                        return this._parentState && this._parentState.isPresentingHMD || this._vrDisplay && this._vrDisplay.isPresenting || false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DeviceService$$1.prototype, "isPresentingRealityHMD", {
                    /**
                     * Is the current reality presenting to an HMD
                     */
                    get: function () {
                        return this._parentState && this._parentState.isPresentingRealityHMD || this._vrDisplay && this._vrDisplay.isPresenting && !!this._vrDisplay.displayName.match(/polyfill/g) || false;
                    },
                    enumerable: true,
                    configurable: true
                });
                DeviceService$$1.prototype.requestPresentHMD = function () {
                    if (!this.sessionService.manager.isConnected) throw new Error('Session must be connected');
                    if (this.sessionService.isRealityManager) {
                        return this.onRequestPresentHMD();
                    }
                    return this.sessionService.manager.request('ar.device.requestPresentHMD');
                };
                DeviceService$$1.prototype.exitPresentHMD = function () {
                    if (!this.sessionService.manager.isConnected) throw new Error('Session must be connected');
                    if (this.sessionService.isRealityManager) {
                        return this.onExitPresentHMD();
                    }
                    return this.sessionService.manager.request('ar.device.exitPresentHMD');
                };
                DeviceService$$1.prototype._tryOrientationUpdates = function () {
                    var _this = this;
                    if (typeof window == 'undefined' || !window.addEventListener) return;
                    if (defined(this._deviceOrientationListener)) return;
                    var headingDrift = 0;
                    var alphaOffset = undefined;
                    this._deviceOrientationListener = function (e) {
                        var alphaDegrees = e.alpha;
                        var webkitCompassHeading = e['webkitCompassHeading'];
                        var webkitCompassAccuracy = +e['webkitCompassAccuracy'];
                        if (!defined(alphaDegrees)) {
                            return;
                        }
                        if (e.absolute) {
                            alphaOffset = 0;
                        }
                        // when the phone is almost updside down, webkit flips the compass heading 
                        // (not documented anywhere, annoyingly)
                        // if (e.beta >= 130 || e.beta <= -130) webkitCompassHeading = undefined;
                        _this._deviceOrientationHeadingAccuracy = webkitCompassAccuracy > 0 ? webkitCompassAccuracy : undefined;
                        if ((!defined(alphaOffset) || Math.abs(headingDrift) > 5) && defined(webkitCompassHeading) && webkitCompassAccuracy >= 0 && webkitCompassAccuracy < 80 && webkitCompassHeading >= 0) {
                            if (!defined(alphaOffset)) {
                                alphaOffset = -webkitCompassHeading;
                            } else {
                                alphaOffset -= headingDrift;
                            }
                        }
                        if (!defined(alphaOffset) || !defined(e.alpha) || !defined(e.beta) || !defined(e.gamma)) return;
                        var alpha = CesiumMath.RADIANS_PER_DEGREE * (e.alpha + alphaOffset || -webkitCompassHeading || 0);
                        var beta = CesiumMath.RADIANS_PER_DEGREE * e.beta;
                        var gamma = CesiumMath.RADIANS_PER_DEGREE * e.gamma;
                        var alphaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, alpha, _this._scratchQuaternion);
                        var betaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, beta, _this._scratchQuaternion2);
                        var alphaBetaQuat = Quaternion.multiply(alphaQuat, betaQuat, _this._scratchQuaternion);
                        var gammaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, gamma, _this._scratchQuaternion2);
                        var alphaBetaGammaQuat = Quaternion.multiply(alphaBetaQuat, gammaQuat, _this._scratchQuaternion);
                        // finally, convert from ENU to EUS
                        _this._deviceOrientation = Quaternion.multiply(_this._negX90, alphaBetaGammaQuat, _this._deviceOrientation || new Quaternion()); // rotate from ENU to EUS
                        _this._deviceOrientationHeadingAccuracy = webkitCompassAccuracy;
                        // TODO: fix heading drift calculation (heading should match webkitCompassHeading)
                        // if (defined(webkitCompassHeading)) {
                        //     const q = alphaBetaGammaQuat//utils.getEntityOrientationInReferenceFrame(this.interfaceEntity, JulianDate.now(), this.locationEntity, this._scratchQuaternion1);
                        //     var heading = -Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));
                        //     if (heading < 0) heading += 2*Math.PI;
                        //     const {swing,twist} = swingTwistDecomposition(alphaBetaGammaQuat, Cartesian3.UNIT_Z);
                        //     const twistAngle = 2 * Math.acos(twist.w);
                        //     console.log(twist.w + ' ' + twistAngle * CesiumMath.DEGREES_PER_RADIAN + '\n' + webkitCompassHeading);
                        //     // this._headingDrift = webkitCompassHeading - heading * CesiumMath.DEGREES_PER_RADIAN;
                        // }
                    };
                    if ('ondeviceorientationabsolute' in window) {
                        window.addEventListener('deviceorientationabsolute', this._deviceOrientationListener);
                    } else if ('ondeviceorientation' in window) {
                        window.addEventListener('deviceorientation', this._deviceOrientationListener);
                    }
                };
                DeviceService$$1.prototype._setupVRPresentChangeHandler = function () {
                    var _this = this;
                    if (typeof window !== 'undefined' && window.addEventListener) {
                        this.viewService.viewportModeChangeEvent.addEventListener(function (mode) {
                            if (mode === ViewportMode.PAGE && _this._vrDisplay && _this._vrDisplay.displayName.match(/polyfill/g)) _this.exitPresentHMD();
                        });
                        var currentCanvas_1;
                        var previousPresentationMode_1;
                        var handleVRDisplayPresentChange = function (e) {
                            var viewService = _this.viewService;
                            var display = e.display || e.detail.vrdisplay || e.detail.display;
                            if (display) {
                                if (display.isPresenting) {
                                    _this._vrDisplay = display;
                                    if (display.displayName.match(/polyfill/g)) {
                                        currentCanvas_1 = display.getLayers()[0].source;
                                        if (currentCanvas_1) currentCanvas_1.classList.add('argon-interactive'); // for now, only use webvr when not in Argon
                                        previousPresentationMode_1 = viewService.viewportMode;
                                        viewService.desiredViewportMode = ViewportMode.IMMERSIVE;
                                    }
                                } else {
                                    if (currentCanvas_1 && display.displayName.match(/polyfill/g)) {
                                        currentCanvas_1.classList.remove('argon-interactive'); // for now, only use webvr when not in Argon
                                        currentCanvas_1 = undefined;
                                        viewService.desiredViewportMode = previousPresentationMode_1;
                                    }
                                }
                            }
                        };
                        window.addEventListener('vrdisplaypresentchange', handleVRDisplayPresentChange);
                    }
                };
                return DeviceService$$1;
            }());

            __decorate$3([deprecated$1(), __metadata$3("design:type", Object), __metadata$3("design:paramtypes", [])], DeviceService.prototype, "geolocationDesired", null);
            __decorate$3([deprecated$1(), __metadata$3("design:type", Object), __metadata$3("design:paramtypes", [])], DeviceService.prototype, "geolocationOptions", null);
            __decorate$3([deprecated$1(), __metadata$3("design:type", Function), __metadata$3("design:paramtypes", [typeof (_a$3 = typeof JulianDate !== "undefined" && JulianDate) === "function" && _a$3 || Object, typeof (_b$3 = typeof CanvasViewport !== "undefined" && CanvasViewport) === "function" && _b$3 || Object, typeof (_c$2 = typeof SerializedSubviewList !== "undefined" && SerializedSubviewList) === "function" && _c$2 || Object, Object]), __metadata$3("design:returntype", Object)], DeviceService.prototype, "createContextFrameState", null);
            _export('DeviceService', DeviceService = __decorate$3([autoinject(), __metadata$3("design:paramtypes", [typeof (_d$2 = typeof SessionService !== "undefined" && SessionService) === "function" && _d$2 || Object, typeof (_e$2 = typeof EntityService !== "undefined" && EntityService) === "function" && _e$2 || Object, typeof (_f$1 = typeof ViewService !== "undefined" && ViewService) === "function" && _f$1 || Object, typeof (_g$1 = typeof VisibilityService !== "undefined" && VisibilityService) === "function" && _g$1 || Object])], DeviceService));
            /**
             *
             */

            _export('DeviceServiceProvider', DeviceServiceProvider = function () {
                function DeviceServiceProvider$$1(sessionService, deviceService, viewService, entityService, entityServiceProvider) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.deviceService = deviceService;
                    this.viewService = viewService;
                    this.entityService = entityService;
                    this.entityServiceProvider = entityServiceProvider;
                    this._subscribers = {};
                    this._needsPublish = false;
                    this._publishTime = new JulianDate(0, 0);
                    this._stableState = new DeviceStableState$$1();
                    this._targetGeolocationOptions = {};
                    this._sessionGeolocationOptions = new Map();
                    this._sctachStageCartesian = new Cartesian3();
                    this._scatchStageMatrix4 = new Matrix4();
                    this._scatchStageMatrix3 = new Matrix3();
                    this._scatchStageQuaternion = new Quaternion();
                    this._eastUpSouthToFixedFrame = eastUpSouthToFixedFrame;
                    this._scratchCartographic = new Cartographic();
                    this.entityServiceProvider.targetReferenceFrameMap.set(deviceService.stage.id, ReferenceFrame.FIXED);
                    this.entityServiceProvider.targetReferenceFrameMap.set(deviceService.user.id, deviceService.stage.id);
                    this.sessionService.connectEvent.addEventListener(function (session) {
                        // backwards compat pre-v1.1.8
                        session.on['ar.device.requestFrameState'] = function () {
                            _this._subscribers[session.id] = session;
                            return new Promise(function (resolve) {
                                var remove = _this.deviceService.frameStateEvent.addEventListener(function (frameState) {
                                    resolve(frameState);
                                    remove();
                                });
                            });
                        };
                        session.on['ar.device.startUpdates'] = function () {
                            _this._subscribers[session.id] = session;
                        };
                        session.on['ar.device.stopUpdates'] = function () {
                            delete _this._subscribers[session.id];
                        };
                        // to be removed (subscription options are handled by EntityService now)
                        session.on['ar.device.setGeolocationOptions'] = function (_a) {
                            var options = _a.options;
                            _this._sessionGeolocationOptions.set(session, options);
                            _this._checkDeviceGeolocationSubscribers();
                        };
                        session.on['ar.device.requestPresentHMD'] = function () {
                            return _this.handleRequestPresentHMD(session);
                        };
                        session.on['ar.device.exitPresentHMD'] = function () {
                            return _this.handleExitPresentHMD(session);
                        };
                        session.closeEvent.addEventListener(function () {
                            if (_this._sessionGeolocationOptions.has(session)) {
                                _this._sessionGeolocationOptions.delete(session);
                                _this._checkDeviceGeolocationSubscribers();
                            }
                        });
                        _this._needsPublish = true;
                    });
                    this.entityServiceProvider.sessionSubscribedEvent.addEventListener(function (_a) {
                        var id = _a.id,
                            options = _a.options,
                            session = _a.session;
                        if (_this.deviceService.stage.id === id) {
                            _this._sessionGeolocationOptions.set(session, options);
                            _this._checkDeviceGeolocationSubscribers();
                        }
                    });
                    this.entityServiceProvider.sessionUnsubscribedEvent.addEventListener(function (_a) {
                        var id = _a.id;
                        if (_this.deviceService.stage.id === id) _this._checkDeviceGeolocationSubscribers();
                    });
                    this.deviceService.suggestedGeolocationSubscriptionChangeEvent.addEventListener(function () {
                        _this._needsPublish = true;
                    });
                    this.viewService.viewportChangeEvent.addEventListener(function () {
                        _this._needsPublish = true;
                    });
                    this.viewService.viewportModeChangeEvent.addEventListener(function () {
                        _this._needsPublish = true;
                    });
                    this.deviceService.screenOrientationChangeEvent.addEventListener(function () {
                        _this._needsPublish = true;
                    });
                    this.deviceService.frameStateEvent.addEventListener(function (state) {
                        if (_this._needsPublish || _this._stableState.isPresentingHMD !== _this.deviceService.isPresentingHMD || _this._stableState.isPresentingRealityHMD !== _this.deviceService.isPresentingRealityHMD || CanvasViewport.equals(_this._stableState.viewport, state.viewport) === false) {
                            _this._needsPublish = true;
                        } else if (_this._stableState.subviews) {
                            if (_this._stableState.subviews.length === state.subviews.length) {
                                for (var i = 0; i < state.subviews.length; i++) {
                                    if (!SerializedSubview.equals(state.subviews[i], _this._stableState.subviews[i])) {
                                        _this._needsPublish = true;
                                        break;
                                    }
                                }
                            } else {
                                _this._needsPublish = true;
                            }
                        }
                        if (_this._needsPublish) _this.publishStableState();
                    });
                }
                DeviceServiceProvider$$1.prototype.handleRequestPresentHMD = function (session) {
                    return this.deviceService.requestPresentHMD();
                };
                DeviceServiceProvider$$1.prototype.handleExitPresentHMD = function (session) {
                    return this.deviceService.exitPresentHMD();
                };
                DeviceServiceProvider$$1.prototype.publishStableState = function () {
                    var stableState = this._stableState;
                    stableState.suggestedGeolocationSubscription = this.deviceService.suggestedGeolocationSubscription;
                    stableState.suggestedUserHeight = this.deviceService.suggestedUserHeight;
                    stableState.strict = this.deviceService.strict;
                    stableState.viewport = CanvasViewport.clone(this.deviceService.frameState.viewport, stableState.viewport);
                    stableState.subviews = SerializedSubviewList.clone(this.deviceService.frameState.subviews, stableState.subviews);
                    this.onUpdateStableState(this._stableState);
                    // send stable state to each subscribed session 
                    JulianDate.now(this._publishTime);
                    for (var id in this._subscribers) {
                        var session = this._subscribers[id];
                        if (session.version[0] > 0 && session !== this.sessionService.manager) {
                            for (var k in stableState.entities) {
                                delete stableState.entities[k];
                            }

                            this.entityServiceProvider.fillEntityStateMapForSession(session, this._publishTime, stableState.entities);
                            session.send('ar.device.state', stableState);
                        }
                    }
                    this._needsPublish = false;
                };
                DeviceServiceProvider$$1.prototype.onUpdateStableState = function (stableState) {};
                DeviceServiceProvider$$1.prototype._checkDeviceGeolocationSubscribers = function () {
                    var subscribers = this.entityServiceProvider.subscribersByEntity.get(this.deviceService.stage.id);
                    if (subscribers && subscribers.size > 0) {
                        var reducedOptions_1 = {};
                        this._sessionGeolocationOptions.forEach(function (options, session) {
                            reducedOptions_1.enableHighAccuracy = reducedOptions_1.enableHighAccuracy || options && options.enableHighAccuracy || false;
                        });
                        if (this._targetGeolocationOptions.enableHighAccuracy !== reducedOptions_1.enableHighAccuracy) {
                            this._targetGeolocationOptions = reducedOptions_1;
                        }
                        if (JSON.stringify(this._targetGeolocationOptions) !== JSON.stringify(this._currentGeolocationOptions)) {
                            this._currentGeolocationOptions = this._targetGeolocationOptions;
                            this.onStopGeolocationUpdates();
                            this.onStartGeolocationUpdates(this._targetGeolocationOptions);
                        }
                    } else {
                        this.onStopGeolocationUpdates();
                        this._currentGeolocationOptions = undefined;
                    }
                    this._needsPublish = true;
                };
                DeviceServiceProvider$$1.prototype.configureStage = function (cartographic, geoHorizontalAccuracy, geoVerticalAccuracy) {
                    var _this = this;
                    if (!defined(geoVerticalAccuracy) && cartographic.height === 0) {
                        updateHeightFromTerrain(cartographic).then(function () {
                            return _this.configureStage(cartographic, geoHorizontalAccuracy, 0);
                        });
                        return;
                    }
                    var stage = this.deviceService.stage;
                    var fixedPosition = Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, undefined, this._sctachStageCartesian);
                    var eusTransform = this._eastUpSouthToFixedFrame(fixedPosition, undefined, this._scatchStageMatrix4);
                    var eusRotation = Matrix4.getRotation(eusTransform, this._scatchStageMatrix3);
                    var eusOrientation = Quaternion.fromRotationMatrix(eusRotation, this._scatchStageQuaternion);
                    stage.position = stage.position || new ConstantPositionProperty();
                    stage.orientation = stage.orientation || new ConstantProperty();
                    stage.position.setValue(fixedPosition, ReferenceFrame.FIXED);
                    stage.orientation.setValue(eusOrientation);
                    stage['meta'] = {
                        geoHorizontalAccuracy: geoHorizontalAccuracy,
                        geoVerticalAccuracy: geoVerticalAccuracy
                    };
                };
                /**
                 * Overridable. Should call configureStage when new geolocation is available
                 */
                DeviceServiceProvider$$1.prototype.onStartGeolocationUpdates = function (options) {
                    var _this = this;
                    if (typeof navigator == 'undefined' || !navigator.geolocation) throw new Error('Unable to start geolocation updates');
                    if (!defined(this._geolocationWatchId)) {
                        this._geolocationWatchId = navigator.geolocation.watchPosition(function (pos) {
                            var longDegrees = pos.coords.longitude;
                            var latDegrees = pos.coords.latitude;
                            var altitude = pos.coords.altitude;
                            var cartographic = Cartographic.fromDegrees(longDegrees, latDegrees, altitude || 0, _this._scratchCartographic);
                            _this.configureStage(cartographic, pos.coords.accuracy > 0 ? pos.coords.accuracy : undefined, pos.coords.altitudeAccuracy || undefined);
                        }, function (e) {
                            console.warn('Unable to start geolocation updates: ' + e.message);
                        }, options);
                    }
                };
                /**
                 * Overridable.
                 */
                DeviceServiceProvider$$1.prototype.onStopGeolocationUpdates = function () {
                    if (typeof navigator !== 'undefined' && defined(this._geolocationWatchId)) {
                        navigator.geolocation.clearWatch(this._geolocationWatchId);
                        this._geolocationWatchId = undefined;
                    }
                };
                return DeviceServiceProvider$$1;
            }());

            _export('DeviceServiceProvider', DeviceServiceProvider = __decorate$3([autoinject(), __metadata$3("design:paramtypes", [typeof (_h$1 = typeof SessionService !== "undefined" && SessionService) === "function" && _h$1 || Object, DeviceService, typeof (_j$1 = typeof ViewService !== "undefined" && ViewService) === "function" && _j$1 || Object, typeof (_k$1 = typeof EntityService !== "undefined" && EntityService) === "function" && _k$1 || Object, typeof (_l$1 = typeof EntityServiceProvider !== "undefined" && EntityServiceProvider) === "function" && _l$1 || Object])], DeviceServiceProvider));

            __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$10 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('ContextService', ContextService = function () {
                function ContextService(entityService, sessionService, deviceService, viewService) {
                    var _this = this;
                    this.entityService = entityService;
                    this.sessionService = sessionService;
                    this.deviceService = deviceService;
                    this.viewService = viewService;
                    /**
                     * An event that is raised after managed entities have been updated for
                     * the current frame.
                     */
                    this.updateEvent = new Event$1();
                    /**
                     * An event that is raised when it is an approriate time to render graphics.
                     * This event fires after the update event.
                     */
                    this.renderEvent = new Event$1();
                    /**
                     * An event that is raised after the render event
                     */
                    this.postRenderEvent = new Event$1();
                    /**
                     * An event that fires when the origin changes.
                     */
                    this.originChangeEvent = new Event$1();
                    this._originChanged = false;
                    /**
                     * A monotonically increasing value (in milliseconds) for the current frame state.
                     * This value is useful only for doing accurate *timing*, not for determining
                     * the absolute time. Use [[ContextService.time]] for absolute time.
                     * This value is -1 until the first [[ContextService.updateEvent]].
                     */
                    this.timestamp = -1;
                    /**
                     * The time in milliseconds since the previous timestamp,
                     * capped to [[ContextService.maxDeltaTime]]
                     */
                    this.deltaTime = 0;
                    /**
                     * This value caps the deltaTime for each frame. By default,
                     * the value is 1/3s (333.3ms)
                     */
                    this.maxDeltaTime = 1 / 3 * 1000;
                    /**
                     * The current (absolute) time according to the current reality.
                     * This value is arbitrary until the first [[ContextService.updateEvent]].
                     */
                    this.time = new JulianDate(0, 0);
                    /**
                    * An entity representing the local origin, which is oriented
                    * with +Y up. The local origin changes infrequently, is platform dependent,
                    * and is the suggested origin for a rendering scenegraph.
                    *
                    * Any time the local origin changes, the localOriginChange event is raised.
                    */
                    this.origin = this.entities.add(new Entity({
                        id: 'ar.origin',
                        name: 'Origin',
                        position: new ConstantPositionProperty(undefined, ReferenceFrame.FIXED),
                        orientation: new ConstantProperty(undefined)
                    }));
                    this._localOrigin = this.entities.add(new Entity({
                        id: 'ar.localOrigin',
                        name: 'Local Origin',
                        position: new ConstantPositionProperty(Cartesian3.ZERO, this.origin),
                        orientation: new ConstantProperty(Quaternion.IDENTITY)
                    }));
                    this._localOriginEastNorthUp = this.entities.add(new Entity({
                        id: 'ar.localOriginENU',
                        name: 'Local Origin (ENU)',
                        position: new ConstantPositionProperty(Cartesian3.ZERO, this.localOriginEastNorthUp),
                        orientation: new ConstantProperty(Quaternion.fromAxisAngle(Cartesian3.UNIT_X, -Math.PI / 2))
                    }));
                    /**
                     * A coordinate system representing the physical space in which the user is free to
                     * move around, positioned on the surface the user is standing on,
                     * where +X is east, +Y is up, and +Z is south (East-Up-South), if geolocation is known.
                     * If the stage is not geolocated, then the +X and +Z directions are arbitrary.
                     */
                    this.stage = this.entities.add(new Entity({
                        id: 'ar.stage',
                        name: 'Stage',
                        position: new ConstantPositionProperty(undefined, ReferenceFrame.FIXED),
                        orientation: new ConstantProperty(undefined)
                    }));
                    /**
                     * A coordinate system representing the floor.
                     * While the `stage` always represents a physical surface,
                     * the `floor` entity may represent a virtual floor.
                     */
                    this.floor = this.entities.add(new Entity({
                        id: 'ar.floor',
                        name: 'Floor',
                        position: new ConstantPositionProperty(Cartesian3.ZERO, this.stage),
                        orientation: new ConstantProperty(Quaternion.IDENTITY)
                    }));
                    /**
                     * An coordinate system representing the user,
                     * where +X is right, +Y is up, and -Z is the direction the user is facing
                     */
                    this.user = this.entities.add(new Entity({
                        id: 'ar.user',
                        name: 'User',
                        position: new ConstantPositionProperty(undefined, this.stage),
                        orientation: new ConstantProperty(undefined)
                    }));
                    /**
                     * An coordinate system representing the rendering view,
                     * where +X is right, +Y is up, and -Z is the direction of the view.
                     */
                    this.view = this.entities.add(new Entity({
                        id: 'ar.view',
                        name: 'View',
                        position: new ConstantPositionProperty(Cartesian3.ZERO, this.user),
                        orientation: new ConstantProperty(Quaternion.IDENTITY)
                    }));
                    /**
                     * The default reference frame to use when calling `getEntityPose`.
                     * By default, this is the `origin` reference frame.
                     */
                    this.defaultReferenceFrame = this.origin;
                    this._entityPoseMap = new Map();
                    this._updatingEntities = new Set();
                    this._knownEntities = new Set();
                    this._scratchCartesian = new Cartesian3();
                    this._scratchQuaternion = new Quaternion();
                    this._scratchFrustum = new PerspectiveFrustum();
                    /**
                     * Subscribe to pose updates for the given entity id
                     *
                     * @returns A Promise that resolves to a new or existing entity
                     * instance matching the given id, if the subscription is successful
                     */
                    this.subscribe = this.entityService.subscribe.bind(this.entityService);
                    /**
                     * Unsubscribe to pose updates for the given entity id
                     */
                    this.unsubscribe = this.entityService.unsubscribe.bind(this.entityService);
                    this._stringIdentifierFromReferenceFrame = stringIdentifierFromReferenceFrame;
                    this._frameIndex = -1;
                    this._scratchFrameState = {
                        time: {},
                        entities: {},
                        viewport: {},
                        subviews: []
                    };
                    this._getSerializedEntityState = getSerializedEntityState;
                    this._getEntityPositionInReferenceFrame = getEntityPositionInReferenceFrame;
                    this._getEntityOrientationInReferenceFrame = getEntityOrientationInReferenceFrame;
                    this._scratchMatrix3 = new Matrix3();
                    this._scratchMatrix4 = new Matrix4();
                    this.sessionService.manager.on['ar.context.update'] = function (state) {
                        var scratchFrustum = _this._scratchFrustum;
                        // backwards-compat
                        if (typeof state.reality !== 'string') {
                            state.reality = state.reality && state.reality['uri'];
                        }
                        if (!state.viewport && state['view'] && state['view'].viewport) {
                            state.viewport = state['view'].viewport;
                        }
                        if (!state.subviews && state['view'] && state['view'].subviews) {
                            state.subviews = state['view'].subviews;
                            scratchFrustum.near = DEFAULT_NEAR_PLANE;
                            scratchFrustum.far = DEFAULT_FAR_PLANE;
                            for (var _i = 0, _a = state.subviews; _i < _a.length; _i++) {
                                var s = _a[_i];
                                var frustum = s['frustum'];
                                scratchFrustum.xOffset = frustum.xOffset || 0;
                                scratchFrustum.yOffset = frustum.yOffset || 0;
                                scratchFrustum.fov = frustum.fov || CesiumMath.PI_OVER_THREE;
                                scratchFrustum.aspectRatio = frustum.aspectRatio || 1;
                                s.projectionMatrix = Matrix4.clone(scratchFrustum.projectionMatrix, s.projectionMatrix);
                            }
                        }
                        if (!state.entities[_this.user.id] && state['view'] && state['view'].pose) {
                            state.entities[_this.user.id] = state['view'].pose;
                        }
                        // end backwards-compat
                        _this._update(state);
                    };
                    this.origin.definitionChanged.addEventListener(function (origin, property) {
                        if (property === 'position' || property === 'orientation') {
                            if (origin.position) {
                                origin.position.definitionChanged.addEventListener(function () {
                                    _this._originChanged = true;
                                });
                            }
                            if (origin.orientation) {
                                origin.orientation.definitionChanged.addEventListener(function () {
                                    _this._originChanged = true;
                                });
                            }
                            _this._originChanged = true;
                        }
                    });
                    this._scratchFrustum.near = DEFAULT_NEAR_PLANE;
                    this._scratchFrustum.far = DEFAULT_FAR_PLANE;
                    this._scratchFrustum.fov = CesiumMath.PI_OVER_THREE;
                    this._scratchFrustum.aspectRatio = 1;
                    this._serializedFrameState = {
                        reality: undefined,
                        time: JulianDate.now(),
                        entities: {},
                        viewport: new CanvasViewport(),
                        subviews: [{
                            type: SubviewType.SINGULAR,
                            viewport: new Viewport(),
                            projectionMatrix: this._scratchFrustum.projectionMatrix
                        }]
                    };
                }
                Object.defineProperty(ContextService.prototype, "entities", {
                    get: function () {
                        return this.entityService.collection;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "localOriginChangeEvent", {
                    /**
                     * An event that fires when the local origin changes.
                     */
                    get: function () {
                        return this.originChangeEvent;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ContextService.prototype, "localOrigin", {
                    /** alias for origin */
                    get: function () {
                        return this._localOrigin;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "localOriginEastUpSouth", {
                    // To be removed. This is no longer useful.
                    get: function () {
                        return this._localOrigin;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "localOriginEastNorthUp", {
                    // To be removed. This is no longer useful.
                    get: function () {
                        return this._localOriginEastNorthUp;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "geoposeHeadingAccuracy", {
                    /**
                     * If geopose is available, this is the accuracy of the user's heading
                     */
                    get: function () {
                        return this.stage['meta'].geoposeHeadingAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "geoposeHorizontalAccuracy", {
                    /**
                     * If geopose is available, this is the accuracy of the user's cartographic location
                     */
                    get: function () {
                        return this.stage['meta'].geoposeHorizontalAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "geoposeVerticalAccuracy", {
                    /**
                     * If geopose is available, this is the accuracy of the user's elevation
                     */
                    get: function () {
                        return this.stage['meta'].geoposeVerticalAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "serializedFrameState", {
                    /**
                     * The serialized frame state for this frame
                     */
                    get: function () {
                        return this._serializedFrameState;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "systemTime", {
                    /**
                     * Deprecated. Use timestamp property.
                     * @private
                     */
                    get: function () {
                        return this.timestamp;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Deprecated. To be removed.
                 * @private
                 */
                ContextService.prototype.getTime = function () {
                    return this.time;
                };
                /**
                 * Deprecated. To be removed. Use the defaultReferenceFrame property if necessary.
                 * @private
                 */
                ContextService.prototype.setDefaultReferenceFrame = function (origin) {
                    this.defaultReferenceFrame = origin;
                };
                /**
                 * Deprecated. To be removed.  Use the defaultReferenceFrame property.
                 * @private
                 */
                ContextService.prototype.getDefaultReferenceFrame = function () {
                    return this.defaultReferenceFrame;
                };
                /**
                 * Subscribe to pose updates for an entity specified by the given id
                 *
                 * @deprecated Use [[ContextService#subscribe]]
                 * @param id - the id of the desired entity
                 * @returns A new or existing entity instance matching the given id
                 */
                ContextService.prototype.subscribeToEntityById = function (id) {
                    this.subscribe(id);
                    return this.entities.getOrCreateEntity(id);
                };
                /**
                 * Get the cartographic position of an Entity for the current context time
                 */
                ContextService.prototype.getEntityCartographic = function (entity, result) {
                    return this.entityService.getCartographic(entity, this.time, result);
                };
                /**
                 * Deprecated. Use `EntityService.createFixed` (`app.entity.createFixed`);
                 */
                ContextService.prototype.createGeoEntity = function (cartographic, localToFixed) {
                    return this.entityService.createFixed(cartographic, localToFixed);
                };
                /**
                 * Create a new EntityPose instance to represent the pose of an entity
                 * relative to a given reference frame. If no reference frame is specified,
                 * then the pose is based on the context's defaultReferenceFrame.
                 *
                 * @param entityOrId - the entity to track
                 * @param referenceFrameOrId - The intended reference frame. Defaults to `this.defaultReferenceFrame`.
                 */
                ContextService.prototype.createEntityPose = function (entityOrId, referenceFrameOrId) {
                    if (referenceFrameOrId === void 0) {
                        referenceFrameOrId = this.defaultReferenceFrame;
                    }
                    return this.entityService.createEntityPose(entityOrId, referenceFrameOrId);
                };
                /**
                 * Gets the current pose of an entity, relative to a given reference frame.
                 *
                 * @deprecated
                 * @param entityOrId - The entity whose state is to be queried.
                 * @param referenceFrameOrId - The intended reference frame. Defaults to `this.defaultReferenceFrame`.
                 */
                ContextService.prototype.getEntityPose = function (entityOrId, referenceFrameOrId) {
                    if (referenceFrameOrId === void 0) {
                        referenceFrameOrId = this.defaultReferenceFrame;
                    }
                    var key = this._stringIdentifierFromReferenceFrame(entityOrId) + '@' + this._stringIdentifierFromReferenceFrame(referenceFrameOrId);
                    var entityPose = this._entityPoseMap.get(key);
                    if (!entityPose) {
                        entityPose = this.entityService.createEntityPose(entityOrId, referenceFrameOrId);
                        this._entityPoseMap.set(key, entityPose);
                    }
                    entityPose.update(this.time);
                    return entityPose;
                };
                /**
                 * Process the next frame state (which should come from the current reality viewer)
                 */
                ContextService.prototype.submitFrameState = function (frameState) {
                    frameState.index = ++this._frameIndex;
                    this._update(frameState);
                };
                /**
                 * Create a frame state.
                 *
                 * @param time
                 * @param viewport
                 * @param subviewList
                 * @param user
                 * @param entityOptions
                 */
                ContextService.prototype.createFrameState = function (time, viewport, subviewList, options) {
                    var overrideUser = options && options.overrideUser;
                    if (this.deviceService.strict) {
                        if (overrideUser) {
                            console.warn('The `overrideUser` flag is set, but the device is in strict mode');
                            overrideUser = false;
                        }
                    }
                    var frameState = this._scratchFrameState;
                    frameState.time = JulianDate.clone(time, frameState.time);
                    frameState.viewport = CanvasViewport.clone(viewport, frameState.viewport);
                    frameState.subviews = SerializedSubviewList.clone(subviewList, frameState.subviews);
                    var entities = frameState.entities = {};
                    var getSerializedEntityState$$1 = this._getSerializedEntityState;
                    // stage
                    var stage = this.stage;
                    if (options && options.overrideStage) {
                        entities[stage.id] = getSerializedEntityState$$1(stage, time, undefined);
                    }
                    // user
                    var user = this.user;
                    if (overrideUser) {
                        entities[user.id] = getSerializedEntityState$$1(user, time, stage);
                    }
                    // view
                    var view = this.view;
                    if (options && options.overrideView) {
                        entities[view.id] = getSerializedEntityState$$1(view, time, user);
                    }
                    // subviews
                    for (var index = 0; index < subviewList.length; index++) {
                        // check for valid projection matrices
                        var subview = subviewList[index];
                        if (!isFinite(subview.projectionMatrix[0])) throw new Error('Invalid projection matrix (contains non-finite values)');
                        if (options && options.overrideSubviews) {
                            var subviewEntity = this.getSubviewEntity(index);
                            entities[subviewEntity.id] = getSerializedEntityState$$1(subviewEntity, time, view);
                        }
                    }
                    // floor
                    var floorOffset = options && options.floorOffset || 0;
                    var floor = this.floor;
                    floor.position.setValue(Cartesian3.fromElements(0, floorOffset, 0, this._scratchCartesian), stage);
                    if (floorOffset !== 0) {
                        frameState.entities[this.floor.id] = getSerializedEntityState$$1(floor, time, stage);
                    }
                    return frameState;
                };
                // All of the following work is only necessary when running in an old manager (version === 0)
                ContextService.prototype._updateBackwardsCompatability = function (frameState) {
                    this._knownEntities.clear();
                    // update the entities the manager knows about
                    var entityService = this.entityService;
                    for (var id in frameState.entities) {
                        entityService.updateEntityFromSerializedState(id, frameState.entities[id]);
                        this._updatingEntities.add(id);
                        this._knownEntities.add(id);
                    }
                    // if the mangager didn't send us an update for a particular entity,
                    // assume the manager no longer knows about it
                    for (var _i = 0, _a = this._updatingEntities; _i < _a.length; _i++) {
                        var id = _a[_i];
                        if (!this._knownEntities.has(id)) {
                            var entity = this.entities.getById(id);
                            if (entity) {
                                if (entity.position) entity.position.setValue(undefined);
                                if (entity.orientation) entity.orientation.setValue(undefined);
                            }
                            this._updatingEntities.delete(id);
                        }
                    }
                    // If running within an older manager, we have to set the stage based on the user pose. 
                    var userPositionFixed = this._getEntityPositionInReferenceFrame(this.user, frameState.time, ReferenceFrame.FIXED, this._scratchCartesian);
                    if (userPositionFixed) {
                        var eusToFixedFrameTransform = eastUpSouthToFixedFrame(userPositionFixed, undefined, this._scratchMatrix4);
                        var eusRotationMatrix = Matrix4.getRotation(eusToFixedFrameTransform, this._scratchMatrix3);
                        var eusOrientation = Quaternion.fromRotationMatrix(eusRotationMatrix);
                        this.stage.position.setValue(userPositionFixed, ReferenceFrame.FIXED);
                        this.stage.orientation.setValue(eusOrientation);
                    } else {
                        this.stage.position.setValue(Cartesian3.fromElements(0, -this.deviceService.suggestedUserHeight, 0, this._scratchCartesian), this.user.position.referenceFrame);
                        this.stage.orientation.setValue(Quaternion.IDENTITY);
                    }
                    frameState.entities[this.stage.id] = true; // assume overriden for _update
                };
                // TODO: This function is called a lot. Potential for optimization. 
                ContextService.prototype._update = function (frameState) {
                    this._serializedFrameState = frameState;
                    var time = frameState.time;
                    var entities = frameState.entities;
                    // update our time values
                    var timestamp = performance.now();
                    this.deltaTime = Math.min(timestamp - this.timestamp, this.maxDeltaTime);
                    this.timestamp = timestamp;
                    JulianDate.clone(frameState.time, this.time);
                    // update provided entities
                    if (this.sessionService.manager.isConnected && this.sessionService.manager.version[0] === 0) {
                        this._updateBackwardsCompatability(frameState);
                    } else {
                        var entityService = this.entityService;
                        for (var id in entities) {
                            entityService.updateEntityFromSerializedState(id, entities[id]);
                        }
                    }
                    // update stage entity
                    var deviceStage = this.deviceService.stage;
                    var contextStage = this.stage;
                    if (entities[contextStage.id] === undefined) {
                        var contextStagePosition = contextStage.position;
                        var contextStageOrientation = contextStage.orientation;
                        contextStagePosition.setValue(Cartesian3.ZERO, deviceStage);
                        contextStageOrientation.setValue(Quaternion.IDENTITY);
                    }
                    // update user entity
                    var deviceUser = this.deviceService.user;
                    var contextUser = this.user;
                    if (entities[contextUser.id] === undefined) {
                        var userPositionValue = this._getEntityPositionInReferenceFrame(deviceUser, time, deviceStage, this._scratchCartesian);
                        var userOrientationValue = this._getEntityOrientationInReferenceFrame(deviceUser, time, deviceStage, this._scratchQuaternion);
                        var contextUserPosition = contextUser.position;
                        var contextUserOrientation = contextUser.orientation;
                        contextUserPosition.setValue(userPositionValue, contextStage);
                        contextUserOrientation.setValue(userOrientationValue);
                    }
                    // update view entity
                    var contextView = this.view;
                    if (entities[contextView.id] === undefined) {
                        var contextViewPosition = contextView.position;
                        var contextViewOrientation = contextView.orientation;
                        contextViewPosition.setValue(Cartesian3.ZERO, contextUser);
                        contextViewOrientation.setValue(Quaternion.IDENTITY);
                    }
                    // update subview entities
                    for (var i = 0; i < frameState.subviews.length; i++) {
                        if (entities['ar.view_' + i] === undefined) {
                            var deviceSubview = this.deviceService.getSubviewEntity(i);
                            var contextSubview = this.getSubviewEntity(i);
                            var subviewPositionValue = this._getEntityPositionInReferenceFrame(deviceSubview, time, deviceUser, this._scratchCartesian);
                            var subviewOrientationValue = this._getEntityOrientationInReferenceFrame(deviceSubview, time, deviceUser, this._scratchQuaternion);
                            var contextSubviewPosition = contextSubview.position;
                            var contextSubviewOrientation = contextSubview.orientation;
                            contextSubviewPosition.setValue(subviewPositionValue, contextView);
                            contextSubviewOrientation.setValue(subviewOrientationValue);
                        }
                    }
                    // update floor entity
                    if (entities[this.floor.id] === undefined) {
                        var floorPosition = this.floor.position;
                        floorPosition.setValue(Cartesian3.ZERO, contextStage);
                    }
                    // update origin entity
                    if (entities[this.origin.id] === undefined) {
                        var deviceOrigin = this.deviceService.origin;
                        var contextOrigin = this.origin;
                        var deviceOriginPositionValue = this._getEntityPositionInReferenceFrame(deviceOrigin, time, deviceStage, this._scratchCartesian);
                        var deviceOriginOrientationValue = this._getEntityOrientationInReferenceFrame(deviceOrigin, time, deviceStage, this._scratchQuaternion);
                        var contextOriginPosition = contextOrigin.position;
                        var contextOriginOrientation = contextOrigin.orientation;
                        contextOriginPosition.setValue(deviceOriginPositionValue, contextStage);
                        contextOriginOrientation.setValue(deviceOriginOrientationValue);
                    }
                    // update view
                    this.viewService._processContextFrameState(frameState, this);
                    // TODO: realityService._processContextFrameState(frameState); 
                    // raise events for the user to update and render the scene
                    if (this._originChanged) {
                        this._originChanged = false;
                        var originPosition = this.origin.position;
                        console.log('Updated context origin to ' + JSON.stringify(originPosition['_value']) + " at " + this._stringIdentifierFromReferenceFrame(originPosition.referenceFrame));
                        this.originChangeEvent.raiseEvent(undefined);
                    }
                    this.updateEvent.raiseEvent(this);
                    this.renderEvent.raiseEvent(this);
                    this.postRenderEvent.raiseEvent(this);
                    // submit frame if necessary
                    var vrDisplay = this.deviceService.vrDisplay;
                    if (this.deviceService.autoSubmitFrame && vrDisplay && vrDisplay.isPresenting) {
                        vrDisplay.submitFrame();
                    }
                };
                ContextService.prototype.getSubviewEntity = function (index) {
                    var subviewEntity = this.entityService.collection.getOrCreateEntity('ar.view_' + index);
                    if (!subviewEntity.position) {
                        subviewEntity.position = new ConstantPositionProperty(Cartesian3.ZERO, this.user);
                    }
                    if (!subviewEntity.orientation) {
                        subviewEntity.orientation = new ConstantProperty(Quaternion.IDENTITY);
                    }
                    return subviewEntity;
                };
                ContextService.prototype.subscribeGeolocation = function (options) {
                    return this.entityService.subscribe(this.stage.id, options).then(function () {});
                };
                ContextService.prototype.unsubscribeGeolocation = function () {
                    this.entityService.unsubscribe(this.stage.id);
                };
                Object.defineProperty(ContextService.prototype, "geoHeadingAccuracy", {
                    get: function () {
                        return this.user['meta'] && this.user['meta'].geoHeadingAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "geoHorizontalAccuracy", {
                    get: function () {
                        return this.user['meta'] && this.user['meta'].geoHorizontalAccuracy || this.stage['meta'] && this.stage['meta'].geoHorizontalAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "geoVerticalAccuracy", {
                    get: function () {
                        return this.user['meta'] && this.user['meta'].geoVerticalAccuracy || this.stage['meta'] && this.stage['meta'].geoVerticalAccuracy;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ContextService;
            }());

            __decorate$10([deprecated$1('originChangeEvent'), __metadata$10("design:type", Object), __metadata$10("design:paramtypes", [])], ContextService.prototype, "localOriginChangeEvent", null);
            __decorate$10([deprecated$1('origin'), __metadata$10("design:type", Object), __metadata$10("design:paramtypes", [])], ContextService.prototype, "localOrigin", null);
            __decorate$10([deprecated$1(), __metadata$10("design:type", Object), __metadata$10("design:paramtypes", [])], ContextService.prototype, "localOriginEastUpSouth", null);
            __decorate$10([deprecated$1(), __metadata$10("design:type", Object), __metadata$10("design:paramtypes", [])], ContextService.prototype, "localOriginEastNorthUp", null);
            __decorate$10([deprecated$1('timestamp'), __metadata$10("design:type", Object), __metadata$10("design:paramtypes", [])], ContextService.prototype, "systemTime", null);
            __decorate$10([deprecated$1('time'), __metadata$10("design:type", Function), __metadata$10("design:paramtypes", []), __metadata$10("design:returntype", typeof (_a$10 = typeof JulianDate !== "undefined" && JulianDate) === "function" && _a$10 || Object)], ContextService.prototype, "getTime", null);
            __decorate$10([deprecated$1(), __metadata$10("design:type", Function), __metadata$10("design:paramtypes", [typeof (_b$10 = typeof Entity !== "undefined" && Entity) === "function" && _b$10 || Object]), __metadata$10("design:returntype", void 0)], ContextService.prototype, "setDefaultReferenceFrame", null);
            __decorate$10([deprecated$1('defaultReferenceFrame'), __metadata$10("design:type", Function), __metadata$10("design:paramtypes", []), __metadata$10("design:returntype", typeof (_c$6 = typeof Entity !== "undefined" && Entity) === "function" && _c$6 || Object)], ContextService.prototype, "getDefaultReferenceFrame", null);
            __decorate$10([deprecated$1('subscribe'), __metadata$10("design:type", Function), __metadata$10("design:paramtypes", [String]), __metadata$10("design:returntype", typeof (_d$5 = typeof Entity !== "undefined" && Entity) === "function" && _d$5 || Object)], ContextService.prototype, "subscribeToEntityById", null);
            __decorate$10([deprecated$1('EntityService.createFixed'), __metadata$10("design:type", Function), __metadata$10("design:paramtypes", [typeof (_e$5 = typeof Cartographic !== "undefined" && Cartographic) === "function" && _e$5 || Object, Object]), __metadata$10("design:returntype", void 0)], ContextService.prototype, "createGeoEntity", null);
            _export('ContextService', ContextService = __decorate$10([autoinject(), __metadata$10("design:paramtypes", [typeof (_f$3 = typeof EntityService !== "undefined" && EntityService) === "function" && _f$3 || Object, typeof (_g$3 = typeof SessionService !== "undefined" && SessionService) === "function" && _g$3 || Object, typeof (_h$3 = typeof DeviceService !== "undefined" && DeviceService) === "function" && _h$3 || Object, typeof (_j$2 = typeof ViewService !== "undefined" && ViewService) === "function" && _j$2 || Object])], ContextService));

            _export('ContextServiceProvider', ContextServiceProvider = function () {
                function ContextServiceProvider(sessionService, contextService, entityServiceProvider, permissionServiceProvider) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.contextService = contextService;
                    this.entityServiceProvider = entityServiceProvider;
                    this.permissionServiceProvider = permissionServiceProvider;
                    this._cacheTime = new JulianDate(0, 0);
                    this._sessionEntities = {};
                    this._temp = {};
                    this.desiredGeolocationOptions = {};
                    this.sessionGeolocationOptions = new Map();
                    this.entityServiceProvider.targetReferenceFrameMap.set(this.contextService.stage.id, ReferenceFrame.FIXED);
                    // subscribe to context geolocation if any child sessions have subscribed
                    this.entityServiceProvider.sessionSubscribedEvent.addEventListener(function (evt) {
                        if (evt.id === _this.contextService.stage.id && evt.session !== _this.sessionService.manager) {
                            _this._setGeolocationOptions(evt.session, evt.options);
                            _this.contextService.subscribeGeolocation(_this.desiredGeolocationOptions);
                        }
                    });
                    // unsubscribe from context geolocation if all child sessions are unsubscribed
                    this.entityServiceProvider.sessionUnsubscribedEvent.addEventListener(function () {
                        var subscribers = _this.entityServiceProvider.subscribersByEntity.get(_this.contextService.stage.id);
                        if (subscribers && subscribers.size === 1 && subscribers.has(_this.sessionService.manager)) {
                            _this.contextService.unsubscribeGeolocation();
                        }
                    });
                    // publish updates to child sessions
                    this.contextService.updateEvent.addEventListener(function () {
                        _this._publishUpdates();
                    });
                }
                ContextServiceProvider.prototype._publishUpdates = function () {
                    var state = this.contextService.serializedFrameState;
                    this._cacheTime = JulianDate.clone(state.time, this._cacheTime);
                    for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
                        var session = _a[_i];
                        if (Role.isRealityAugmenter(session.info.role)) this._sendUpdateForSession(state, session);
                    }
                };
                ContextServiceProvider.prototype._sendUpdateForSession = function (state, session) {
                    var sessionEntities = this._sessionEntities;
                    var entityServiceProvider = this.entityServiceProvider;
                    // clear session entities
                    for (var id in sessionEntities) {
                        delete sessionEntities[id];
                    }
                    // reference all entities from the primary frame state
                    if (state.entities) {
                        for (var id in state.entities) {
                            sessionEntities[id] = state.entities[id];
                        }
                    }
                    // always send the origin state
                    sessionEntities[this.contextService.origin.id] = entityServiceProvider.getCachedSerializedEntityState(this.contextService.origin, state.time);
                    // get subscribed entitiesfor the session
                    var subscriptions = entityServiceProvider.subscriptionsBySubscriber.get(session);
                    // exclude the stage state unless it is explicitly subscribed 
                    var contextService = this.contextService;
                    var contextStageId = contextService.stage.id;
                    if (!subscriptions[contextStageId]) delete sessionEntities[contextStageId];
                    // add the entity states for all subscribed entities
                    var iter = subscriptions.keys();
                    var item;
                    while (item = iter.next(), !item.done) {
                        var id_1 = item.value;
                        var entity = contextService.entities.getById(id_1);
                        sessionEntities[id_1] = entityServiceProvider.getCachedSerializedEntityState(entity, state.time);
                    }
                    // remove stage updates if geolocation permission is not granted
                    if (this.permissionServiceProvider.getPermissionState(session, contextStageId) != PermissionState.GRANTED) delete sessionEntities[contextStageId];
                    // recycle the frame state object, but with the session entities
                    var parentEntities = state.entities;
                    state.entities = sessionEntities;
                    state.time = state.time;
                    state.sendTime = JulianDate.now(state.sendTime);
                    if (session.version[0] === 0) {
                        for (var _i = 0, _a = state.subviews; _i < _a.length; _i++) {
                            var s = _a[_i];
                            s['frustum'] = s['frustum'] || decomposePerspectiveProjectionMatrix(s.projectionMatrix, {});
                        }
                        var view = this._temp;
                        view.viewport = state.viewport;
                        view.subviews = state.subviews;
                        view.pose = state.entities['ar.user'];
                        delete state.subviews;
                        delete state.viewport;
                        delete state.entities['ar.user'];
                        state['view'] = view;
                        session.send('ar.context.update', state);
                        delete state['view'];
                        state.viewport = view.viewport;
                        state.subviews = view.subviews;
                    } else if (session.version[0] === 1 && session.version[1] === 1 && state.entities['ar.user']) {
                        state.entities['ar.user'].r = 'ar.stageEUS';
                        session.send('ar.context.update', state);
                        state.entities['ar.user'].r = 'ar.stage';
                    } else {
                        session.send('ar.context.update', state);
                    }
                    // restore the parent entities
                    state.entities = parentEntities;
                };
                ContextServiceProvider.prototype._setGeolocationOptions = function (session, options) {
                    var _this = this;
                    this.sessionGeolocationOptions.set(session, options);
                    session.closeEvent.addEventListener(function () {
                        _this.sessionGeolocationOptions.delete(session);
                        _this._updateDesiredGeolocationOptions();
                    });
                    this._updateDesiredGeolocationOptions();
                };
                ContextServiceProvider.prototype._updateDesiredGeolocationOptions = function () {
                    var reducedOptions = {};
                    this.sessionGeolocationOptions.forEach(function (options, session) {
                        reducedOptions.enableHighAccuracy = reducedOptions.enableHighAccuracy || options && options.enableHighAccuracy || false;
                    });
                    if (this.desiredGeolocationOptions.enableHighAccuracy !== reducedOptions.enableHighAccuracy) {
                        this.desiredGeolocationOptions = reducedOptions;
                    }
                };
                return ContextServiceProvider;
            }());

            _export('ContextServiceProvider', ContextServiceProvider = __decorate$10([autoinject(), __metadata$10("design:paramtypes", [typeof (_k$2 = typeof SessionService !== "undefined" && SessionService) === "function" && _k$2 || Object, ContextService, typeof (_l$2 = typeof EntityServiceProvider !== "undefined" && EntityServiceProvider) === "function" && _l$2 || Object, typeof (_m$1 = typeof PermissionServiceProvider !== "undefined" && PermissionServiceProvider) === "function" && _m$1 || Object])], ContextServiceProvider));

            _export('RealityViewer', RealityViewer = function () {
                function RealityViewer(uri) {
                    var _this = this;
                    this.uri = uri;
                    this.providedReferenceFrames = [];
                    this.connectEvent = new Event$1();
                    this.presentChangeEvent = new Event$1();
                    this._isPresenting = false;
                    this.connectEvent.addEventListener(function (session) {
                        if (_this._session) _this._session.close();
                        _this._session = session;
                        session.closeEvent.addEventListener(function () {
                            if (_this._session === session) _this._session = undefined;
                        });
                    });
                }
                Object.defineProperty(RealityViewer.prototype, "isPresenting", {
                    get: function () {
                        return this._isPresenting;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RealityViewer.prototype, "session", {
                    get: function () {
                        return this._session;
                    },
                    enumerable: true,
                    configurable: true
                });
                RealityViewer.prototype.destroy = function () {
                    this.setPresenting(false);
                    if (this.session) {
                        this.session.close();
                    }
                };

                RealityViewer.prototype.setPresenting = function (flag) {
                    if (this._isPresenting !== flag) {
                        this._isPresenting = flag;
                        this.presentChangeEvent.raiseEvent(undefined);
                    }
                };
                RealityViewer.getType = function (uri) {
                    if (uri === undefined) return undefined;
                    if (uri.split(':')[0] === 'reality') {
                        return uri;
                    }
                    return 'hosted';
                };
                return RealityViewer;
            }());

            RealityViewer.DEFAULT = 'reality:default';
            RealityViewer.EMPTY = 'reality:empty';
            RealityViewer.LIVE = 'reality:live';

            __extends$2 = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __decorate$11 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$11 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('EmptyRealityViewer', EmptyRealityViewer = function (_super) {
                __extends$2(EmptyRealityViewer, _super);
                function EmptyRealityViewer(sessionService, viewService, container, uri) {
                    var _this = _super.call(this, uri) || this;
                    _this.sessionService = sessionService;
                    _this.viewService = viewService;
                    _this.container = container;
                    _this.uri = uri;
                    _this.type = 'empty';
                    _this._moveFlags = {
                        moveForward: false,
                        moveBackward: false,
                        moveUp: false,
                        moveDown: false,
                        moveLeft: false,
                        moveRight: false
                    };
                    _this._scratchMatrix3 = new Matrix3();
                    _this._scratchMatrix4 = new Matrix4();
                    function getFlagForKeyCode(keyCode) {
                        switch (keyCode) {
                            case 'W'.charCodeAt(0):
                                return 'moveForward';
                            case 'S'.charCodeAt(0):
                                return 'moveBackward';
                            case 'E'.charCodeAt(0):
                                return 'moveUp';
                            case 'R'.charCodeAt(0):
                                return 'moveDown';
                            case 'D'.charCodeAt(0):
                                return 'moveRight';
                            case 'A'.charCodeAt(0):
                                return 'moveLeft';
                            default:
                                return undefined;
                        }
                    }
                    var keydownListener = function (e) {
                        var flagName = getFlagForKeyCode(e.keyCode);
                        if (typeof flagName !== 'undefined') {
                            _this._moveFlags[flagName] = true;
                        }
                    };
                    var keyupListener = function (e) {
                        var flagName = getFlagForKeyCode(e.keyCode);
                        if (typeof flagName !== 'undefined') {
                            _this._moveFlags[flagName] = false;
                        }
                    };
                    if (typeof document !== 'undefined') {
                        _this.presentChangeEvent.addEventListener(function () {
                            if (_this.isPresenting) {
                                if (!_this._aggregator && _this.viewService.element) {
                                    _this.viewService.element['disableRootEvents'] = true;
                                    _this._aggregator = new CameraEventAggregator(_this.viewService.element);
                                    document.addEventListener('keydown', keydownListener, false);
                                    document && document.addEventListener('keyup', keyupListener, false);
                                }
                            } else {
                                _this._aggregator && _this._aggregator.destroy();
                                _this._aggregator = undefined;
                                document && document.removeEventListener('keydown', keydownListener);
                                document && document.removeEventListener('keyup', keyupListener);
                                for (var k in _this._moveFlags) {
                                    _this._moveFlags[k] = false;
                                }
                            }
                        });
                    }
                    return _this;
                }
                EmptyRealityViewer.prototype.load = function () {
                    var _this = this;
                    // Create a child container so that we can conveniently setup all the services
                    // that would exist in a normal hosted reality viewer 
                    var child = this.container.createChild();
                    // Create the session instance that will be used by the managerto talk to the reality 
                    var session = this.sessionService.addManagedSessionPort(this.uri);
                    session.connectEvent.addEventListener(function () {
                        _this.connectEvent.raiseEvent(session); // let the manager know the session is ready
                    });
                    // use a SessionConnectService to create a connection via the session instance we created
                    child.registerInstance(ConnectService, new SessionConnectService(session, this.sessionService.configuration));
                    // setup the configuration for our empty reality
                    child.registerInstance(Configuration, {
                        role: Role.REALITY_VIEWER,
                        uri: this.uri,
                        title: 'Empty',
                        version: this.sessionService.configuration.version,
                        supportsCustomProtocols: true,
                        protocols: ['ar.configureStage@v1']
                    });
                    // Create the basic services that we need to use. 
                    // Note: we won't create a child ViewService here,
                    // as we are already managing the DOM with the
                    // ViewService that exists in the root container. 
                    child.autoRegisterAll([SessionService, EntityService, VisibilityService, ContextService, DeviceService, RealityService]);
                    var childContextService = child.get(ContextService);
                    var childDeviceService = child.get(DeviceService);
                    var childSessionService = child.get(SessionService);
                    var childRealityService = child.get(RealityService);
                    var customStagePosition;
                    var customStageOrientation;
                    // Create protocol handlers for `ar.configureStage` protocol
                    childRealityService.connectEvent.addEventListener(function (session) {
                        session.on['ar.configureStage.setStageGeolocation'] = function (_a) {
                            var geolocation = _a.geolocation;
                            customStagePosition = Cartesian3.fromRadians(geolocation.longitude, geolocation.latitude, geolocation.height, undefined, customStagePosition);
                            var transformMatrix = eastUpSouthToFixedFrame(customStagePosition, undefined, _this._scratchMatrix4);
                            var rotationMatrix = Matrix4.getRotation(transformMatrix, _this._scratchMatrix3);
                            customStageOrientation = Quaternion.fromRotationMatrix(rotationMatrix, customStageOrientation);
                        };
                        session.on['ar.configureStage.resetStageGeolocation'] = function () {
                            customStagePosition = undefined;
                            customStageOrientation = undefined;
                        };
                    });
                    // Setup everything after connected to the manager. The manager only connects once.
                    childSessionService.manager.connectEvent.addEventListener(function () {
                        // since we aren't create a child view service and viewport service, 
                        // suppress any errors from not handling these messages
                        childSessionService.manager.suppressErrorOnUnknownTopic = true;
                        var scratchQuaternion = new Quaternion();
                        var scratchQuaternionDragYaw = new Quaternion();
                        // const pitchQuat = new Quaternion;
                        var positionScratchCartesian = new Cartesian3();
                        var movementScratchCartesian = new Cartesian3();
                        var orientationMatrix = new Matrix3();
                        var up = new Cartesian3(0, 0, 1);
                        var right = new Cartesian3(1, 0, 0);
                        var forward = new Cartesian3(0, -1, 0);
                        var scratchFrustum = new PerspectiveFrustum();
                        var deviceStage = childDeviceService.stage;
                        var deviceUser = childDeviceService.user;
                        var NEGATIVE_UNIT_Z = new Cartesian3(0, 0, -1);
                        // const X_90ROT = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, CesiumMath.PI_OVER_TWO);
                        var subviews = [];
                        var deviceUserPose = childContextService.createEntityPose(deviceUser, deviceStage);
                        var checkSuggestedGeolocationSubscription = function () {
                            if (childDeviceService.suggestedGeolocationSubscription) {
                                childDeviceService.subscribeGeolocation(childDeviceService.suggestedGeolocationSubscription);
                            } else {
                                childDeviceService.unsubscribeGeolocation();
                            }
                        };
                        checkSuggestedGeolocationSubscription();
                        var remove1 = childDeviceService.suggestedGeolocationSubscriptionChangeEvent.addEventListener(checkSuggestedGeolocationSubscription);
                        var remove2 = childDeviceService.frameStateEvent.addEventListener(function (frameState) {
                            if (childSessionService.manager.isClosed) return;
                            var aggregator = _this._aggregator;
                            var flags = _this._moveFlags;
                            if (!_this.isPresenting) {
                                aggregator && aggregator.reset();
                                return;
                            }
                            SerializedSubviewList.clone(frameState.subviews, subviews);
                            // provide fov controls
                            if (!childDeviceService.strict) {
                                decomposePerspectiveProjectionMatrix(subviews[0].projectionMatrix, scratchFrustum);
                                scratchFrustum.fov = _this.viewService.subviews[0] && _this.viewService.subviews[0].frustum.fov || CesiumMath.PI_OVER_THREE;
                                if (aggregator && aggregator.isMoving(CameraEventType.WHEEL)) {
                                    var wheelMovement = aggregator.getMovement(CameraEventType.WHEEL);
                                    var diff = wheelMovement.endPosition.y;
                                    scratchFrustum.fov = Math.min(Math.max(scratchFrustum.fov - diff * 0.02, Math.PI / 8), Math.PI - Math.PI / 8);
                                }
                                if (aggregator && aggregator.isMoving(CameraEventType.PINCH)) {
                                    var pinchMovement = aggregator.getMovement(CameraEventType.PINCH);
                                    var diff = pinchMovement.distance.endPosition.y - pinchMovement.distance.startPosition.y;
                                    scratchFrustum.fov = Math.min(Math.max(scratchFrustum.fov - diff * 0.02, Math.PI / 8), Math.PI - Math.PI / 8);
                                }
                                subviews.forEach(function (s) {
                                    var aspect = s.viewport.width / s.viewport.height;
                                    scratchFrustum.aspectRatio = isFinite(aspect) ? aspect : 1;
                                    Matrix4.clone(scratchFrustum.projectionMatrix, s.projectionMatrix);
                                });
                            }
                            var time = frameState.time;
                            deviceUserPose.update(time);
                            var overrideUser = !(deviceUserPose.status & PoseStatus.KNOWN);
                            // provide controls if the device does not have a physical pose
                            if (overrideUser) {
                                var contextUser = childContextService.user;
                                var contextStage = childContextService.stage;
                                var position = getEntityPositionInReferenceFrame(contextUser, time, contextStage, positionScratchCartesian) || Cartesian3.fromElements(0, childDeviceService.suggestedUserHeight, 0, positionScratchCartesian);
                                var orientation = getEntityOrientationInReferenceFrame(contextUser, time, contextStage, scratchQuaternion) || Quaternion.clone(Quaternion.IDENTITY, scratchQuaternion);
                                if (aggregator && aggregator.isMoving(CameraEventType.LEFT_DRAG)) {
                                    var dragMovement = aggregator.getMovement(CameraEventType.LEFT_DRAG);
                                    if (orientation) {
                                        // const dragPitch = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, frustum.fov * (dragMovement.endPosition.y - dragMovement.startPosition.y) / app.view.getViewport().height, scratchQuaternionDragPitch);
                                        var dragYaw = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, scratchFrustum.fov * (dragMovement.endPosition.x - dragMovement.startPosition.x) / frameState.viewport.width, scratchQuaternionDragYaw);
                                        // const drag = Quaternion.multiply(dragPitch, dragYaw, dragYaw);
                                        orientation = Quaternion.multiply(orientation, dragYaw, dragYaw);
                                        contextUser.orientation.setValue(orientation);
                                    }
                                }
                                Matrix3.fromQuaternion(orientation, orientationMatrix);
                                Matrix3.multiplyByVector(orientationMatrix, Cartesian3.UNIT_Y, up);
                                Matrix3.multiplyByVector(orientationMatrix, Cartesian3.UNIT_X, right);
                                Matrix3.multiplyByVector(orientationMatrix, NEGATIVE_UNIT_Z, forward);
                                var moveRate = 0.02;
                                if (flags.moveForward) {
                                    Cartesian3.multiplyByScalar(forward, moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                if (flags.moveBackward) {
                                    Cartesian3.multiplyByScalar(forward, -moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                if (flags.moveUp) {
                                    Cartesian3.multiplyByScalar(up, moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                if (flags.moveDown) {
                                    Cartesian3.multiplyByScalar(up, -moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                if (flags.moveLeft) {
                                    Cartesian3.multiplyByScalar(right, -moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                if (flags.moveRight) {
                                    Cartesian3.multiplyByScalar(right, moveRate, movementScratchCartesian);
                                    Cartesian3.add(position, movementScratchCartesian, position);
                                }
                                contextUser.position.setValue(position, contextStage);
                                contextUser.orientation.setValue(orientation);
                            }
                            var overrideStage = customStagePosition && customStageOrientation ? true : false;
                            if (overrideStage) {
                                var contextStage = childContextService.stage;
                                contextStage.position.setValue(customStagePosition, ReferenceFrame.FIXED);
                                contextStage.orientation.setValue(customStageOrientation);
                            }
                            var contextFrameState = childContextService.createFrameState(time, frameState.viewport, subviews, {
                                overrideUser: overrideUser,
                                overrideStage: overrideStage
                            });
                            childContextService.submitFrameState(contextFrameState);
                            aggregator && aggregator.reset();
                        });
                        childSessionService.manager.closeEvent.addEventListener(function () {
                            remove1();
                            remove2();
                        });
                    });
                    childSessionService.connect();
                };
                return EmptyRealityViewer;
            }(RealityViewer));

            _export('EmptyRealityViewer', EmptyRealityViewer = __decorate$11([inject(SessionService, ViewService, Container), __metadata$11("design:paramtypes", [typeof (_a$11 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$11 || Object, typeof (_b$11 = typeof ViewService !== "undefined" && ViewService) === "function" && _b$11 || Object, typeof (_c$7 = typeof Container !== "undefined" && Container) === "function" && _c$7 || Object, String])], EmptyRealityViewer));

            __extends$3 = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __decorate$12 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$12 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('LiveRealityViewer', LiveRealityViewer = function (_super) {
                __extends$3(LiveRealityViewer, _super);
                function LiveRealityViewer(sessionService, viewService, contextService, deviceService, uri) {
                    var _this = _super.call(this, uri) || this;
                    _this.sessionService = sessionService;
                    _this.viewService = viewService;
                    _this.contextService = contextService;
                    _this.deviceService = deviceService;
                    _this.uri = uri;
                    if (typeof document !== 'undefined') {
                        _this.settingsIframe = document.createElement('iframe');
                        _this.settingsIframe.width = '0';
                        _this.settingsIframe.height = '0';
                        _this.settingsIframe.src = 'https://argonjs.io/tools.argonjs.io/';
                        _this.settingsIframe.style.display = 'none';
                        _this.videoFov = Math.PI / 2;
                        _this.videoElement = document.createElement('video');
                        _this.videoElement.style.width = '100%';
                        _this.videoElement.style.height = 'height:100%';
                        _this.videoElement.controls = false;
                        _this.videoElement.autoplay = true;
                        _this.videoElement.style.display = 'none';
                        _this.videoElement.style.zIndex = "-100";
                        var viewElement = _this.viewService.element;
                        viewElement.insertBefore(_this.settingsIframe, viewElement.firstChild);
                        viewElement.insertBefore(_this.videoElement, viewElement.firstChild);
                        _this.canvas = document.createElement('canvas');
                        _this.context = _this.canvas.getContext('2d');
                        window.addEventListener('message', function (event) {
                            var origin = event.origin;
                            if (origin === 'http://argonjs.io') {
                                _this.videoFov = event.data; // TODO: this is not flexible. Should be passing an object with message type and data
                            }
                        });
                    }
                    _this.presentChangeEvent.addEventListener(function () {
                        if (typeof document !== 'undefined') {
                            _this.videoElement.style.display = _this.isPresenting ? 'initial' : 'none';
                        }
                    });
                    return _this;
                }
                LiveRealityViewer.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    if (typeof document !== 'undefined') {
                        this.settingsIframe.remove();
                        this.videoElement.remove();
                        this.canvas.remove();
                    }
                };
                LiveRealityViewer.prototype.setupInternalSession = function (internalSession) {
                    var _this = this;
                    internalSession.connectEvent.addEventListener(function () {
                        if (_this.videoElement) {
                            var videoElement_1 = _this.videoElement;
                            var mediaDevices = navigator.mediaDevices;
                            var getUserMedia = (mediaDevices.getUserMedia || mediaDevices['mozGetUserMedia'] || mediaDevices['msGetUserMedia'] || mediaDevices['webkitGetUserMedia']).bind(mediaDevices);
                            getUserMedia({ audio: false, video: true }).then(function (videoStream) {
                                var stopVideoStream = function () {
                                    for (var _i = 0, _a = videoStream.getTracks(); _i < _a.length; _i++) {
                                        var t = _a[_i];
                                        t.stop();
                                    }
                                };
                                if (internalSession.isConnected) {
                                    videoElement_1.src = window.URL.createObjectURL(videoStream);
                                    internalSession.closeEvent.addEventListener(stopVideoStream);
                                } else {
                                    stopVideoStream();
                                }
                            }).catch(function (error) {
                                internalSession.errorEvent.raiseEvent(error);
                            });
                            // const viewService = this.viewService;
                            var lastFrameTime_1 = -1;
                            var remove1_1 = _this.deviceService.suggestedGeolocationSubscriptionChangeEvent.addEventListener(function () {
                                if (_this.deviceService.suggestedGeolocationSubscription) {
                                    _this.deviceService.subscribeGeolocation(_this.deviceService.suggestedGeolocationSubscription, internalSession);
                                } else {
                                    _this.deviceService.unsubscribeGeolocation();
                                }
                            });
                            var remove2_1 = _this.deviceService.frameStateEvent.addEventListener(function (frameState) {
                                if (videoElement_1.currentTime != lastFrameTime_1) {
                                    lastFrameTime_1 = videoElement_1.currentTime;
                                    // const videoWidth = videoElement.videoWidth;
                                    // const videoHeight = videoElement.videoHeight;
                                    var contextFrameState = _this.contextService.createFrameState(frameState.time, frameState.viewport, frameState.subviews);
                                    internalSession.send('ar.reality.frameState', contextFrameState);
                                }
                            });
                            internalSession.closeEvent.addEventListener(function () {
                                remove1_1();
                                remove2_1();
                            });
                        }
                    });
                };
                LiveRealityViewer.prototype.load = function () {
                    var _this = this;
                    var session = this.sessionService.addManagedSessionPort(this.uri);
                    session.connectEvent.addEventListener(function () {
                        _this.connectEvent.raiseEvent(session);
                    });
                    var internalSession = this.sessionService.createSessionPort(this.uri);
                    internalSession.suppressErrorOnUnknownTopic = true;
                    this.setupInternalSession(internalSession);
                    // Only connect after the caller is able to attach connectEvent handlers
                    Promise.resolve().then(function () {
                        if (_this.sessionService.manager.isClosed) return;
                        var messageChannel = _this.sessionService.createSynchronousMessageChannel();
                        session.open(messageChannel.port1, _this.sessionService.configuration);
                        internalSession.open(messageChannel.port2, { role: Role.REALITY_VIEWER, title: 'Live', uri: _this.uri, version: _this.sessionService.configuration.version });
                    });
                };
                LiveRealityViewer.isAvailable = function () {
                    if (typeof navigator !== 'undefined' && navigator.mediaDevices) {
                        var mediaDevices = navigator.mediaDevices;
                        return !!(mediaDevices.getUserMedia || mediaDevices['mozGetUserMedia'] || mediaDevices['msGetUserMedia'] || mediaDevices['webkitGetUserMedia']);
                    } else {
                        return false;
                    }
                };
                LiveRealityViewer.prototype.getVideoFrame = function (x, y, width, height) {
                    this.canvas.width = this.videoElement.videoWidth;
                    this.canvas.height = this.videoElement.videoHeight;
                    this.context.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);
                    return this.context.getImageData(x, y, width, height);
                };
                return LiveRealityViewer;
            }(RealityViewer));

            _export('LiveRealityViewer', LiveRealityViewer = __decorate$12([inject(SessionService, ViewService, ContextService, DeviceService), __metadata$12("design:paramtypes", [typeof (_a$12 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$12 || Object, typeof (_b$12 = typeof ViewService !== "undefined" && ViewService) === "function" && _b$12 || Object, typeof (_c$8 = typeof ContextService !== "undefined" && ContextService) === "function" && _c$8 || Object, typeof (_d$6 = typeof DeviceService !== "undefined" && DeviceService) === "function" && _d$6 || Object, String])], LiveRealityViewer));

            __extends$4 = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __decorate$13 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$13 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('HostedRealityViewer', HostedRealityViewer = function (_super) {
                __extends$4(HostedRealityViewer, _super);
                function HostedRealityViewer(sessionService, viewService, uri) {
                    var _this = _super.call(this, uri) || this;
                    _this.sessionService = sessionService;
                    _this.viewService = viewService;
                    _this.uri = uri;
                    _this.type = 'hosted';
                    if (typeof document !== 'undefined' && document.createElement) {
                        var iframeElement = _this.iframeElement = document.createElement('iframe');
                        iframeElement.name = createGuid();
                        iframeElement.style.border = '0';
                        iframeElement.width = '100%';
                        iframeElement.height = '100%';
                        iframeElement.style.position = 'absolute';
                        iframeElement.style.opacity = '0';
                        iframeElement.style.pointerEvents = 'none';
                        iframeElement.style.zIndex = "-100";
                        var viewElement = _this.viewService.element;
                        viewElement.insertBefore(iframeElement, viewElement.firstChild);
                        _this.presentChangeEvent.addEventListener(function () {
                            _this.iframeElement.style.opacity = _this.isPresenting ? '1' : '0';
                        });
                    }
                    return _this;
                }
                HostedRealityViewer.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    if (this.iframeElement) {
                        this.iframeElement.remove();
                    }
                };
                HostedRealityViewer.prototype.load = function () {
                    var _this = this;
                    if (typeof document !== 'undefined' && document.createElement) {
                        var session_1 = this.sessionService.addManagedSessionPort(this.uri);
                        session_1.connectEvent.addEventListener(function () {
                            if (_this.sessionService.manager.isClosed) return;
                            _this.connectEvent.raiseEvent(session_1);
                        });
                        var handleConnectMessage_1 = function (ev) {
                            if (ev.data.type !== 'ARGON_SESSION') return;
                            var name = ev.data.name;
                            var messagePort = ev.ports && ev.ports[0];
                            if (!messagePort) throw new Error('Received an ARGON_SESSION message without a MessagePort object');
                            if (name !== _this.iframeElement.name) return;
                            window.removeEventListener('message', handleConnectMessage_1);
                            session_1.open(messagePort, _this.sessionService.configuration);
                        };
                        window.addEventListener('message', handleConnectMessage_1);
                        this.iframeElement.src = '';
                        this.iframeElement.src = this.uri;
                    }
                };
                return HostedRealityViewer;
            }(RealityViewer));

            _export('HostedRealityViewer', HostedRealityViewer = __decorate$13([inject(SessionService, ViewService), __metadata$13("design:paramtypes", [typeof (_a$13 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$13 || Object, typeof (_b$13 = typeof ViewService !== "undefined" && ViewService) === "function" && _b$13 || Object, String])], HostedRealityViewer));

            __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$9 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('RealityViewerFactory', RealityViewerFactory = function () {
                function RealityViewerFactory(_createEmptyReality, _createLiveReality, _createHostedReality) {
                    this._createEmptyReality = _createEmptyReality;
                    this._createLiveReality = _createLiveReality;
                    this._createHostedReality = _createHostedReality;
                }
                RealityViewerFactory.prototype.createRealityViewer = function (uri) {
                    switch (RealityViewer.getType(uri)) {
                        case RealityViewer.EMPTY:
                            return this._createEmptyReality(uri);
                        case RealityViewer.LIVE:
                            return this._createLiveReality(uri);
                        case 'hosted':
                            return this._createHostedReality(uri);
                        default:
                            throw new Error('Unsupported Reality Viewer: ' + uri);
                    }
                };
                return RealityViewerFactory;
            }());

            _export('RealityViewerFactory', RealityViewerFactory = __decorate$9([inject(Factory.of(EmptyRealityViewer), Factory.of(LiveRealityViewer), Factory.of(HostedRealityViewer)), __metadata$9("design:paramtypes", [Object, Object, Object])], RealityViewerFactory));
            /**
            * A service which makes requests to manage the reality viewer.
            */

            _export('RealityService', RealityService = function () {
                // private _scratchFrustum = new PerspectiveFrustum();
                function RealityService(sessionService, contextService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.contextService = contextService;
                    this._connectEvent = new Event$1();
                    this._sessions = [];
                    this._changeEvent = new Event$1();
                    /**
                     * The default Reality Viewer.
                     */
                    this.default = RealityViewer.EMPTY;
                    sessionService.manager.on['ar.reality.connect'] = function (_a) {
                        var id = _a.id;
                        var realityControlSession = _this.sessionService.createSessionPort(id);
                        var messageChannel = _this.sessionService.createSynchronousMessageChannel();
                        var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
                        var SEND_MESSAGE_KEY = 'ar.reality.message.send.' + id;
                        var CLOSE_SESSION_KEY = 'ar.reality.close.' + id;
                        messageChannel.port1.onmessage = function (msg) {
                            _this.sessionService.manager.send(ROUTE_MESSAGE_KEY, msg.data);
                        };
                        _this.sessionService.manager.on[SEND_MESSAGE_KEY] = function (message) {
                            messageChannel.port1.postMessage(message);
                        };
                        _this.sessionService.manager.on[CLOSE_SESSION_KEY] = function () {
                            realityControlSession.close();
                        };
                        realityControlSession.connectEvent.addEventListener(function () {
                            _this.sessions.push(realityControlSession);
                            _this.connectEvent.raiseEvent(realityControlSession);
                            realityControlSession.closeEvent.addEventListener(function () {
                                var idx = _this.sessions.indexOf(realityControlSession);
                                _this.sessions.splice(idx, 1);
                            });
                        });
                        _this.sessionService.manager.closeEvent.addEventListener(function () {
                            realityControlSession.close();
                            delete _this.sessionService.manager.on[SEND_MESSAGE_KEY];
                            delete _this.sessionService.manager.on[CLOSE_SESSION_KEY];
                        });
                        realityControlSession.open(messageChannel.port2, _this.sessionService.configuration);
                    };
                    var i = 0;
                    this.contextService.updateEvent.addEventListener(function () {
                        var frameState = _this.contextService.serializedFrameState;
                        if (sessionService.isRealityViewer && sessionService.manager.isConnected) {
                            // backwards compatability
                            if (sessionService.manager.isConnected && sessionService.manager.version[0] === 0) {
                                var eye = frameState['eye'] = frameState['eye'] || {};
                                eye.pose = frameState.entities['ar.user'];
                                eye.viewport = Viewport.clone(frameState.subviews[0].viewport, eye.viewport);
                                delete frameState.entities['ar.user'];
                                // throttle for 30fps
                                i++ % 2 === 0 && sessionService.manager.send('ar.reality.frameState', frameState);
                                frameState.entities['ar.user'] = eye.pose;
                            } else {
                                sessionService.manager.send('ar.reality.frameState', frameState);
                            }
                        }
                        var current = frameState.reality;
                        var previous = _this._current;
                        if (previous !== current) {
                            _this._current = current;
                            _this.changeEvent.raiseEvent({ previous: previous, current: current });
                        }
                    });
                }
                Object.defineProperty(RealityService.prototype, "connectEvent", {
                    /**
                     * An event that provides a session for sending / receiving
                     * commands to / from a reality.
                     *
                     * The session passed via this event can represent either endpoint of
                     * a connection between RealityViewer <--> RealityAugmenter/RealityManager.
                     *
                     * If running in a RealityAugmenter, the session
                     * represents a connection to a RealityViewer.
                     *
                     * If running in a RealityViewer, the session
                     * represents a connection to a RealityAugmenter.
                     */
                    get: function () {
                        return this._connectEvent;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(RealityService.prototype, "sessions", {
                    /**
                     * A collection of connected sessions.
                     *
                     * If running in a RealityAugmenter, this collection
                     * represents connections to any loaded RealityViewers.
                     *
                     * If running in a RealityViewer, this collection
                     * represents connections to any RealityAugmenters.
                     */
                    get: function () {
                        return this._sessions;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(RealityService.prototype, "changeEvent", {
                    /**
                     * An event that is raised when the presenting reality viewer is changed.
                     */
                    get: function () {
                        return this._changeEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RealityService.prototype, "current", {
                    /**
                     * The URI for the currently presenting Reality Viewer.
                     */
                    get: function () {
                        return this._current;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Install the specified reality viewer
                 */
                RealityService.prototype.install = function (uri) {
                    var _this = this;
                    return this.sessionService.manager.whenConnected().then(function () {
                        if (_this.sessionService.manager.version[0] >= 1 !== true) return Promise.reject(new Error('Not supported'));
                        return _this.sessionService.manager.request('ar.reality.install', { uri: uri });
                    });
                };
                /**
                 * Uninstall the specified reality viewer
                 */
                RealityService.prototype.uninstall = function (uri) {
                    var _this = this;
                    return this.sessionService.manager.whenConnected().then(function () {
                        if (_this.sessionService.manager.version[0] >= 1 !== true) return Promise.reject(new Error('Not supported'));
                        return _this.sessionService.manager.request('ar.reality.uninstall', { uri: uri });
                    });
                };
                /**
                 * Request a reality viewer to be presented.
                 * - Pass a url to request a (custum) hosted reality viewer
                 * - [[RealityViewer.DEFAULT]] to request the system default reality viewer
                 * - [[RealityViewer.LIVE]] to request a live reality viewer
                 * - [[RealityViewer.EMPTY]] to request an empty reality viewer
                 */
                RealityService.prototype.request = function (uri) {
                    var _this = this;
                    return this.sessionService.manager.whenConnected().then(function () {
                        if (_this.sessionService.manager.version[0] >= 1 !== true) return _this.sessionService.manager.request('ar.reality.desired', { reality: { uri: uri } });
                        return _this.sessionService.manager.request('ar.reality.request', { uri: uri });
                    });
                };
                /**
                 * Deprecated. Use [[RealityService#request]]
                 * @deprecated
                 */
                RealityService.prototype.setDesired = function (reality) {
                    this.request(reality ? reality.uri : RealityViewer.DEFAULT);
                };
                /**
                 * Ask a reality to move the stage to the given geolocation
                 */
                RealityService.prototype.setStageGeolocation = function (realitySession, geolocation) {
                    if (!realitySession.supportsProtocol('ar.configureStage')) return Promise.reject('Protocol `ar.configureStage` is not supported');
                    return realitySession.request('ar.configureStage.setStageGeolocation', { geolocation: geolocation });
                };
                /**
                 * Ask a reality to move the stage to the given geolocation
                 */
                RealityService.prototype.resetStageGeolocation = function (realitySession) {
                    if (!realitySession.supportsProtocol('ar.configureStage')) return Promise.reject('Protocol `ar.configureStage` is not supported');
                    return realitySession.request('ar.configureStage.resetStageGeolocation');
                };
                return RealityService;
            }());

            __decorate$9([deprecated$1('request'), __metadata$9("design:type", Function), __metadata$9("design:paramtypes", [Object]), __metadata$9("design:returntype", void 0)], RealityService.prototype, "setDesired", null);
            _export('RealityService', RealityService = __decorate$9([autoinject(), __metadata$9("design:paramtypes", [typeof (_a$9 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$9 || Object, typeof (_b$9 = typeof ContextService !== "undefined" && ContextService) === "function" && _b$9 || Object])], RealityService));

            _export('RealityServiceProvider', RealityServiceProvider = function () {
                function RealityServiceProvider(sessionService, realityService, contextService, deviceService, viewServiceProvider, visibilityServiceProvider, focusServiceProvider, realityViewerFactory) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.realityService = realityService;
                    this.contextService = contextService;
                    this.deviceService = deviceService;
                    this.viewServiceProvider = viewServiceProvider;
                    this.visibilityServiceProvider = visibilityServiceProvider;
                    this.focusServiceProvider = focusServiceProvider;
                    this.realityViewerFactory = realityViewerFactory;
                    /**
                     * An event that is raised when a reality viewer is installed.
                     */
                    this.installedEvent = new Event$1();
                    /**
                     * An event that is raised when a reality viewer is uninstalled.
                     */
                    this.uninstalledEvent = new Event$1();
                    this._viewerByURI = new Map();
                    this._installersByURI = new Map();
                    this._scratchFrustum = new PerspectiveFrustum();
                    sessionService.ensureIsRealityManager();
                    sessionService.manager.connectEvent.addEventListener(function () {
                        setTimeout(function () {
                            if (!_this._presentingRealityViewer && _this.realityService.default) _this._handleRequest(_this.sessionService.manager, {
                                uri: _this.realityService.default
                            });
                        });
                    });
                    sessionService.manager.closeEvent.addEventListener(function () {
                        _this._viewerByURI.forEach(function (v) {
                            v.destroy();
                        });
                    });
                    sessionService.connectEvent.addEventListener(function (session) {
                        if (!Role.isRealityViewer(session.info.role)) {
                            session.on['ar.reality.install'] = function (_a) {
                                var uri = _a.uri;
                                return _this._handleInstall(session, uri);
                            };
                            session.on['ar.reality.uninstall'] = function (_a) {
                                var uri = _a.uri;
                                return _this._handleUninstall(session, uri);
                            };
                            session.on['ar.reality.request'] = function (message) {
                                return _this._handleRequest(session, message);
                            };
                            // For backwards compatability. 
                            session.on['ar.reality.desired'] = function (message) {
                                var reality = message.reality;
                                if (reality) {
                                    if (reality['type']) {
                                        var type = reality['type'];
                                        reality.uri = reality.uri || 'reality:' + type;
                                        if (type === 'hosted') reality.uri = reality['url'];
                                    }
                                }
                                _this._handleRequest(session, { uri: reality.uri });
                            };
                        }
                    });
                    this.viewServiceProvider.forwardedUIEvent.addEventListener(function (uievent) {
                        var session = _this._presentingRealityViewer && _this._presentingRealityViewer.session;
                        if (session) _this.viewServiceProvider.sendUIEventToSession(uievent, session);
                    });
                }
                Object.defineProperty(RealityServiceProvider.prototype, "presentingRealityViewer", {
                    get: function () {
                        return this._presentingRealityViewer;
                    },
                    enumerable: true,
                    configurable: true
                });
                RealityServiceProvider.prototype._handleInstall = function (session, uri) {
                    var _this = this;
                    var installers = this._installersByURI.get(uri);
                    if (installers) {
                        installers.add(session);
                    } else {
                        var viewer_1 = this.realityViewerFactory.createRealityViewer(uri);
                        this._viewerByURI.set(uri, viewer_1);
                        installers = new Set();
                        installers.add(session);
                        this._installersByURI.set(uri, installers);
                        viewer_1.connectEvent.addEventListener(function (viewerSession) {
                            if (_this.sessionService.manager.isClosed) return;
                            if (!Role.isRealityViewer(viewerSession.info.role)) {
                                viewerSession.sendError({ message: "Expected a reality viewer" });
                                viewerSession.close();
                                throw new Error('The application "' + viewerSession.uri + '" does not support being loaded as a reality viewer');
                            }
                            viewerSession.on['ar.reality.frameState'] = function (frame) {
                                if (_this._presentingRealityViewer === viewer_1) {
                                    if (viewerSession.version[0] === 0) {
                                        var deviceState = _this.deviceService.frameState;
                                        if (!deviceState) return;
                                        frame.viewport = CanvasViewport.clone(deviceState.viewport, frame.viewport);
                                        frame.subviews = SerializedSubviewList.clone(deviceState.subviews, frame.subviews);
                                        var eye = frame['eye'];
                                        var eyePose = eye.pose;
                                        var eyeFov = eye.fov;
                                        frame.entities = frame.entities || {};
                                        frame.entities['ar.user'] = eyePose;
                                        for (var _i = 0, _a = frame.subviews; _i < _a.length; _i++) {
                                            var s = _a[_i];
                                            var f = decomposePerspectiveProjectionMatrix(s.projectionMatrix, s['frustum'] || {});
                                            f.fov = eyeFov;
                                            _this._scratchFrustum.clone(f);
                                            s.projectionMatrix = Matrix4.clone(_this._scratchFrustum.projectionMatrix, s.projectionMatrix);
                                        }
                                    }
                                    frame.reality = viewer_1.uri;
                                    _this.contextService.submitFrameState(frame);
                                }
                            };
                            if (viewerSession.info['supportsCustomProtocols']) {
                                _this._connectViewerWithSession(viewerSession, _this.sessionService.manager);
                                for (var _i = 0, _a = _this.sessionService.managedSessions; _i < _a.length; _i++) {
                                    session = _a[_i];
                                    _this._connectViewerWithSession(viewerSession, session);
                                }
                                var remove_1 = _this.sessionService.connectEvent.addEventListener(function (session) {
                                    _this._connectViewerWithSession(viewerSession, session);
                                });
                                viewerSession.closeEvent.addEventListener(function () {
                                    return remove_1();
                                });
                            }
                            var removePresentChangeListener = viewer_1.presentChangeEvent.addEventListener(function () {
                                _this.visibilityServiceProvider.set(viewerSession, viewer_1.isPresenting);
                            });
                            _this.visibilityServiceProvider.set(viewerSession, viewer_1.isPresenting);
                            viewerSession.closeEvent.addEventListener(function () {
                                removePresentChangeListener();
                                _this.contextService.entities.removeById(viewerSession.uri);
                                console.log('Reality session closed: ' + uri);
                            });
                        });
                        viewer_1.load();
                        this.installedEvent.raiseEvent({ viewer: viewer_1 });
                    }
                };
                RealityServiceProvider.prototype._connectViewerWithSession = function (viewerSession, session) {
                    if (Role.isRealityViewer(session.info.role)) return;
                    var id = createGuid();
                    var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
                    var SEND_MESSAGE_KEY = 'ar.reality.message.send.' + id;
                    var CLOSE_SESSION_KEY = 'ar.reality.close.' + id;
                    viewerSession.on[ROUTE_MESSAGE_KEY] = function (message) {
                        session.send(SEND_MESSAGE_KEY, message);
                    };
                    session.on[ROUTE_MESSAGE_KEY] = function (message) {
                        viewerSession.send(SEND_MESSAGE_KEY, message);
                    };
                    viewerSession.send('ar.reality.connect', { id: id });
                    session.send('ar.reality.connect', { id: id });
                    viewerSession.closeEvent.addEventListener(function () {
                        session.send(CLOSE_SESSION_KEY);
                    });
                    session.closeEvent.addEventListener(function () {
                        viewerSession.send(CLOSE_SESSION_KEY);
                    });
                };
                RealityServiceProvider.prototype._handleUninstall = function (session, uri) {
                    var installers = this._installersByURI.get(uri);
                    if (installers) {
                        if (installers.size === 0) {
                            var viewer = this._viewerByURI.get(uri);
                            this._viewerByURI.delete(uri);
                            viewer.destroy();
                            this.uninstalledEvent.raiseEvent({ viewer: viewer });
                        }
                    }
                    return Promise.reject(new Error("Unable to uninstall a reality viewer which is not installed"));
                };
                RealityServiceProvider.prototype._handleRequest = function (session, options) {
                    if (this.focusServiceProvider.session === session || session === this.sessionService.manager) {
                        var uri = options && options.uri || RealityViewer.DEFAULT;
                        switch (uri) {
                            case RealityViewer.DEFAULT:
                                uri = this.realityService.default;
                        }
                        this._handleInstall(session, uri);
                        this._setPresentingRealityViewer(this._viewerByURI.get(uri));
                        return Promise.resolve();
                    }
                    throw new Error('Request Denied');
                };
                RealityServiceProvider.prototype._setPresentingRealityViewer = function (viewer) {
                    if (!viewer) throw new Error('Invalid State. Expected a RealityViewer instance');
                    if (this._presentingRealityViewer === viewer) return;
                    this._viewerByURI.forEach(function (v) {
                        v.setPresenting(v === viewer);
                    });
                    this._presentingRealityViewer = viewer;
                    console.log('Presenting reality viewer changed to: ' + viewer.uri);
                };
                RealityServiceProvider.prototype.getViewerByURI = function (uri) {
                    return this._viewerByURI.get(uri);
                };
                RealityServiceProvider.prototype.removeInstaller = function (installerSession) {
                    var _this = this;
                    this._viewerByURI.forEach(function (viewer, realityUri, map) {
                        var installers = _this._installersByURI.get(realityUri);
                        if (installers && installers.has(installerSession)) {
                            installers.delete(installerSession);
                            if (installers.size === 0 && viewer.session) {
                                _this._handleUninstall(viewer.session, realityUri);
                                _this._installersByURI.delete(realityUri);
                            }
                        }
                    });
                };
                return RealityServiceProvider;
            }());

            _export('RealityServiceProvider', RealityServiceProvider = __decorate$9([autoinject, __metadata$9("design:paramtypes", [typeof (_c$5 = typeof SessionService !== "undefined" && SessionService) === "function" && _c$5 || Object, RealityService, typeof (_d$4 = typeof ContextService !== "undefined" && ContextService) === "function" && _d$4 || Object, typeof (_e$4 = typeof DeviceService !== "undefined" && DeviceService) === "function" && _e$4 || Object, typeof (_f$2 = typeof ViewServiceProvider !== "undefined" && ViewServiceProvider) === "function" && _f$2 || Object, typeof (_g$2 = typeof VisibilityServiceProvider !== "undefined" && VisibilityServiceProvider) === "function" && _g$2 || Object, typeof (_h$2 = typeof FocusServiceProvider !== "undefined" && FocusServiceProvider) === "function" && _h$2 || Object, RealityViewerFactory])], RealityServiceProvider));

            __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$2 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            openIcon = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='768' height='768'%3E%3Cpath fill='white' d='M448.5 96H672v223.5h-64.5v-114L294 519l-45-45 313.5-313.5h-114V96zm159 511.5V384H672v223.5c0 34.5-30 64.5-64.5 64.5h-447c-36 0-64.5-30-64.5-64.5v-447C96 126 124.5 96 160.5 96H384v64.5H160.5v447h447z'/%3E%3C/svg%3E\")";
            eyeIcon = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Cpath fill='white' d='M256 96C144.34 96 47.56 161.02 0 256c47.56 94.98 144.34 160 256 160 111.656 0 208.438-65.02 256-160-47.558-94.98-144.344-160-256-160zm126.225 84.852c30.08 19.187 55.57 44.887 74.717 75.148-19.146 30.26-44.637 55.96-74.718 75.148C344.427 355.258 300.78 368 256 368s-88.43-12.743-126.226-36.852c-30.08-19.186-55.57-44.886-74.716-75.148 19.146-30.262 44.637-55.962 74.717-75.148 1.96-1.25 3.938-2.46 5.93-3.65C130.725 190.866 128 205.612 128 221c0 70.69 57.308 128 128 128s128-57.31 128-128c0-15.387-2.726-30.134-7.704-43.8 1.99 1.19 3.97 2.402 5.93 3.652zM256 208c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48z'/%3E%3C/svg%3E\")";
            vrIcon = "url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E)";
            fullscreenIcon = "url('data:image/svg+xml;utf8,<svg width=\"512\" height=\"512\" version=\"1.1\" viewBox=\"-3 -3 17 17\" xmlns=\"http://www.w3.org/2000/svg\"><g fill=\"none\" fill-rule=\"evenodd\" id=\"Page-1\" stroke=\"none\" stroke-width=\"1\"><g fill=\"white\" id=\"Core\" transform=\"translate(-215.000000, -257.000000)\"><g id=\"fullscreen\" transform=\"translate(215.000000, 257.000000)\"><path d=\"M2,9 L0,9 L0,14 L5,14 L5,12 L2,12 L2,9 L2,9 Z M0,5 L2,5 L2,2 L5,2 L5,0 L0,0 L0,5 L0,5 Z M12,12 L9,12 L9,14 L14,14 L14,9 L12,9 L12,12 L12,12 Z M9,0 L9,2 L12,2 L12,5 L14,5 L14,0 L9,0 L9,0 Z\" id=\"Shape\"/></g></g></g></svg>')";
            argonAppIcon = "url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBYRXhpZgAATU0AKgAAAAgABAExAAIAAAARAAAAPlEQAAEAAAABAQAAAFERAAQAAAABAAAAAFESAAQAAAABAAAAAAAAAABBZG9iZSBJbWFnZVJlYWR5AAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCACQAJADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9ObW1tTbW5NrbDMEJwtvCo5jU8KqBVHoFAAHAAFT/AGS1/wCfW3/78x//ABNFp/x6Wv8A17w/+i1qxX/ILOVXnl71T4n1l3/4C+4/1nUNF7vRfZ8vQr/ZLX/n1t/+/Mf/AMTR9ktf+fW3/wC/Mf8A8TViip5qv81T75f10X3D5P7v/kv/AACv9ktf+fW3/wC/Mf8A8TR9ktf+fW3/AO/Mf/xNWKKOar/NU++X9dF9wcn93/yX/gFf7Ja/8+tv/wB+Y/8A4mj7Ja/8+tv/AN+Y/wD4mrFFHNV/mqffL+ui+4OT+7/5L/wCv9ktf+fW3/78x/8AxNH2S1/59bf/AL8x/wDxNWKKOar/ADVPvl/XRfcHJ/d/8l/4BX+yWv8Az62//fmP/wCJo+yWv/Prb/8AfmP/AOJqxRRzVf5qn3y/rovuDk/u/wDkv/AK/wBktf8An1t/+/Mf/wATR9ktf+fW3/78x/8AxNWKKOar/NU++X9dF9wcn93/AMl/4BX+yWv/AD62/wD35j/+Jo+yWv8Az62//fmP/wCJqxRRzVf5qn3y/rovuDk/u/8Akv8AwCv9ktf+fW3/AO/Mf/xNQXVrai2uCLW2OIJjhreFhxGx5VkKsPUMCCOCCKv1Xu/+PS6/695v/RbVVOVT2kNZ/HHrLuv8kJw0fu9H9ny9BLP/AI87T/r2g/8ARS1ZqtZ/8edp/wBe0H/opas1pP45f4pfmzVT0Wj2X5L/AIP9PQoooqR8/k/6/p/09CiiigOfyf8AX9P+noUUUUBz+T/r+n/T0KKKKA5/J/1/T/p6FFFFAc/k/wCv6f8AT0KKKKA5/J/1/T/p6FFFFAc/k/6/p/09Cq15/wAed3/17T/+imqzVa8/487v/r2n/wDRTVdP+JT/AMcf/SkJz0ej2f5f8P8A09Cz/wCPO0/69oP/AEUtWarWf/Hnaf8AXtB/6KWrNKfxy/xS/NmS2XovyCiiipGFfpT8AP2E/C3xX+E3hT4ieLPF/jLQdT8VRX+o2+l6Kuix2cGkLqV3a6RN/wATHSr25eW/sLeDUHczCPbdIqRqFy35v2WmX2t3+naHpkck2pa5qOn6Jp0USl5JL/V7yHTrRUUZLN59zGcAdAT2r+ofwn4dsfCHhfw54U0xdmneGtC0nQbEYx/oukWMFhAWHPztHArOSSWcliSSSf8ARL9nx4C8H+L3E3H+eeIPDuF4l4Y4YyXLctwuX4+WKpYWWf57jZYmji4SwtbD1KtXA5fk+NpSp+1dOnHMqc6lNylQlH8B8e+O834RyvIcHw/mFTLs0zTHYnEVMRRjSnVjgMvoRhUpONanVhGOIxOOoTjLlUm8JNRklzp/n7/w7R+F/wD0Ub4kf99eFv8A5n6/N/8Aac+FFj+z98ZIvhnBqN/qGk614T0nxX4R1fV3tDe6tFNc3+ma3p90bO3tLWK907U9PZ7aNIE8+xvLb70wJf8ApCr8h/8Agrd8Pjf+AfhZ8VLSGJZ/B/i278JavcorLd/2T41tI5dObzFGfJtPEOhWEceXBil1IvGMu5H9ifSo+iB4N5Z4KcU594fcB5bwxxHw7PLs4p5hldTMqmIll9HGUsLmlGpTxWNxFGph6eBxVXHVoOClJYJKFSlO1SP5D4X+LvGOK4zyzAcQZ5XzPLsxjiMG8PiYYWEFiZ0ZVMLOEqNCnONWdejDDwfM1+/1jJaP8x6K4Xwp4r/tPy9M1SQDU1G22uWwqamqjhHPCpqCgHjhbsDcuJQwPdV/hvmOXYrK8VPCYunyVIaxkrunWpttRrUZNLnpzs7OylGSlCcYVIThH+1cPiKWKpRrUZc0Xo09JQkt4TWtpK+q1TTUotxcZMooorhNwooooAKKKKACq15/x53f/XtP/wCimqzVa8/487v/AK9p/wD0U1XT/iU/8cf/AEpCez9H+QWf/Hnaf9e0H/opas1nWf8Ax52n/XtB/wCilqzSn8cv8UvzY42stXsunl6liiq9FSPTu/u/4J9X/sWeCf8AhNv2jfA4mglm0/wdHqfju/aMHbDJoduttojTNghVPiDUtMkUNjeYCFII4/oJr8r/APgmb4JEel/E74lXEDeZqOp6Z4I0i4OQrWejW/8AbGsbB0fzL/VrGF3HAewMf3lYD9TmZUVndlREUszMQqqqjLMzHACqASSSAAMmv+hT9nrwH/qd9HXKM4xFFUsfx9neb8WV3ONq0cFGpDJMqpSl/wA+ZYPKFmFCN3GKzGc9JVJpfwN9IHPP7W8QsTgqc3PD5BgMFlULP3XXnGWYYuVk3apGvjXhqnW+Gin8KOZ8MeMdA8Yf8JD/AGBei9/4RbxRq3g7Wtox9l1/RPs/9pWR5OWtzdQgk7SS3TGCfH/2s/hw/wAWP2cvi74JtoY5tUvvB2o6loIkjDlfEPh0J4h0IxEqzRSvqel20KyphlErc7SwPyN/wTW+LH/CyJ/2qvMlXffftAeIPiRYwMVEn9j/ABBEsVlKqDpF/wAUw0fykojDHG4Fv1AIBBBAIIwQRkEHqCD1Br+jOD88y3xr8Jfr+JWHqZXxtlPEuS4tYW1Si8LPGZtw9ieRTlNc3s6E21KTtUuuh+dZxgcTwXxZ9XpuaxWS4vLMbSc/iVVUcJmNO7SWilUitFsfxZW8wuIILhN6CaOKePqkib1WRDkYKSISDkEFWHHIr2Pwr4tGohNN1WVE1JFxb3TkImpIi/dkY4VL9FXLZIW6UFlxKGDH7QPw9f4UfHT4t/D3yDb2nh7x1rT6NGQFB8N69KviTw2yKOFjXRNYsoFVflUwsikha8V1MkadfsCVZbO6ZWBIZWWF2VlI5DKwDKw5BAI5Ff8APXxlwjKljs34bzin7DM8izPMMrrVIxvVwmYZdiquCxUUnZyp+3w8oVqMuVTjFfw6sKdSn/fWTZqpU8HmGElz4TH0MNiYRv7tbDYmnCtSldXSl7OopQmtYtu6cXKMvteH4cfEm4hiuLb4bfEK5t540mguLfwT4lnt54ZVDxTQTRaY0c0MqMrxSxsySIyujFSDVXUvA3jrRbOXUtb8C+NdF023MYuNS1jwpr2mafbmaVIYRPe3thBbQmaaSOGLzJV8yaSOJMu6qf6RfhFJJL8J/hhLK7SSy/DzwVJJI5LPJI/hvTGd2Y8lmYlmJ5JJNZ3xv+GNv8ZvhJ8QPhdc6g+kf8Jp4bvdItNZiRpZdF1Rgtxo+tRRLJEZpdH1WCy1KKHzEWWS1WN2CsTX951v2YWS1+Equb5P4nZ3is9rcOzzLK8tr8P5dSweJzaplv1rBYGtiP7SjOnhq2MdOhUr2UoUpupZONj8Qp/SXxEM2hhMZwzhKOBjmMcNisVDMcROtSwkcSqVfEQpfVbTqQoqdSNO9pSXLfVW/nk8B/Cb4m/FFrz/AIV54G1/xZDp0ogv77T4IINLs7ll3i1n1bUbiy00Xez5jaJdPcopDPCqspOT4x8C+NPh5q40Dx34X1fwprL263kNhrECRPdWTSyQLfWU0Ms9re2bTwzQC5tZ5ovOhliZhIjKP6VfAHgbw78NfB3h/wAD+FbKOx0Tw7p0FhaoiIsty8a5utQvXRV+0ajqV0Zr7UbtwZbq9uJp5CXkJr8Qf+Cqer3mjftDfC66tGyD8IZkuLWRmFvdw/8ACaaqTFKBna4I3QzqN8L4IypZT+Z+Nf0Csl8IPAyPHFTjHN828QMHXyShmmCjSwNLhWeJzSvCjisHgIvDLM4xwk6jpYfMMRjHHF+yVapgcJGs6dD6Tgzx1xPF3GzyOGTYXCZBVp46phcTKdeebKnhaUqlOtiLVvqn75R5qmHp0b0VL2ccRXlT9pV+PaKyNM1O01e0S9snLRk7JYnwJrWcDLW9wo+669VYfJKmJIyVJAv1/mhVpVaFWpRrU5UqtKThUpzXLOE47xkujX47rQ/o2EoTjGcJ80JJSjKNmmmrppqRYqtef8ed3/17T/8AopqWq15/x53f/XtP/wCimpU/4lP/ABx/9KQ3az1ez6eXqFn/AMedp/17Qf8Aopas1Ws/+PO0/wCvaD/0UtWaU/jl/il+bEtl6L8gprusaPI5wkas7n0VQWY/gATTq7X4aeD3+IXxH8BeBFEmzxZ4u0PR7to1LNHpct5HPrM3AYqsOjwX0rNg7QhbtXo5LlWNz7OMqyPLaLxGYZxmWCyvA0FdOtjMfiaWFw1JNKTTnWqwjdRbV9nsY4nE0cFhsRjMTP2eGwlCtisRU/590MPTlWrT/wC3KcJS+R++/wCyX4GPw+/Z7+GeizQGDUdQ0GPxTrCsCJP7U8WSyeILlJVIBWS2XUIrMoQGjW2VGyyknof2kPGh+HnwC+MfjRJDFcaB8OfFl3YyAgFNTk0e6tdKIzwT/aNxa8dW+6OSK9oiijgijhhRY4oUSKKNFCpHHGoRERRwqqoCqBwAABXmvxi+E3hf44fDzXfhj40m1uHwx4kOnDVl8P6pJo2o3EOmanZ6tDbC+ijldLaa6sYFu4guLi33wMdjtX/VDQ4RxXC/hRT4F4P9isdkPAK4W4bnWqPCUHjsvyD+y8rr16yhVlRjPE06NavW5Ks43nUaqT3/AMwJ5vSzTiyWe5z7T6vj+IP7VzNU4+1qKhiMw+tYuFKDlBTlGlOcKcHKEXaMbxW34X/8EnfFH/COfH3xL4LlkJh8afCyXyQWPzan4K1ewu4WI6OX0/WtWZj97MYI431/Q7XxJ8I/2AfgL8EviHoPxP8AA0vxBh8T+HY9VhsTqvjO61TTZrfWdMudKv7e9sJrVY7mGS2uWdFLKY7mK3nUh4Vr7br89+jH4dcZeFfhjDgvjWWWzx2X59muIy15VjZY7DLKswWFxcYyqTw2FlCssxq5k5U/ZySjKE1N87hD3/EviHJ+KeJXnOS/WvY4jAYWnivrdCOHqfW8O6tFtQjWrJw+rQwyUuZXkpLl0u/5/v8Agq78PD4f+NXgT4k2tqsVj8RfBU2h6hcKwzP4k8C3o2mRAAVebw9r2nxI7E+ZHpbKpxDhfyq1P/kG6h/143f/AKTyV/R7/wAFQfh9/wAJd+zNd+K7a2hk1L4V+K9C8Yi4Yf6RDoV1LJ4a8SJAe6fYNaS+uI+Ny6aj5zGAf5wtU/5Buo/9eN3/AOk8lf5h/TI4O/1S8duJMRSpOngeLsLl/FuD91pOpmFKWDzR83wylPOsvzGu0rOMa8FJN+/P+lfCDN/7V4JyqMpc1bKq1bKK2t3bDTjWwul21GOBxOFpq+7pytoj+xD4Pf8AJJPhb/2TnwR/6jOmV6NXnPwe/wCSSfC3/snPgj/1GdMr0av9qOG/+SdyD/sS5X/6g0D+Ncx/5GGO/wCwzE/+npn5d/tIf8FMfDPwe8f6x8Nfh/4Db4k614Vuzp3i7W7vxCvh7w3pWtRBWu/D9hLDpmr3usanp29YtWljgtbHTr0PYGe5u4bmK2/KT9rf9pO0/ak8aeCfHMPhC+8E3nh3wTP4U1XSLvVbXWrea7bXrvVo73TNRtreyeW0eG52Ol5Y2dxFKNgSVB5rfMmrXE93rfiK7uZXnubvxN4mu7maQlpJrm61/Ubi4mdjks8s0jyOSSSzEmqNf4b+LH0lPE/xTXEOR53m9CnwdmWaQxOD4YoZXlVOjltLL8Z7fLo08xjglm1avSUIrEVa+PqRxE5VG6cIeyp0v7Y4X8O+GeF3gMbgcHOWb4bCypVczqYrFSqYmdeh7PEynh3WeEhCpeTpwp0IuklFKcpc8p6ekatd6LeC7tCG3AJc2zkiC8gBz5UuPuuvWCcDfC+CMoWU+36bqVpq1ol7ZOWjY7JI3wJraYDLW9wg+7IvVWHySpiSMlScfPtaek6td6NeLd2hDbgEubZyRDeQA58qXH3XXkwTgb4X5GULKf5Q4k4bpZxSeIw6jSzGlG0Jv3YYmEdqNZ7KVtKVV/B8E702nD9Ry3MpYOSp1G5Yab1WrdJtq84K+388OvxR974vfarXn/Hnd/8AXtP/AOimqLTdStNWtEvbJy0THZJG+BNbTAZe3uFH3ZF6hh8kqYkjJU8S3n/Hnd/9e0//AKKavx90qtDE+xrU5UqtKqoVKc1yzhOMleMl0a/HdaH2CnGdNThJShKPNGUXdNNXTTQlmR9jteR/x7Qf+ilqzuHqPzrPszm0tT/07Qf+ilqzROC55av4pfn/AMP/AFvUdl6L8ifcPUfnX3n/AME7fBY8RfHPUvFs6SG0+HnhC9uoJFTdD/bfiqU6JZo7kbVcaRHr7oAd+dpA27iPgWv23/4JweCf7C+C+teM54pI7z4g+L9QuYXcYV9E8MD/AIR/TjHxlka/g1q4DZKn7R8oGCW/rv6C/AP+vH0keCJVqXtsBwd9d45x9483s3kFODyirbZcvEWKyf3n8N7r31G/5R4255/YfhznrhPkxGbqhkWG1tzPMZv63Du+bLKOP/Dbc/QmvnX4zftW/Av4Aa5ovhv4qeMJfD2s+INJuNb0uzg8P+ItaM2mW14LCS5kl0XS7+G3Bui0UcdxJHLKY5WjRljZh9FV/NL/AMFJvFknif8Aa08V6eLr7TZeBvCfgzwlaIG3R2txLp83inVIUHRXNz4jjE46+ZFg/dFf7YfSZ8X838FvDinxRw/h8pxWeY/iHLMiy6hnVHE4nAOWJoY7HYqdTD4PG5fiKjhgcuxPs+TFU4xqyhKfNH3X/F/htwlhOMuIZ5ZmFTFUsFh8uxOOxE8HUp0q9qdShh6UYVK1DEU1eviaTknSbcFJRadmv1tl/wCClH7HcEUk0vxPvVjhjeWRv+EE8ettSNSzHavhsscKCcKCT2BNfb2lapYa3pem61pVwl5pmr2Fnqmm3cYdY7qwv7eO7s7lFkVHCT28scqh0VwGAZVOQP4w5EWVHjcZSRGRh6q4KsPxBNf1T/sT+MZvHX7KvwQ1y6kSS9g8E2Xhu+KNuIu/B09z4Tl8zkkSv/YolcNzmTPIIJ/IPoq/Sc4x8auKeJeGeM8Dwxg6+XZBTzzKnw9gMywM6tOhmGHwGYxxKzDOc29qoSzDAOl7JUXDmnzud1y/WeJ/htlHB2V5dmWT1syrQr4+WBxax9fDV1GVTDzr4d0lQweFcW/q+IU3JzT9xJJpuXuXxF8G2HxE8A+NPAeqRwyWHjHwtrvhq5FxGJIkTWdMubATMpVvmt3nWeNgC6SRo6YdVI/jf1rT9Q0i213RtWRotW0T+2dD1aNxho9V0aS70vUkPTOy+tJ1Bx8wAYda/tSr+WX/AIKC/D0/Dj9pr4wWkNuYNK8ZwW/xK0fCLHFJH4s06X+2/JVeAF8V6dr7SY6tIJCAZMD439oRwd9a4c4E48oUr1MozXG8M5hUhFOTwuc4f+0MvnVfK5RpYbFZVi6UHzxiquYqLUpThy+14AZv7PMs6yKpL3cVh8NmeHTeiq4OssNiIwXWdWli6U3a75MLfZNn9Knwe/5JJ8Lf+yc+CP8A1GdMr0avOfg9/wAkk+Fv/ZOfBH/qM6ZXo1f37w3/AMk7kH/Ylyv/ANQaB+C5j/yMMd/2GYn/ANPTP4v73/kJ6z/2Hte/9PN9VerF7/yE9Z/7D2vf+nm+qvX/ADb4j/eK/wD1+q/+lyP9EofBH/DH8kFFFFYlGnpOrXmjXYu7Rg2QEubZyRBeQg5MUuPuuvWCcDfC+CMqWU+yxanZ6tpE97ZOWja3nSSJ8Ce2nELFre4UfdkXnaw+SVcSRkg4Hg9W7TVrvRjcXVqwIa2lS5t3J8m7gEbZjlAyQ6/egmUb4nwRlSVr5jiDhylm6jiKCjSzGly8k9o4iEWrUaz/AJklalVesPgl+7acPUy7Mp4NulUvPDTbvHVulJ7zguz+3D7Wso+9pL3Sz/487T/r2g/9FLVmq1n/AMedp/17Qf8Aopas1+QT+OX+KX5s+zWy9F+QV7bZ/tpftQfCvwroXhnwJ4k8H2fgnw3p1rpGm2E/gHTb280q2t12Iby8a7je9W4fdLNqEkayyXUsrXXzSbz4lSEAhlZVZWVkdHUMjoww6OjZV0cEhlIwRX3PAHiVxp4ZZrXzfgviLOOHcVjsMsBmNTJ8wxGW1sbgPbU67wtSvhpwqcirUqdaGriqtOEpRnFOEvEz7h3KOJcJDB5xgMJj6VGr9Yw8cZhqWJp0cQoSpqrGnWjKHNyTnBuylyTkoyi2mvZP+HlP7YH/AEOfgj/w3Ol//J1fG/jHxbr3j7xd4m8deKrqK+8T+L9YuNe1+8t7ZbO2uNSuljjka2so2eOzt0ihhigto2ZYo41UMetXfE3hk6WXv7BWbTHb97Fks+mu5wFP8T2TscQynJh4il4CuePr93znxX438R8swceJONuJOKMuw9d4nDYTO84xuYU8HjPZulUl7DE16sKOKhTqSpykld053hOVKpGU/gsLwvk/DuJrf2fkuW5ZiKlNUqlXA4KhhpV6POpxXtKVOEqlJzipJN2542klODSK+oPhL+2V+0L8DvBtv4A+G/ifw9p/hW01HVNUtbLWfCVjrt1Bd6zdvf6iI764uYZfs8t5LNPFAVIgMrqjFcAfL9FcvDXFfE3B2YSzbhTPs24czOeGqYOePybHYjL8XPCVp0qlXDSr4apTqSoVKlGjOdJtwlOlTk1zQi1eYZZl2bYdYXNMDhMwwyqRrLD4zD08TRVWClGFRU6sZRVSMZzjGaXMlOSTtJ3+6/8Ah5T+2B/0Ofgj/wANzpf/AMnV84/Gz46fEj9ojVtJ134sXuhatq+iaNeeH7C90Pw/a+HZTo99ci8ms7w2s05vBDc+ZNZPIR9ja6vfLB+1SV5FRX0XEHix4m8WZZWyXibj3izP8or1KNWtlubZ5j8dgqtTD1Y1qFSeHxFedOU6VWEalOTjeMldM4cBwxw5lWJhjcsyPKsBi6anGGJwmAw2HrxjUi4TjGrSpxmlOLcZK9pJtPQ+2NF/4KI/tY+HtG0nQNK8X+DIdL0PTLDR9Nil+H2mTyxWGmWsVlZxyzG9UzSJbwRq8pVTIwLlRnFaf/Dyn9sD/oc/BH/hudL/APk6vhSivWpeO/jRQpUqFHxT48pUaNOFKlShxNmsYU6dOKhThCKxNoxhFKMUtEkkjklwTwfOUpz4YyGU5ycpSllWDblKTvKTbo3bbbbfVj5HaWaed8GW5ubm7mIG1Wnu55LmdlUcIrTSuVQcIpCDhRTKKK/KG222222223dtt6ttvdt7s+nCiiikAVXu/wDj1uf+veb/ANFtViq93/x63P8A17zf+i2qofHH/FH80B9DWZH2O15H/HtB/wCilqzuHqPzqhaf8ett/wBe8P8A6LWrFfzvP45f4pfmz9Hi7xi+6X5E+4eo/OjcPUfnUFFSMnJUghtjKysjK4DI6MMMjqeHRwcMp4IryfxL4a/ssvqGnqX0tmHmxAl3012PCsSSWsnbiGU5MJIhlONjH1Gl4wQyq6spR0dQySIwwyOjZVkYcMpBBFevk+cYnJ8T7aj79Gdo4nDSbUK8E+9nyVYXbpVUm4NtNTpyqU58eNwVLG0uSfuzjd06qV5Ql+sZWSnG+q1TUlGS+fqK6/xL4aOmFtQ09WfS3b97Fyz6bI7cIerNZMTiKU8wnEUpxsauQr9lwGPw2ZYani8LPnpT0aek6c0k5UqsbvkqQurq7TTjODlCUZS+JxGHq4arKlWjyyjr3jKL2lF9Yvo+jTTSkmkUUUV2GIUUUUAFFFFABRRRQAVXu/8Aj1uf+veb/wBFtViq93/x63P/AF7zf+i2qofHH/FH80B9AWn/AB623/XvD/6LWrFULW6tRbW4N1bHEEIytxCwOI1HDK5Vh6MpII5BIqf7Xa/8/Nv/AN/o/wD4qv56nCfPL3J/E/svv6ea+8/RYSXLHVfDHquy/wA0WKKr/a7X/n5t/wDv9H/8VR9rtf8An5t/+/0f/wAVU8k/5J/+Av8Ay8195XNH+Zfev66r7yxRVf7Xa/8APzb/APf6P/4qj7Xa/wDPzb/9/o//AIqjkn/JP/wF/wCXmvvDmj/MvvX9dV95ZzwQQrKysjo4DI6MMMjqeGRgSGU8EV5Z4l8N/wBmFr/T1ZtLZv3sPLPprtjCsTy9m7HEUpyYSRFKcFGr0r7Xa/8APzb/APf6P/4qj7XaEMrXFq6spV0eWJkdGGGR1LEMrDhlIIIr1smzXGZPiVWoxnOjPljicO1JQr00+9nyVYXbpVUm4NtNSpznCfFjcJQxtLkm4xmrunUVnKEnb/wKL0Uo3SkrbSUZR8HorpvEmjW2ms19YTwvpzsPMhE0bSWEjE/Kfmy1mx4ikPMJxHIcbWrkftdr/wA/Nv8A9/o//iq/ZcDjKOY4anisK5Tp1FqnG06c1bmpVY68tSF1dXaacZQcoSjKXxdehUw1WVGqkpR1TTvGcX8M4P7UZdHve8WlJNKxRVf7Xa/8/Nv/AN/o/wD4qj7Xa/8APzb/APf6P/4quzll/LL7n/XVfeY3/r+vVfeWKKr/AGu1/wCfm3/7/R//ABVH2u1/5+bf/v8AR/8AxVHLL+WX3P8ArqvvC/8AX9eq+8sUVX+12v8Az82//f6P/wCKo+12v/Pzb/8Af6P/AOKo5Zfyy+5/11X3hf8Ar+vVfeWKr3f/AB63P/XvN/6Laj7Xa/8APzb/APf6P/4qoLq6tWtrhRc22WglAzPCoyY2AyzOFUepJAHUkCnCMuaPuv4o9H3X+aFdd1/X/Do//9k=)";

            _export('DefaultUIService', DefaultUIService = function () {
                function DefaultUIService(sessionService, viewService, realityService, realityServiceProvider, deviceService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.viewService = viewService;
                    this.realityService = realityService;
                    this.realityServiceProvider = realityServiceProvider;
                    this.deviceService = deviceService;
                    this.realityViewerItemElements = new Map();
                    this.menuItems = [];
                    this.menuOpen = false;
                    var config = this.sessionService.configuration.defaultUI || {};
                    if (document && !config.disable) {
                        var style = document.createElement("style");
                        style.type = 'text/css';
                        document.head.insertBefore(style, document.head.firstChild);
                        var sheet = style.sheet;
                        sheet.insertRule("\n                .argon-ui {\n                    -webkit-tap-highlight-color: transparent;\n                    -webkit-user-select: none;\n                }\n            ", sheet.cssRules.length);
                        sheet.insertRule("\n                .argon-ui-button {\n                    background-image: " + argonAppIcon + ";\n                    width: 144px;\n                    height: 144px;\n                }\n            ", sheet.cssRules.length);
                        sheet.insertRule("\n                .argon-ui-blur {\n                    background-color: rgba(238, 178, 17, 0.7);\n                    -webkit-backdrop-filter: blur(5px);\n                }\n            ", sheet.cssRules.length);
                        sheet.insertRule("\n                .argon-ui-box {\n                    webkit-user-select: none;\n                    ms-user-select: none;\n                    user-select: none;\n                }\n            ", sheet.cssRules.length);
                        sheet.insertRule("\n                .argon-ui-list-item {\n                    align-items: center;\n                    background: white;\n                    border-top: 1px solid lightgrey;\n                    display: flex;\n                    height: 20px;\n                    justify-content: space-between;\n                    padding: 20px;\n                    width: 100%;\n                    cursor: pointer;\n                    font-family: 'Sans-serif';\n                    font-size: 12px;\n                    color: #5F5F5F;\n                    box-sizing: border-box;\n                }\n            ", sheet.cssRules.length);
                        sheet.insertRule("\n                .argon-ui-list-item:hover {\n                    background: rgb(240,240,240);\n                }\n            ", sheet.cssRules.length);
                        this.element = document.createElement('div');
                        this.element.className = 'argon-ui';
                        this.element.style.position = 'absolute';
                        this.element.style.bottom = '0';
                        this.element.style.right = '0';
                        this.element.style.width = '100%';
                        this.element.style.height = '100%';
                        this.element.style['userSelect'] = 'none';
                        this.element.style.webkitUserSelect = 'none';
                        this.element.style.zIndex = '10';
                        this.element.style.pointerEvents = 'none';
                        this.element.style.overflow = 'hidden';
                        this.viewService.element.appendChild(this.element);
                        this.sessionService.manager.closeEvent.addEventListener(function () {
                            _this.element.remove();
                        });
                        var realityViewerOverlayElement_1 = document.createElement('div');
                        realityViewerOverlayElement_1.className = 'argon-overlay';
                        realityViewerOverlayElement_1.style.width = '100%';
                        realityViewerOverlayElement_1.style.height = '100%';
                        realityViewerOverlayElement_1.style.display = 'flex';
                        realityViewerOverlayElement_1.style.alignItems = 'center';
                        realityViewerOverlayElement_1.style.pointerEvents = 'auto';
                        realityViewerOverlayElement_1.addEventListener('click', function (e) {
                            if (e.target === realityViewerOverlayElement_1) {
                                realityViewerOverlayElement_1.remove();
                                e.stopPropagation();
                            }
                        });
                        // realityViewerOverlayElement.addEventListener('touchend', (e)=> {
                        //     if (e.target === realityViewerOverlayElement) {
                        //         e.preventDefault();
                        //         e.stopPropagation();
                        //         realityViewerOverlayElement.remove();
                        //     }
                        // });
                        this.realityViewerSelectorElement = document.createElement('div');
                        this.realityViewerSelectorElement.classList.add('argon-ui-box');
                        this.realityViewerSelectorElement.classList.add('argon-ui-blur');
                        this.realityViewerSelectorElement.style.maxWidth = '300px';
                        this.realityViewerSelectorElement.style.maxHeight = '70%';
                        this.realityViewerSelectorElement.style.width = '70%';
                        this.realityViewerSelectorElement.style.margin = 'auto';
                        this.realityViewerSelectorElement.style.padding = '20px';
                        this.realityViewerSelectorElement.style.boxShadow = 'rgb(102,102,102) 0 5px 20px';
                        realityViewerOverlayElement_1.appendChild(this.realityViewerSelectorElement);
                        var realitySelectorPrompt = document.createElement('h2');
                        realitySelectorPrompt.innerText = 'Select a Reality';
                        realitySelectorPrompt.style.fontFamily = 'Sans-Serif';
                        realitySelectorPrompt.style.color = 'white';
                        realitySelectorPrompt.style.marginTop = '0';
                        realitySelectorPrompt.style.flex = '0 1 auto';
                        this.realityViewerSelectorElement.appendChild(realitySelectorPrompt);
                        this.realityViewerListElement = document.createElement('div');
                        this.realityViewerListElement.style.flex = '1 1 auto';
                        this.realityViewerListElement.style.maxHeight = '250px';
                        this.realityViewerListElement.style.overflowY = 'auto';
                        this.realityViewerSelectorElement.appendChild(this.realityViewerListElement);
                        this.realityServiceProvider.installedEvent.addEventListener(function (_a) {
                            var viewer = _a.viewer;
                            var uri = viewer.uri;
                            var e = document.createElement('div');
                            e.innerText = uri;
                            viewer.connectEvent.addEventListener(function (session) {
                                e.innerText = session.info.title || uri;
                            });
                            e.className = 'argon-ui-list-item';
                            _this.realityViewerItemElements.set(uri, e);
                            _this.realityViewerListElement.appendChild(e);
                            e.addEventListener('click', function () {
                                _this.realityService.request(uri);
                                realityViewerOverlayElement_1.remove();
                            });
                        });
                        this.realityServiceProvider.uninstalledEvent.addEventListener(function (_a) {
                            var viewer = _a.viewer;
                            var uri = viewer.uri;
                            var e = _this.realityViewerItemElements.get(uri);
                            _this.realityViewerItemElements.delete(uri);
                            e.remove();
                        });
                        this.menuBackgroundElement = document.createElement('div');
                        this.menuBackgroundElement.className = 'argon-ui-blur';
                        this.menuBackgroundElement.style.position = 'absolute';
                        this.menuBackgroundElement.style.bottom = '-150px';
                        this.menuBackgroundElement.style.right = '-150px';
                        this.menuBackgroundElement.style.width = '300px';
                        this.menuBackgroundElement.style.height = '300px';
                        this.menuBackgroundElement.style.transform = 'scale(0.1)';
                        this.menuBackgroundElement.style.transition = 'transform 0.3s, opacity 0.3s';
                        this.menuBackgroundElement.style.borderRadius = '150px';
                        this.menuBackgroundElement.style.zIndex = '-2';
                        this.element.appendChild(this.menuBackgroundElement);
                        var menuButton = document.createElement('div');
                        this.element.appendChild(menuButton);
                        menuButton.className = 'argon-ui-button';
                        menuButton.style.position = 'absolute';
                        menuButton.style.bottom = '0';
                        menuButton.style.right = '0';
                        menuButton.style.transform = 'scale(0.36)';
                        menuButton.style.transformOrigin = '110% 110%';
                        menuButton.style.borderRadius = '72px';
                        menuButton.style.cursor = 'pointer';
                        menuButton.style.pointerEvents = 'auto';
                        menuButton.style.zIndex = '-1';
                        this.openInArgonMenuItem = this._createMenuItem(openIcon, 'Open in Argon');
                        this.openInArgonMenuItem.addEventListener('touchstart', function () {
                            openInArgonApp();
                        });
                        this.openInArgonMenuItem.addEventListener('touchend', function () {
                            if (confirm('Oops, it looks like you are still here! You may not have the Argon Browser installed. Would you like to install it now?')) {
                                installArgonApp();
                            }
                            _this.menuOpen = false;
                            _this.updateMenu();
                        });
                        this.hmdMenuItem = this._createMenuItem(vrIcon, 'Toggle HMD', function () {
                            _this.menuOpen = false;
                            _this.updateMenu();
                            if (_this.deviceService.isPresentingHMD) {
                                _this.deviceService.exitPresentHMD();
                            } else {
                                _this.deviceService.requestPresentHMD();
                            }
                        });
                        this.realityMenuItem = this._createMenuItem(eyeIcon, 'Select Reality Viewer...', function () {
                            _this.menuOpen = false;
                            _this.updateMenu();
                            realityViewerOverlayElement_1.style.backgroundColor = 'rgba(0,0,0,0.3)';
                            _this.element.appendChild(realityViewerOverlayElement_1);
                        });
                        this.maximizeMenuItem = this._createMenuItem(fullscreenIcon, 'Toggle Immersive View', function () {
                            _this.menuOpen = false;
                            _this.updateMenu();
                            if (_this.viewService.viewportMode === ViewportMode.IMMERSIVE) {
                                _this.viewService.desiredViewportMode = ViewportMode.EMBEDDED;
                            } else {
                                _this.viewService.desiredViewportMode = ViewportMode.IMMERSIVE;
                            }
                        });
                        this.onSelect(menuButton, this.toggleMenu.bind(this));
                        this.updateMenu();
                        this.viewService.viewportChangeEvent.addEventListener(function () {
                            _this.updateMenu();
                        });
                        this.viewService.viewportModeChangeEvent.addEventListener(function () {
                            _this.updateMenu();
                        });
                    }
                }
                DefaultUIService.prototype._createMenuItem = function (icon, hint, onSelect) {
                    var menuItem = document.createElement('div');
                    menuItem.style.position = 'absolute';
                    menuItem.style.bottom = '-20px';
                    menuItem.style.right = '-20px';
                    menuItem.style.textAlign = 'left';
                    menuItem.style.width = '40px';
                    menuItem.style.height = '40px';
                    menuItem.style.fontFamily = 'Arial Black';
                    menuItem.style.color = 'black';
                    menuItem.style.cursor = 'default';
                    menuItem.style.textShadow = '-1px -1px 0px #545454, 1px -1px 0px #545454, -1px 1px 0px #545454, 1px 1px 0px #545454';
                    menuItem.style.transition = 'transform 0.3s ease 0.1s, opacity 0.3s ease 0.1s';
                    menuItem.style.opacity = '0';
                    menuItem.style.pointerEvents = 'none';
                    menuItem.style.transformOrigin = '50% 50%';
                    menuItem.style.backgroundImage = icon;
                    menuItem.style.backgroundSize = '100% 100%';
                    menuItem.style.backgroundRepeat = 'no-repeat';
                    menuItem.style.zIndex = '2';
                    menuItem.style.cursor = 'pointer';
                    this.element.appendChild(menuItem);
                    menuItem.title = hint;
                    if (onSelect) this.onSelect(menuItem, onSelect);
                    menuItem.addEventListener('mouseenter', function () {
                        menuItem.style.color = '#eeb211';
                    });
                    menuItem.addEventListener('mouseleave', function () {
                        menuItem.style.color = 'white';
                    });
                    return menuItem;
                };
                DefaultUIService.prototype.onSelect = function (element, cb) {
                    element.addEventListener('touchend', function (ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        cb();
                    });
                    element.addEventListener('click', function (ev) {
                        ev.stopPropagation();
                        cb();
                    });
                };
                DefaultUIService.prototype.toggleMenu = function () {
                    if (this.menuOpen) {
                        this.menuOpen = false;
                    } else {
                        this.menuOpen = true;
                    }
                    this.updateMenu();
                };
                DefaultUIService.prototype._hideMenuItem = function (e) {
                    e.style.transform = 'scale(0.2)';
                    e.style.opacity = '0';
                    e.style.pointerEvents = 'none';
                };
                DefaultUIService.prototype.updateMenu = function () {
                    var _this = this;
                    if (this.deviceService.isPresentingHMD && isIOS) {
                        this.element.style.display = 'none';
                    } else {
                        this.element.style.display = 'block';
                    }
                    this.menuItems = [];
                    this.menuItems.push(null);
                    if (isIOS) this.menuItems.push(this.openInArgonMenuItem);else this._hideMenuItem(this.openInArgonMenuItem);
                    var parentElement = this.viewService.element.parentElement;
                    var parentWidth = parentElement ? parentElement.clientWidth : 0;
                    var parentHeight = parentElement ? parentElement.clientHeight : 0;
                    if (!(window.innerWidth === parentWidth && window.innerHeight === parentHeight)) this.menuItems.push(this.maximizeMenuItem);else this._hideMenuItem(this.maximizeMenuItem);
                    if (isIOS || 'getVRDisplays' in navigator) this.menuItems.push(this.hmdMenuItem);else this._hideMenuItem(this.hmdMenuItem);
                    if (this.realityViewerItemElements.size > 0) this.menuItems.push(this.realityMenuItem);else this._hideMenuItem(this.realityMenuItem);
                    this.menuItems.push(null);
                    if (!this.menuOpen) {
                        this.menuItems.forEach(function (e, i) {
                            if (!e) return;
                            _this._hideMenuItem(e);
                        });
                        this.menuBackgroundElement.style.transform = 'scale(0.1)';
                    } else {
                        var length_1 = this.menuItems.length;
                        this.menuItems.forEach(function (e, i) {
                            if (!e) return;
                            var angle = i / (length_1 - 1) * (Math.PI / 2 + Math.PI / 8) - Math.PI / 16;
                            var d = 100;
                            var x = d * Math.cos(angle);
                            var y = d * Math.sin(angle);
                            e.style.transform = "translateX(" + -x + "px) translateY(" + -y + "px) scale(0.8)";
                            e.style.opacity = '1';
                            e.style.pointerEvents = 'auto';
                        });
                        this.menuBackgroundElement.style.transform = 'scale(1)';
                    }
                };
                return DefaultUIService;
            }());

            _export('DefaultUIService', DefaultUIService = __decorate$2([autoinject(), __metadata$2("design:paramtypes", [typeof (_a$2 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$2 || Object, typeof (_b$2 = typeof ViewService !== "undefined" && ViewService) === "function" && _b$2 || Object, typeof (_c$1 = typeof RealityService !== "undefined" && RealityService) === "function" && _c$1 || Object, typeof (_d$1 = typeof RealityServiceProvider !== "undefined" && RealityServiceProvider) === "function" && _d$1 || Object, typeof (_e$1 = typeof DeviceService !== "undefined" && DeviceService) === "function" && _e$1 || Object])], DefaultUIService));

            __extends$5 = undefined && undefined.__extends || function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __decorate$14 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata$14 = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('VuforiaServiceProvider', VuforiaServiceProvider = function () {
                function VuforiaServiceProvider(sessionService) {
                    if (sessionService.isRealityManager) {
                        sessionService.connectEvent.addEventListener(function (session) {
                            session.on['ar.vuforia.isAvailable'] = function () {
                                return Promise.resolve({ available: false });
                            };
                        });
                        sessionService.connectEvent.addEventListener(function (session) {
                            session.on['ar.vuforia.init'] = function () {
                                return Promise.reject(new Error("Vuforia is not supported on this system"));
                            };
                        });
                    }
                }
                return VuforiaServiceProvider;
            }());

            _export('VuforiaServiceProvider', VuforiaServiceProvider = __decorate$14([inject(SessionService), __metadata$14("design:paramtypes", [typeof (_a$14 = typeof SessionService !== "undefined" && SessionService) === "function" && _a$14 || Object])], VuforiaServiceProvider));
            /**
             * A service for interacting with the Vuforia API
             */

            _export('VuforiaService', VuforiaService = function () {
                function VuforiaService(sessionService) {
                    this.sessionService = sessionService;
                }
                /**
                 * Resolves to a boolean indicating whether or not the Vuforia API is available on this system
                 */
                VuforiaService.prototype.isAvailable = function () {
                    return this.sessionService.manager.request('ar.vuforia.isAvailable').then(function (message) {
                        return message.available;
                    });
                };
                /**
                 * Initialize vuforia using an encrypted license.
                 * You can get a vuforia license key from https://developer.vuforia.com/
                 * You can encrypt your vuforia license with the tool at http://docs.argonjs.io/start/vuforia-pgp-encryptor
                 */
                VuforiaService.prototype.init = function (options) {
                    var _this = this;
                    if (typeof options === 'string') options = { encryptedLicenseData: options };
                    if (!options.encryptedLicenseData || typeof options.encryptedLicenseData !== 'string') throw new Error('options.encryptedLicenseData is required.');
                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
                        return new VuforiaAPI(_this.sessionService.manager);
                    });
                };
                /**
                 * Initialize vuforia with an unecrypted key.
                 * It's a bad idea to publish your unencrypted vuforia key on the internet.
                 * @private
                 */
                VuforiaService.prototype.initWithUnencryptedKey = function (options) {
                    var _this = this;
                    if (typeof options === 'string') options = { key: options };
                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
                        return new VuforiaAPI(_this.sessionService.manager);
                    });
                };
                return VuforiaService;
            }());

            _export('VuforiaService', VuforiaService = __decorate$14([inject(SessionService, VuforiaServiceProvider), __metadata$14("design:paramtypes", [typeof (_b$14 = typeof SessionService !== "undefined" && SessionService) === "function" && _b$14 || Object])], VuforiaService));

            _export('VuforiaAPI', VuforiaAPI = function () {
                function VuforiaAPI(manager) {
                    this.objectTracker = new VuforiaObjectTracker(manager);
                }
                return VuforiaAPI;
            }());

            _export('VuforiaTracker', VuforiaTracker = function () {
                function VuforiaTracker() {}
                return VuforiaTracker;
            }());

            _export('VuforiaObjectTracker', VuforiaObjectTracker = function (_super) {
                __extends$5(VuforiaObjectTracker, _super);
                function VuforiaObjectTracker(managerSession) {
                    var _this = _super.call(this) || this;
                    _this.managerSession = managerSession;
                    _this.dataSetLoadEvent = new Event$1();
                    _this.dataSetUnloadEvent = new Event$1();
                    _this.dataSetActivateEvent = new Event$1();
                    _this.dataSetDeactivateEvent = new Event$1();
                    _this._deprecatedDataSetInstanceMap = new Map();
                    managerSession.on['ar.vuforia.objectTrackerLoadDataSetEvent'] = function (message) {
                        _this.dataSetLoadEvent.raiseEvent(message);
                    };
                    managerSession.on['ar.vuforia.objectTrackerUnloadDataSetEvent'] = function (message) {
                        _this.dataSetUnloadEvent.raiseEvent(message);
                    };
                    managerSession.on['ar.vuforia.objectTrackerActivateDataSetEvent'] = function (message) {
                        var deprecatedDataSetInstance = _this._deprecatedDataSetInstanceMap.get(message.id);
                        if (deprecatedDataSetInstance) {
                            deprecatedDataSetInstance._onActivate();
                            _this.dataSetActivateEvent.raiseEvent(deprecatedDataSetInstance);
                        } else _this.dataSetActivateEvent.raiseEvent(message);
                    };
                    managerSession.on['ar.vuforia.objectTrackerDeactivateDataSetEvent'] = function (message) {
                        var deprecatedDataSetInstance = _this._deprecatedDataSetInstanceMap.get(message.id);
                        if (deprecatedDataSetInstance) {
                            deprecatedDataSetInstance._onDeactivate();
                            _this.dataSetActivateEvent.raiseEvent(deprecatedDataSetInstance);
                        } else _this.dataSetDeactivateEvent.raiseEvent(message);
                    };
                    return _this;
                }
                /**
                 * Deprecated. Please use createDataSetFromURI instead.
                 * @deprecated To be removed.
                 */
                VuforiaObjectTracker.prototype.createDataSet = function (url) {
                    var _this = this;
                    if (url && window.document) {
                        url = resolveURL(url);
                    }
                    return this.managerSession.request('ar.vuforia.objectTrackerCreateDataSet', { url: url }).then(function (message) {
                        var dataSet = new DeprecatedVuforiaDataSet(message.id, _this.managerSession);
                        _this._deprecatedDataSetInstanceMap.set(message.id, dataSet);
                        return dataSet;
                    });
                };
                /**
                 * Fetch a dataset from the provided url.
                 * If successfull, resolves to an id which represents the dataset.
                 */
                VuforiaObjectTracker.prototype.createDataSetFromURL = function (url) {
                    if (url && window.document) {
                        url = resolveURL(url);
                    }
                    return this.managerSession.request('ar.vuforia.objectTrackerCreateDataSet', { url: url }).then(function (message) {
                        return message.id;
                    });
                };
                Object.defineProperty(VuforiaObjectTracker.prototype, "createDataSetFromURI", {
                    get: function () {
                        return this.createDataSetFromURL;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                 * Load the dataset into memory, and return a promise which
                 * resolves to the contained trackables
                 */
                VuforiaObjectTracker.prototype.loadDataSet = function (id) {
                    var _this = this;
                    return this.managerSession.whenConnected().then(function () {
                        if (_this.managerSession.version[0] == 0) {
                            return _this.managerSession.request('ar.vuforia.dataSetLoad', { id: id });
                        }
                        return _this.managerSession.request('ar.vuforia.objectTrackerLoadDataSet', { id: id });
                    });
                };
                /**
                 * Unload a dataset from memory (deactivating it if necessary)
                 */
                VuforiaObjectTracker.prototype.unloadDataSet = function (id) {
                    var _this = this;
                    return this.managerSession.whenConnected().then(function () {
                        if (_this.managerSession.version[0] == 0) {
                            return _this.deactivateDataSet(id);
                        }
                        return _this.managerSession.request('ar.vuforia.objectTrackerUnloadDataSet', { id: id });
                    });
                };
                /**
                 * Load (if necessary) and activate a dataset to enable tracking of the contained trackables
                 */
                VuforiaObjectTracker.prototype.activateDataSet = function (id) {
                    id = id instanceof DeprecatedVuforiaDataSet ? id.id : id; // backwards compatability
                    return this.managerSession.request('ar.vuforia.objectTrackerActivateDataSet', { id: id });
                };
                /**
                 * Deactivate a loaded dataset to disable tracking of the contained trackables
                 */
                VuforiaObjectTracker.prototype.deactivateDataSet = function (id) {
                    id = id instanceof DeprecatedVuforiaDataSet ? id.id : id; // backwards compatability
                    return this.managerSession.request('ar.vuforia.objectTrackerDeactivateDataSet', { id: id });
                };
                return VuforiaObjectTracker;
            }(VuforiaTracker));

            __decorate$14([deprecated$1('createDataSetFromURL'), __metadata$14("design:type", Function), __metadata$14("design:paramtypes", [String]), __metadata$14("design:returntype", Object)], VuforiaObjectTracker.prototype, "createDataSet", null);
            __decorate$14([deprecated$1('createDataSetFromURL'), __metadata$14("design:type", Object), __metadata$14("design:paramtypes", [])], VuforiaObjectTracker.prototype, "createDataSetFromURI", null);
            /**
             * @deprecated To be removed.
             */

            _export('DeprecatedVuforiaDataSet', DeprecatedVuforiaDataSet = function () {
                function DeprecatedVuforiaDataSet(id, managerSession) {
                    this.id = id;
                    this.managerSession = managerSession;
                    this._isActive = false;
                }
                DeprecatedVuforiaDataSet.prototype._onActivate = function () {
                    this._isActive = true;
                };
                DeprecatedVuforiaDataSet.prototype._onDeactivate = function () {
                    this._isActive = false;
                };
                DeprecatedVuforiaDataSet.prototype.fetch = function () {
                    return this.managerSession.request('ar.vuforia.dataSetFetch', { id: this.id });
                };
                DeprecatedVuforiaDataSet.prototype.load = function () {
                    var _this = this;
                    return this.managerSession.request('ar.vuforia.dataSetLoad', { id: this.id }).then(function (trackables) {
                        _this._trackables = trackables;
                        return trackables;
                    });
                };
                DeprecatedVuforiaDataSet.prototype.isActive = function () {
                    return this._isActive;
                };
                DeprecatedVuforiaDataSet.prototype.getTrackables = function () {
                    return this._trackables;
                };
                return DeprecatedVuforiaDataSet;
            }());

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _export('ArgonSystemProvider', ArgonSystemProvider = function () {
                function ArgonSystemProvider(entity, context, focus, device, visibility, reality, view, vuforia, permission) {
                    this.entity = entity;
                    this.context = context;
                    this.focus = focus;
                    this.device = device;
                    this.visibility = visibility;
                    this.reality = reality;
                    this.view = view;
                    this.vuforia = vuforia;
                    this.permission = permission;
                }
                return ArgonSystemProvider;
            }());

            _export('ArgonSystemProvider', ArgonSystemProvider = __decorate([autoinject(), __metadata("design:paramtypes", [typeof (_a = typeof EntityServiceProvider !== "undefined" && EntityServiceProvider) === "function" && _a || Object, typeof (_b = typeof ContextServiceProvider !== "undefined" && ContextServiceProvider) === "function" && _b || Object, typeof (_c = typeof FocusServiceProvider !== "undefined" && FocusServiceProvider) === "function" && _c || Object, typeof (_d = typeof DeviceServiceProvider !== "undefined" && DeviceServiceProvider) === "function" && _d || Object, typeof (_e = typeof VisibilityServiceProvider !== "undefined" && VisibilityServiceProvider) === "function" && _e || Object, typeof (_f = typeof RealityServiceProvider !== "undefined" && RealityServiceProvider) === "function" && _f || Object, typeof (_g = typeof ViewServiceProvider !== "undefined" && ViewServiceProvider) === "function" && _g || Object, typeof (_h = typeof VuforiaServiceProvider !== "undefined" && VuforiaServiceProvider) === "function" && _h || Object, typeof (_j = typeof PermissionServiceProvider !== "undefined" && PermissionServiceProvider) === "function" && _j || Object])], ArgonSystemProvider));
            /**
             * A composition root which instantiates the object graph based on a provided configuration.
             * You generally want to create a new ArgonSystem via the provided [[init]] or [[initReality]] functions:
             * ```ts
             * var app = Argon.init(); // app is an instance of ArgonSystem
             * ```
             */

            _export('ArgonSystem', ArgonSystem = ArgonSystem_1 = function () {
                function ArgonSystem(container, entity, context, device, focus, reality, session, view, visibility, vuforia, permission) {
                    this.container = container;
                    this.entity = entity;
                    this.context = context;
                    this.device = device;
                    this.focus = focus;
                    this.reality = reality;
                    this.session = session;
                    this.view = view;
                    this.visibility = visibility;
                    this.vuforia = vuforia;
                    this.permission = permission;
                    if (!ArgonSystem_1.instance) ArgonSystem_1.instance = this;
                    if (this.container.hasResolver(ArgonSystemProvider)) this._provider = this.container.get(ArgonSystemProvider);
                    this.session.connect();
                }
                Object.defineProperty(ArgonSystem.prototype, "provider", {
                    get: function () {
                        this.session.ensureIsRealityManager();
                        return this._provider;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "updateEvent", {
                    // events
                    get: function () {
                        return this.context.updateEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "renderEvent", {
                    get: function () {
                        return this.context.renderEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "focusEvent", {
                    get: function () {
                        return this.focus.focusEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "blurEvent", {
                    get: function () {
                        return this.focus.blurEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                ArgonSystem.prototype.destroy = function () {
                    this.session.manager.close();
                    if (ArgonSystem_1.instance === this) {
                        ArgonSystem_1.instance = undefined;
                    }
                };
                return ArgonSystem;
            }());

            _export('ArgonSystem', ArgonSystem = ArgonSystem_1 = __decorate([autoinject, __metadata("design:paramtypes", [typeof (_k = (typeof DI !== "undefined" && DI).Container) === "function" && _k || Object, typeof (_l = typeof EntityService !== "undefined" && EntityService) === "function" && _l || Object, typeof (_m = typeof ContextService !== "undefined" && ContextService) === "function" && _m || Object, typeof (_o = typeof DeviceService !== "undefined" && DeviceService) === "function" && _o || Object, typeof (_p = typeof FocusService !== "undefined" && FocusService) === "function" && _p || Object, typeof (_q = typeof RealityService !== "undefined" && RealityService) === "function" && _q || Object, typeof (_r = typeof SessionService !== "undefined" && SessionService) === "function" && _r || Object, typeof (_s = typeof ViewService !== "undefined" && ViewService) === "function" && _s || Object, typeof (_t = typeof VisibilityService !== "undefined" && VisibilityService) === "function" && _t || Object, typeof (_u = typeof VuforiaService !== "undefined" && VuforiaService) === "function" && _u || Object, typeof (_v = typeof PermissionService !== "undefined" && PermissionService) === "function" && _v || Object])], ArgonSystem));

            _export('ArgonConfigurationManager', ArgonConfigurationManager = function () {
                function ArgonConfigurationManager(configuration, container) {
                    if (container === void 0) {
                        container = new Container();
                    }
                    this.configuration = configuration;
                    this.container = container;
                    container.registerInstance(Configuration, configuration);
                    if (Role.isRealityManager(configuration.role)) container.registerSingleton(ArgonSystemProvider);
                    ArgonConfigurationManager.configure(this);
                }
                ArgonConfigurationManager.configure = function (configurationManager) {
                    configurationManager.standardConfiguration();
                };
                ArgonConfigurationManager.prototype.standardConfiguration = function () {
                    this.defaultConnect();
                    this.defaultUI();
                };
                ArgonConfigurationManager.prototype.defaultConnect = function () {
                    var container = this.container;
                    var configuration = this.configuration;
                    if (Role.isRealityManager(configuration.role)) {
                        container.registerSingleton(ConnectService, LoopbackConnectService);
                    } else if (WKWebViewConnectService.isAvailable()) {
                        container.registerSingleton(ConnectService, WKWebViewConnectService);
                    } else if (AndroidWebViewConnectService.isAvailable()) {
                        container.registerSingleton(ConnectService, AndroidWebViewConnectService);
                    } else if (DOMConnectService.isAvailable()) {
                        container.registerSingleton(ConnectService, DOMConnectService);
                    } else if (DebugConnectService.isAvailable()) {
                        container.registerSingleton(ConnectService, DebugConnectService);
                    }
                };
                ArgonConfigurationManager.prototype.defaultUI = function () {
                    if (Role.isRealityManager(this.configuration.role)) {
                        if (typeof document !== 'undefined') {
                            this.container.get(DefaultUIService);
                        }
                    }
                };
                return ArgonConfigurationManager;
            }());

            _export('initReality', initReality = initRealityViewer);

            _export('DI', DI);

            _export('Cesium', cesiumImports);

            _export('RealityViewer', RealityViewer);

            _export('EmptyRealityViewer', EmptyRealityViewer);

            _export('LiveRealityViewer', LiveRealityViewer);

            _export('HostedRealityViewer', HostedRealityViewer);

            _export('ArgonSystemProvider', ArgonSystemProvider);

            _export('ArgonSystem', ArgonSystem);

            _export('ArgonConfigurationManager', ArgonConfigurationManager);

            _export('init', init);

            _export('initRealityViewer', initRealityViewer);

            _export('initReality', initReality);

            _export('AVERAGE_EYE_HEIGHT', AVERAGE_EYE_HEIGHT);

            _export('DEFAULT_NEAR_PLANE', DEFAULT_NEAR_PLANE);

            _export('DEFAULT_FAR_PLANE', DEFAULT_FAR_PLANE);

            _export('Role', Role);

            _export('Configuration', Configuration);

            _export('Viewport', Viewport);

            _export('CanvasViewport', CanvasViewport);

            _export('SubviewType', SubviewType);

            _export('SerializedEntityState', SerializedEntityState);

            _export('SerializedSubview', SerializedSubview);

            _export('SerializedSubviewList', SerializedSubviewList);

            _export('ContextService', ContextService);

            _export('ContextServiceProvider', ContextServiceProvider);

            _export('EntityPose', EntityPose);

            _export('PoseStatus', PoseStatus);

            _export('EntityService', EntityService);

            _export('EntityServiceProvider', EntityServiceProvider);

            _export('FocusService', FocusService);

            _export('FocusServiceProvider', FocusServiceProvider);

            _export('DeviceStableState', DeviceStableState$$1);

            _export('DeviceFrameState', DeviceFrameState$$1);

            _export('DeviceService', DeviceService);

            _export('DeviceServiceProvider', DeviceServiceProvider);

            _export('RealityViewerFactory', RealityViewerFactory);

            _export('RealityService', RealityService);

            _export('RealityServiceProvider', RealityServiceProvider);

            _export('version', version);

            _export('SessionPort', SessionPort);

            _export('SessionPortFactory', SessionPortFactory);

            _export('ConnectService', ConnectService);

            _export('SessionService', SessionService);

            _export('LoopbackConnectService', LoopbackConnectService);

            _export('DOMConnectService', DOMConnectService);

            _export('DebugConnectService', DebugConnectService);

            _export('SessionConnectService', SessionConnectService);

            _export('WKWebViewConnectService', WKWebViewConnectService);

            _export('AndroidWebViewConnectService', AndroidWebViewConnectService);

            _export('DefaultUIService', DefaultUIService);

            _export('stringIdentifierFromReferenceFrame', stringIdentifierFromReferenceFrame);

            _export('jsonEquals', jsonEquals);

            _export('eastUpSouthToFixedFrame', eastUpSouthToFixedFrame);

            _export('getAncestorReferenceFrames', getAncestorReferenceFrames);

            _export('getReachableAncestorReferenceFrames', getReachableAncestorReferenceFrames);

            _export('getEntityPositionInReferenceFrame', getEntityPositionInReferenceFrame);

            _export('getEntityPosition', getEntityPosition);

            _export('getEntityOrientationInReferenceFrame', getEntityOrientationInReferenceFrame);

            _export('getEntityOrientation', getEntityOrientation);

            _export('getSerializedEntityState', getSerializedEntityState);

            _export('resolveURL', resolveURL);

            _export('parseURL', parseURL);

            _export('resolveElement', resolveElement);

            _export('decomposePerspectiveOffCenterProjectionMatrix', decomposePerspectiveOffCenterProjectionMatrix);

            _export('decomposePerspectiveProjectionMatrix', decomposePerspectiveProjectionMatrix);

            _export('convertEntityReferenceFrame', convertEntityReferenceFrame);

            _export('isIOS', isIOS);

            _export('installArgonApp', installArgonApp);

            _export('openInArgonApp', openInArgonApp);

            _export('requestAnimationFrame', rAF);

            _export('cancelAnimationFrame', cAF);

            _export('deprecated', deprecated$1);

            _export('defaultTerrainProvider', defaultTerrainProvider);

            _export('updateHeightFromTerrain', updateHeightFromTerrain);

            _export('getEventSynthesizier', getEventSynthesizier$1);

            _export('createEventForwarder', createEventForwarder$$1);

            _export('CommandQueue', CommandQueue);

            _export('Event', Event$1);

            _export('MessageChannelLike', MessageChannelLike);

            _export('SynchronousMessageChannel', SynchronousMessageChannel);

            _export('MessageChannelFactory', MessageChannelFactory);

            _export('Subview', Subview);

            _export('ViewportMode', ViewportMode);

            _export('ViewElement', ViewElement);

            _export('ViewService', ViewService);

            _export('ViewServiceProvider', ViewServiceProvider);

            _export('VisibilityService', VisibilityService);

            _export('VisibilityServiceProvider', VisibilityServiceProvider);

            _export('VuforiaServiceProvider', VuforiaServiceProvider);

            _export('VuforiaService', VuforiaService);

            _export('VuforiaAPI', VuforiaAPI);

            _export('VuforiaTracker', VuforiaTracker);

            _export('VuforiaObjectTracker', VuforiaObjectTracker);

            _export('DeprecatedVuforiaDataSet', DeprecatedVuforiaDataSet);

            _export('PermissionNames', PermissionNames);

            _export('Permission', Permission);

            _export('PermissionState', PermissionState);

            _export('PermissionService', PermissionService);

            _export('PermissionServiceProvider', PermissionServiceProvider);
        }
    };
});
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    Argon = factory();
});